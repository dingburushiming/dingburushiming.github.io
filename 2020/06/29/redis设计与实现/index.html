<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《Redis设计与实现》读书笔记 | 定不辱使命</title><meta name="description" content="《Redis设计与实现》读书笔记"><meta name="author" content="李上"><meta name="copyright" content="李上"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《Redis设计与实现》读书笔记"><meta name="twitter:description" content="《Redis设计与实现》读书笔记"><meta name="twitter:image" content="http://yoursite.com/img/redisdesign.jpg"><meta property="og:type" content="article"><meta property="og:title" content="《Redis设计与实现》读书笔记"><meta property="og:url" content="http://yoursite.com/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><meta property="og:site_name" content="定不辱使命"><meta property="og:description" content="《Redis设计与实现》读书笔记"><meta property="og:image" content="http://yoursite.com/img/redisdesign.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><link rel="prev" title="RocketMQ学习笔记" href="http://yoursite.com/2020/07/02/rocketmq/"><link rel="next" title="kafka学习笔记" href="http://yoursite.com/2020/06/23/kafka/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简单动态字符串SDS"><span class="toc-number">1.</span> <span class="toc-text">简单动态字符串SDS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SDS的定义"><span class="toc-number">1.1.</span> <span class="toc-text">SDS的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDS与C字符串的区别"><span class="toc-number">1.2.</span> <span class="toc-text">SDS与C字符串的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常数复杂度获取字符串长度"><span class="toc-number">1.2.1.</span> <span class="toc-text">常数复杂度获取字符串长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#杜绝缓冲区溢出"><span class="toc-number">1.2.2.</span> <span class="toc-text">杜绝缓冲区溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少修改字符串时带来的内存重分配次数"><span class="toc-number">1.2.3.</span> <span class="toc-text">减少修改字符串时带来的内存重分配次数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#空间预分配"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">空间预分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#惰性空间释放"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">惰性空间释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制安全"><span class="toc-number">1.2.4.</span> <span class="toc-text">二进制安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#兼容部分C字符串函数"><span class="toc-number">1.2.5.</span> <span class="toc-text">兼容部分C字符串函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.2.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾"><span class="toc-number">1.3.</span> <span class="toc-text">重点回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS的优点"><span class="toc-number">1.3.1.</span> <span class="toc-text">SDS的优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#链表"><span class="toc-number">2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#链表和链表节点的实现"><span class="toc-number">2.0.1.</span> <span class="toc-text">链表和链表节点的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis链表特性"><span class="toc-number">2.0.2.</span> <span class="toc-text">Redis链表特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#双端"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">双端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无环"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">无环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#带表头指针和表尾指针"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">带表头指针和表尾指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#带链表长度计数器"><span class="toc-number">2.0.2.4.</span> <span class="toc-text">带链表长度计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多态"><span class="toc-number">2.0.2.5.</span> <span class="toc-text">多态</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字典"><span class="toc-number">3.</span> <span class="toc-text">字典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#字典的实现"><span class="toc-number">3.1.</span> <span class="toc-text">字典的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希表"><span class="toc-number">3.1.1.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希表节点"><span class="toc-number">3.1.2.</span> <span class="toc-text">哈希表节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典-1"><span class="toc-number">3.1.3.</span> <span class="toc-text">字典</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希算法"><span class="toc-number">3.2.</span> <span class="toc-text">哈希算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如果要将一个键值对k0和v0添加到字典里面"><span class="toc-number">3.2.1.</span> <span class="toc-text">如果要将一个键值对k0和v0添加到字典里面</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决键冲突"><span class="toc-number">3.3.</span> <span class="toc-text">解决键冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例子"><span class="toc-number">3.3.1.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rehash"><span class="toc-number">3.4.</span> <span class="toc-text">rehash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例子-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希表的扩展与收缩"><span class="toc-number">3.4.2.</span> <span class="toc-text">哈希表的扩展与收缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渐进式rehash"><span class="toc-number">3.5.</span> <span class="toc-text">渐进式rehash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一次渐进式rehash过程"><span class="toc-number">3.5.1.</span> <span class="toc-text">一次渐进式rehash过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-1"><span class="toc-number">3.6.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#跳跃表"><span class="toc-number">4.</span> <span class="toc-text">跳跃表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#跳跃表的实现"><span class="toc-number">4.1.</span> <span class="toc-text">跳跃表的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zskiplist"><span class="toc-number">4.1.1.</span> <span class="toc-text">zskiplist</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zskiplistNode"><span class="toc-number">4.1.2.</span> <span class="toc-text">zskiplistNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跳跃表节点"><span class="toc-number">4.1.3.</span> <span class="toc-text">跳跃表节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#层"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#前进指针"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">前进指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#跨度"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">跨度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后退指针"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">后退指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分值和成员"><span class="toc-number">4.1.3.5.</span> <span class="toc-text">分值和成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跳跃表-1"><span class="toc-number">4.1.4.</span> <span class="toc-text">跳跃表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-2"><span class="toc-number">4.2.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#整数集合"><span class="toc-number">5.</span> <span class="toc-text">整数集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#整数集合的实现"><span class="toc-number">5.1.</span> <span class="toc-text">整数集合的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#升级"><span class="toc-number">5.2.</span> <span class="toc-text">升级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#升级后新元素的摆放那个位置"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">升级后新元素的摆放那个位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提升灵活性"><span class="toc-number">5.2.1.</span> <span class="toc-text">提升灵活性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#降级"><span class="toc-number">5.2.2.</span> <span class="toc-text">降级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-3"><span class="toc-number">5.3.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#压缩列表"><span class="toc-number">6.</span> <span class="toc-text">压缩列表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#压缩列表的构成"><span class="toc-number">6.1.</span> <span class="toc-text">压缩列表的构成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#压缩列表的各个组成部分"><span class="toc-number">6.1.1.</span> <span class="toc-text">压缩列表的各个组成部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#压缩列表各个组成部分的详细说明"><span class="toc-number">6.1.2.</span> <span class="toc-text">压缩列表各个组成部分的详细说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#示例"><span class="toc-number">6.1.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#压缩列表节点的构成"><span class="toc-number">6.2.</span> <span class="toc-text">压缩列表节点的构成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#previous-entry-lenth"><span class="toc-number">6.2.1.</span> <span class="toc-text">previous_entry_lenth</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#encoding"><span class="toc-number">6.2.2.</span> <span class="toc-text">encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#content"><span class="toc-number">6.2.3.</span> <span class="toc-text">content</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连锁更新"><span class="toc-number">6.3.</span> <span class="toc-text">连锁更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-4"><span class="toc-number">6.4.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象"><span class="toc-number">7.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的类型与编码"><span class="toc-number">7.1.</span> <span class="toc-text">对象的类型与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类型"><span class="toc-number">7.1.1.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编码和底层实现"><span class="toc-number">7.1.2.</span> <span class="toc-text">编码和底层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串对象"><span class="toc-number">7.2.</span> <span class="toc-text">字符串对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编码的转换"><span class="toc-number">7.2.1.</span> <span class="toc-text">编码的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串命令的实现"><span class="toc-number">7.2.2.</span> <span class="toc-text">字符串命令的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列表对象"><span class="toc-number">7.3.</span> <span class="toc-text">列表对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编码转换"><span class="toc-number">7.3.1.</span> <span class="toc-text">编码转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表命令的实现"><span class="toc-number">7.3.2.</span> <span class="toc-text">列表命令的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#哈希对象"><span class="toc-number">8.</span> <span class="toc-text">哈希对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#编码转换-1"><span class="toc-number">8.1.</span> <span class="toc-text">编码转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希命令的实现"><span class="toc-number">8.2.</span> <span class="toc-text">哈希命令的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合对象"><span class="toc-number">9.</span> <span class="toc-text">集合对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#编码的转换-1"><span class="toc-number">9.1.</span> <span class="toc-text">编码的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合命令的实现"><span class="toc-number">9.2.</span> <span class="toc-text">集合命令的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#有序集合对象"><span class="toc-number">10.</span> <span class="toc-text">有序集合对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么有序集合需要同时使用跳跃表和字典来实现？"><span class="toc-number">10.1.</span> <span class="toc-text">为什么有序集合需要同时使用跳跃表和字典来实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编码转换-2"><span class="toc-number">10.2.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型检查与命令多态"><span class="toc-number">11.</span> <span class="toc-text">类型检查与命令多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类型检查的实现"><span class="toc-number">11.1.</span> <span class="toc-text">类型检查的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多态命令的实现"><span class="toc-number">11.2.</span> <span class="toc-text">多态命令的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存回收"><span class="toc-number">11.3.</span> <span class="toc-text">内存回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象共享"><span class="toc-number">11.4.</span> <span class="toc-text">对象共享</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么Redis不共享包含字符串的对象"><span class="toc-number">11.4.1.</span> <span class="toc-text">为什么Redis不共享包含字符串的对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的空转时长"><span class="toc-number">11.5.</span> <span class="toc-text">对象的空转时长</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单机数据库的实现"><span class="toc-number">12.</span> <span class="toc-text">单机数据库的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库"><span class="toc-number">12.1.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器中的数据库"><span class="toc-number">12.1.1.</span> <span class="toc-text">服务器中的数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#切换数据库"><span class="toc-number">12.2.</span> <span class="toc-text">切换数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#谨慎处理多数据库程序"><span class="toc-number">12.2.1.</span> <span class="toc-text">谨慎处理多数据库程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库键空间"><span class="toc-number">12.3.</span> <span class="toc-text">数据库键空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#添加新键"><span class="toc-number">12.3.1.</span> <span class="toc-text">添加新键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除键"><span class="toc-number">12.3.2.</span> <span class="toc-text">删除键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新键"><span class="toc-number">12.3.3.</span> <span class="toc-text">更新键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对键取值"><span class="toc-number">12.3.4.</span> <span class="toc-text">对键取值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET"><span class="toc-number">12.3.4.1.</span> <span class="toc-text">GET</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRANGE"><span class="toc-number">12.3.4.2.</span> <span class="toc-text">LRANGE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他键空间操作"><span class="toc-number">12.3.5.</span> <span class="toc-text">其他键空间操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写键空间时的维护操作"><span class="toc-number">12.3.6.</span> <span class="toc-text">读写键空间时的维护操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置键的生存时间或过期时间"><span class="toc-number">12.3.7.</span> <span class="toc-text">设置键的生存时间或过期时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置过期时间"><span class="toc-number">12.3.8.</span> <span class="toc-text">设置过期时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保存过期时间"><span class="toc-number">12.3.9.</span> <span class="toc-text">保存过期时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移除过期时间"><span class="toc-number">12.3.10.</span> <span class="toc-text">移除过期时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算并返回剩余生存时间"><span class="toc-number">12.3.11.</span> <span class="toc-text">计算并返回剩余生存时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过期键的判定"><span class="toc-number">12.3.12.</span> <span class="toc-text">过期键的判定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#过期键删除策略"><span class="toc-number">12.4.</span> <span class="toc-text">过期键删除策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定时删除"><span class="toc-number">12.4.1.</span> <span class="toc-text">定时删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#惰性删除"><span class="toc-number">12.4.2.</span> <span class="toc-text">惰性删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定期删除"><span class="toc-number">12.4.3.</span> <span class="toc-text">定期删除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定期策略是前两种策略的一种整合折中"><span class="toc-number">12.4.3.0.1.</span> <span class="toc-text">定期策略是前两种策略的一种整合折中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#定期删除策略的难点是确定是删除操作执行的时长和频率"><span class="toc-number">12.4.3.0.2.</span> <span class="toc-text">定期删除策略的难点是确定是删除操作执行的时长和频率</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis的过期键删除策略"><span class="toc-number">12.5.</span> <span class="toc-text">Redis的过期键删除策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF，RDB和复制功能对过期键的处理"><span class="toc-number">12.6.</span> <span class="toc-text">AOF，RDB和复制功能对过期键的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成RDB文件"><span class="toc-number">12.6.1.</span> <span class="toc-text">生成RDB文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#载入RDB文件"><span class="toc-number">12.6.2.</span> <span class="toc-text">载入RDB文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF文件写入"><span class="toc-number">12.6.3.</span> <span class="toc-text">AOF文件写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF重写"><span class="toc-number">12.6.4.</span> <span class="toc-text">AOF重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制"><span class="toc-number">12.6.5.</span> <span class="toc-text">复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库通知"><span class="toc-number">12.7.</span> <span class="toc-text">数据库通知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#发送通知"><span class="toc-number">12.7.1.</span> <span class="toc-text">发送通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送通知的实现"><span class="toc-number">12.7.2.</span> <span class="toc-text">发送通知的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-5"><span class="toc-number">12.8.</span> <span class="toc-text">重点回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB持久化"><span class="toc-number">12.9.</span> <span class="toc-text">RDB持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB文件的创建与载入"><span class="toc-number">12.9.1.</span> <span class="toc-text">RDB文件的创建与载入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BGSAVE命令执行期间，服务器处理SAVE，BGSAVE，BGREWRITEAOF三个命令的方式会和平时有所不同"><span class="toc-number">12.9.1.1.</span> <span class="toc-text">BGSAVE命令执行期间，服务器处理SAVE，BGSAVE，BGREWRITEAOF三个命令的方式会和平时有所不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BGREWRITEAOF和BGSAVE两个命令不能同时执行"><span class="toc-number">12.9.1.2.</span> <span class="toc-text">BGREWRITEAOF和BGSAVE两个命令不能同时执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自动间隔性保存"><span class="toc-number">12.10.</span> <span class="toc-text">自动间隔性保存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设置保存条件"><span class="toc-number">12.10.1.</span> <span class="toc-text">设置保存条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dirty计数器和lastsave属性"><span class="toc-number">12.10.2.</span> <span class="toc-text">dirty计数器和lastsave属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检查保存条件是否满足"><span class="toc-number">12.10.3.</span> <span class="toc-text">检查保存条件是否满足</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB文件结构"><span class="toc-number">12.11.</span> <span class="toc-text">RDB文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#databases部分"><span class="toc-number">12.11.1.</span> <span class="toc-text">databases部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-value-pairs部分"><span class="toc-number">12.11.2.</span> <span class="toc-text">key_value_pairs部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#key和value分别保存了键值对的键对象和值对象"><span class="toc-number">12.11.2.1.</span> <span class="toc-text">key和value分别保存了键值对的键对象和值对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#value编码"><span class="toc-number">12.11.3.</span> <span class="toc-text">value编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分析RDB文件"><span class="toc-number">12.12.</span> <span class="toc-text">分析RDB文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不包含任何键值对的RDB文件"><span class="toc-number">12.12.1.</span> <span class="toc-text">不包含任何键值对的RDB文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包含字符串键的RDB文件"><span class="toc-number">12.12.2.</span> <span class="toc-text">包含字符串键的RDB文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包含带有过期时间的字符串键的RDB文件"><span class="toc-number">12.12.3.</span> <span class="toc-text">包含带有过期时间的字符串键的RDB文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包含一个集合键的RDB文件"><span class="toc-number">12.12.4.</span> <span class="toc-text">包含一个集合键的RDB文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于分析RDB文件的说明"><span class="toc-number">12.12.5.</span> <span class="toc-text">关于分析RDB文件的说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-6"><span class="toc-number">12.13.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AOF持久化"><span class="toc-number">13.</span> <span class="toc-text">AOF持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#命令追加"><span class="toc-number">13.0.1.</span> <span class="toc-text">命令追加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF文件的写入与同步"><span class="toc-number">13.0.2.</span> <span class="toc-text">AOF文件的写入与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF持久化的效率和安全"><span class="toc-number">13.0.2.1.</span> <span class="toc-text">AOF持久化的效率和安全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF文件的载入与数据还原"><span class="toc-number">13.0.3.</span> <span class="toc-text">AOF文件的载入与数据还原</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF重写-1"><span class="toc-number">13.1.</span> <span class="toc-text">AOF重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF文件重写的实现"><span class="toc-number">13.1.1.</span> <span class="toc-text">AOF文件重写的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF后台重写"><span class="toc-number">13.1.2.</span> <span class="toc-text">AOF后台重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-7"><span class="toc-number">13.2.</span> <span class="toc-text">重点回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件"><span class="toc-number">13.3.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件事件"><span class="toc-number">13.3.1.</span> <span class="toc-text">文件事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件事件处理器的构成"><span class="toc-number">13.3.2.</span> <span class="toc-text">文件事件处理器的构成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-8"><span class="toc-number">13.4.</span> <span class="toc-text">重点回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#客户端"><span class="toc-number">13.5.</span> <span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端属性"><span class="toc-number">13.5.1.</span> <span class="toc-text">客户端属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#套接字描述符"><span class="toc-number">13.5.2.</span> <span class="toc-text">套接字描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#名字"><span class="toc-number">13.5.3.</span> <span class="toc-text">名字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标志"><span class="toc-number">13.5.4.</span> <span class="toc-text">标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入缓冲区"><span class="toc-number">13.5.5.</span> <span class="toc-text">输入缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令与命令参数"><span class="toc-number">13.5.6.</span> <span class="toc-text">命令与命令参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令的实现函数"><span class="toc-number">13.5.7.</span> <span class="toc-text">命令的实现函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输出缓冲区"><span class="toc-number">13.5.8.</span> <span class="toc-text">输出缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#身份验证"><span class="toc-number">13.5.9.</span> <span class="toc-text">身份验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间"><span class="toc-number">13.5.10.</span> <span class="toc-text">时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#客户端的创建与关闭"><span class="toc-number">13.6.</span> <span class="toc-text">客户端的创建与关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建普通客户端"><span class="toc-number">13.6.1.</span> <span class="toc-text">创建普通客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭普通客户端"><span class="toc-number">13.6.2.</span> <span class="toc-text">关闭普通客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua脚本的伪客户端"><span class="toc-number">13.6.3.</span> <span class="toc-text">Lua脚本的伪客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF文件的伪客户端"><span class="toc-number">13.6.4.</span> <span class="toc-text">AOF文件的伪客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-9"><span class="toc-number">13.7.</span> <span class="toc-text">重点回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务器"><span class="toc-number">13.8.</span> <span class="toc-text">服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#命令请求的执行过程"><span class="toc-number">13.8.1.</span> <span class="toc-text">命令请求的执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#发送命令请求"><span class="toc-number">13.8.1.1.</span> <span class="toc-text">发送命令请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取命令请求"><span class="toc-number">13.8.1.2.</span> <span class="toc-text">读取命令请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令执行器1：查找命令实现"><span class="toc-number">13.8.1.3.</span> <span class="toc-text">命令执行器1：查找命令实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令执行器2：执行预备操作"><span class="toc-number">13.8.1.4.</span> <span class="toc-text">命令执行器2：执行预备操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令执行器3：调用命令的实现函数"><span class="toc-number">13.8.1.5.</span> <span class="toc-text">命令执行器3：调用命令的实现函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令执行器4：执行后续工作"><span class="toc-number">13.8.1.6.</span> <span class="toc-text">命令执行器4：执行后续工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将命令回复发送给客户端"><span class="toc-number">13.8.1.7.</span> <span class="toc-text">将命令回复发送给客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端接受并打印命令回复"><span class="toc-number">13.8.1.8.</span> <span class="toc-text">客户端接受并打印命令回复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serverCron函数"><span class="toc-number">13.8.2.</span> <span class="toc-text">serverCron函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#更新服务器时间缓存"><span class="toc-number">13.8.2.1.</span> <span class="toc-text">更新服务器时间缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更新LRU时钟"><span class="toc-number">13.8.2.2.</span> <span class="toc-text">更新LRU时钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理sigterm信号"><span class="toc-number">13.8.2.3.</span> <span class="toc-text">处理sigterm信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#管理客户端资源"><span class="toc-number">13.8.2.4.</span> <span class="toc-text">管理客户端资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化服务器"><span class="toc-number">13.8.3.</span> <span class="toc-text">初始化服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化服务器状态结构"><span class="toc-number">13.8.3.1.</span> <span class="toc-text">初始化服务器状态结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#载入配置选项"><span class="toc-number">13.8.3.2.</span> <span class="toc-text">载入配置选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重点回顾-10"><span class="toc-number">13.8.4.</span> <span class="toc-text">重点回顾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复制-1"><span class="toc-number">14.</span> <span class="toc-text">复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#旧版复制功能的实现"><span class="toc-number">14.1.</span> <span class="toc-text">旧版复制功能的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步"><span class="toc-number">14.1.1.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令传播"><span class="toc-number">14.1.2.</span> <span class="toc-text">命令传播</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#旧版复制功能的缺陷"><span class="toc-number">14.2.</span> <span class="toc-text">旧版复制功能的缺陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新版复制功能的实现"><span class="toc-number">14.3.</span> <span class="toc-text">新版复制功能的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#部分重同步的实现"><span class="toc-number">14.4.</span> <span class="toc-text">部分重同步的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复制偏移量"><span class="toc-number">14.4.1.</span> <span class="toc-text">复制偏移量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复制积压缓冲区"><span class="toc-number">14.4.2.</span> <span class="toc-text">复制积压缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器运行ID"><span class="toc-number">14.4.3.</span> <span class="toc-text">服务器运行ID</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PSYNC命令的实现"><span class="toc-number">14.5.</span> <span class="toc-text">PSYNC命令的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复制的实现"><span class="toc-number">14.6.</span> <span class="toc-text">复制的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤一：设置主服务器的地址和端口"><span class="toc-number">14.6.1.</span> <span class="toc-text">步骤一：设置主服务器的地址和端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤二：建立套接字连接"><span class="toc-number">14.6.2.</span> <span class="toc-text">步骤二：建立套接字连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤三：发送PING命令"><span class="toc-number">14.6.3.</span> <span class="toc-text">步骤三：发送PING命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤四：身份验证"><span class="toc-number">14.6.4.</span> <span class="toc-text">步骤四：身份验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤五：发送端口信息"><span class="toc-number">14.6.5.</span> <span class="toc-text">步骤五：发送端口信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤六：同步"><span class="toc-number">14.6.6.</span> <span class="toc-text">步骤六：同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#步骤七：命令传播"><span class="toc-number">14.6.7.</span> <span class="toc-text">步骤七：命令传播</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#心跳检测"><span class="toc-number">14.7.</span> <span class="toc-text">心跳检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#检测主从服务器的网络连接状态"><span class="toc-number">14.7.1.</span> <span class="toc-text">检测主从服务器的网络连接状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#辅助实现min-slaves配置选项"><span class="toc-number">14.7.2.</span> <span class="toc-text">辅助实现min-slaves配置选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测命令丢失"><span class="toc-number">14.7.3.</span> <span class="toc-text">检测命令丢失</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-11"><span class="toc-number">14.8.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sentinel"><span class="toc-number">15.</span> <span class="toc-text">Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#启动并初始化Sentinel"><span class="toc-number">15.1.</span> <span class="toc-text">启动并初始化Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化服务器-1"><span class="toc-number">15.1.1.</span> <span class="toc-text">初始化服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Sentinel专用代码"><span class="toc-number">15.1.2.</span> <span class="toc-text">使用Sentinel专用代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化Sentinel状态"><span class="toc-number">15.1.3.</span> <span class="toc-text">初始化Sentinel状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化Sentinel状态的masters属性"><span class="toc-number">15.1.4.</span> <span class="toc-text">初始化Sentinel状态的masters属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建连向主服务器的网络连接"><span class="toc-number">15.1.5.</span> <span class="toc-text">创建连向主服务器的网络连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取主服务器信息"><span class="toc-number">15.2.</span> <span class="toc-text">获取主服务器信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取从服务器信息"><span class="toc-number">15.3.</span> <span class="toc-text">获取从服务器信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#向主服务器和从服务器发送信息"><span class="toc-number">15.4.</span> <span class="toc-text">向主服务器和从服务器发送信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接收来自主服务器和从服务器的频道信息"><span class="toc-number">15.5.</span> <span class="toc-text">接收来自主服务器和从服务器的频道信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#更新sentinels字典"><span class="toc-number">15.5.1.</span> <span class="toc-text">更新sentinels字典</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建连向其他sentinel的命令连接"><span class="toc-number">15.6.</span> <span class="toc-text">创建连向其他sentinel的命令连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检查主观下线状态"><span class="toc-number">15.7.</span> <span class="toc-text">检查主观下线状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主观下线时长选项的作用范围"><span class="toc-number">15.7.1.</span> <span class="toc-text">主观下线时长选项的作用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多个Sentinel设置的主观下线时长可能不同"><span class="toc-number">15.7.2.</span> <span class="toc-text">多个Sentinel设置的主观下线时长可能不同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检查客观下线状态"><span class="toc-number">15.8.</span> <span class="toc-text">检查客观下线状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#发送sentinel-is-master-down-by-addr命令"><span class="toc-number">15.8.1.</span> <span class="toc-text">发送sentinel is-master-down-by-addr命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收sentinel-is-master-down-by-addr命令"><span class="toc-number">15.8.2.</span> <span class="toc-text">接收sentinel is-master-down-by-addr命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收sentinel-is-master-down-by-addr命令的回复"><span class="toc-number">15.8.3.</span> <span class="toc-text">接收sentinel is-master-down-by-addr命令的回复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#客观下线状态的判断条件"><span class="toc-number">15.8.3.1.</span> <span class="toc-text">客观下线状态的判断条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不同的sentinel判断客观下线的条件可能不同"><span class="toc-number">15.8.3.2.</span> <span class="toc-text">不同的sentinel判断客观下线的条件可能不同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选举领头sentinel"><span class="toc-number">15.9.</span> <span class="toc-text">选举领头sentinel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#故障转移"><span class="toc-number">15.10.</span> <span class="toc-text">故障转移</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选出新的主服务器"><span class="toc-number">15.10.1.</span> <span class="toc-text">选出新的主服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#新的主服务器是怎样挑选出来的"><span class="toc-number">15.10.1.1.</span> <span class="toc-text">新的主服务器是怎样挑选出来的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改主服务器的复制目标"><span class="toc-number">15.10.2.</span> <span class="toc-text">修改主服务器的复制目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将旧的主服务器变为从服务器"><span class="toc-number">15.10.3.</span> <span class="toc-text">将旧的主服务器变为从服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-12"><span class="toc-number">15.11.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集群"><span class="toc-number">16.</span> <span class="toc-text">集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#节点"><span class="toc-number">16.1.</span> <span class="toc-text">节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动节点"><span class="toc-number">16.1.1.</span> <span class="toc-text">启动节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集群数据结构"><span class="toc-number">16.1.2.</span> <span class="toc-text">集群数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisClient和clusterLink结构的异同之处"><span class="toc-number">16.1.2.1.</span> <span class="toc-text">redisClient和clusterLink结构的异同之处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CLUSTER-MEET命令的实现"><span class="toc-number">16.1.3.</span> <span class="toc-text">CLUSTER MEET命令的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#槽指派"><span class="toc-number">16.2.</span> <span class="toc-text">槽指派</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#记录节点的槽指派信息"><span class="toc-number">16.2.1.</span> <span class="toc-text">记录节点的槽指派信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传播节点的槽指派信息"><span class="toc-number">16.2.2.</span> <span class="toc-text">传播节点的槽指派信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#记录集群所有槽的指派信息"><span class="toc-number">16.2.3.</span> <span class="toc-text">记录集群所有槽的指派信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CLUSTER-ADDSLOTS命令的实现"><span class="toc-number">16.2.4.</span> <span class="toc-text">CLUSTER ADDSLOTS命令的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在集群中执行命令"><span class="toc-number">16.3.</span> <span class="toc-text">在集群中执行命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重新分片"><span class="toc-number">16.4.</span> <span class="toc-text">重新分片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASK错误"><span class="toc-number">16.5.</span> <span class="toc-text">ASK错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-13"><span class="toc-number">16.6.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#发布与订阅"><span class="toc-number">17.</span> <span class="toc-text">发布与订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#频道的订阅与退订"><span class="toc-number">17.1.</span> <span class="toc-text">频道的订阅与退订</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模式的订阅与退订"><span class="toc-number">17.2.</span> <span class="toc-text">模式的订阅与退订</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送消息"><span class="toc-number">17.3.</span> <span class="toc-text">发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将消息发送个频道订阅者"><span class="toc-number">17.3.1.</span> <span class="toc-text">将消息发送个频道订阅者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查看订阅消息"><span class="toc-number">17.4.</span> <span class="toc-text">查看订阅消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pubsub-channels-patttern"><span class="toc-number">17.4.1.</span> <span class="toc-text">pubsub channels[patttern]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pubsub-numsub-channel-1-channel-2…channel-n"><span class="toc-number">17.4.2.</span> <span class="toc-text">pubsub numsub[channel-1 channel-2…channel-n]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pubsub-numpat"><span class="toc-number">17.4.3.</span> <span class="toc-text">pubsub numpat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-14"><span class="toc-number">17.5.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事务"><span class="toc-number">18.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#事务的实现"><span class="toc-number">18.1.</span> <span class="toc-text">事务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事务开始"><span class="toc-number">18.1.1.</span> <span class="toc-text">事务开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令入队"><span class="toc-number">18.1.2.</span> <span class="toc-text">命令入队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务队列"><span class="toc-number">18.1.3.</span> <span class="toc-text">事务队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行事务"><span class="toc-number">18.1.4.</span> <span class="toc-text">执行事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WATCH命令的实现"><span class="toc-number">18.2.</span> <span class="toc-text">WATCH命令的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用watch命令监视数据库键"><span class="toc-number">18.2.1.</span> <span class="toc-text">使用watch命令监视数据库键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监视机制的触发"><span class="toc-number">18.2.2.</span> <span class="toc-text">监视机制的触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断事务是否安全"><span class="toc-number">18.2.3.</span> <span class="toc-text">判断事务是否安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个完整的WATCH事务执行过程"><span class="toc-number">18.2.4.</span> <span class="toc-text">一个完整的WATCH事务执行过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务的ACID性质"><span class="toc-number">18.3.</span> <span class="toc-text">事务的ACID性质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性"><span class="toc-number">18.3.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一致性"><span class="toc-number">18.3.2.</span> <span class="toc-text">一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#入队错误"><span class="toc-number">18.3.2.1.</span> <span class="toc-text">入队错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行错误"><span class="toc-number">18.3.2.2.</span> <span class="toc-text">执行错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务器停机"><span class="toc-number">18.3.2.3.</span> <span class="toc-text">服务器停机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隔离性"><span class="toc-number">18.3.3.</span> <span class="toc-text">隔离性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#耐久性"><span class="toc-number">18.3.4.</span> <span class="toc-text">耐久性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-15"><span class="toc-number">18.4.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua脚本"><span class="toc-number">19.</span> <span class="toc-text">Lua脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建并修改Lua环境"><span class="toc-number">19.1.</span> <span class="toc-text">创建并修改Lua环境</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序"><span class="toc-number">20.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SORT命令的实现"><span class="toc-number">20.1.</span> <span class="toc-text">SORT命令的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ALPHA选项的实现"><span class="toc-number">20.2.</span> <span class="toc-text">ALPHA选项的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASC选项和DESC选项的实现"><span class="toc-number">20.3.</span> <span class="toc-text">ASC选项和DESC选项的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BY选项的实现"><span class="toc-number">20.4.</span> <span class="toc-text">BY选项的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#带有ALPHA选项的BY选项的实现"><span class="toc-number">20.5.</span> <span class="toc-text">带有ALPHA选项的BY选项的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIMIT选项的实现"><span class="toc-number">20.6.</span> <span class="toc-text">LIMIT选项的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET选项的实现"><span class="toc-number">20.7.</span> <span class="toc-text">GET选项的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STORE选项的实现"><span class="toc-number">20.8.</span> <span class="toc-text">STORE选项的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多个选项的执行顺序"><span class="toc-number">20.9.</span> <span class="toc-text">多个选项的执行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选项的执行顺序"><span class="toc-number">20.9.1.</span> <span class="toc-text">选项的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选项的摆放顺序"><span class="toc-number">20.9.2.</span> <span class="toc-text">选项的摆放顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-16"><span class="toc-number">20.10.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二进制位数组"><span class="toc-number">21.</span> <span class="toc-text">二进制位数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#位数组的表示"><span class="toc-number">21.1.</span> <span class="toc-text">位数组的表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GETBIT命令的实现"><span class="toc-number">21.2.</span> <span class="toc-text">GETBIT命令的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SETBIT命令的实现"><span class="toc-number">21.3.</span> <span class="toc-text">SETBIT命令的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BITCOUNT命令的实现"><span class="toc-number">21.4.</span> <span class="toc-text">BITCOUNT命令的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制位统计算法1：遍历算法"><span class="toc-number">21.4.1.</span> <span class="toc-text">二进制位统计算法1：遍历算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制位统计算法2：查表算法"><span class="toc-number">21.4.2.</span> <span class="toc-text">二进制位统计算法2：查表算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制位统计算法3：variable-precision-SWAR算法"><span class="toc-number">21.4.3.</span> <span class="toc-text">二进制位统计算法3：variable-precision SWAR算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制位统计算法4：Redis的实现"><span class="toc-number">21.4.4.</span> <span class="toc-text">二进制位统计算法4：Redis的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BITOP命令的实现"><span class="toc-number">21.5.</span> <span class="toc-text">BITOP命令的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#慢查询日志"><span class="toc-number">22.</span> <span class="toc-text">慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#慢查询记录的保存"><span class="toc-number">22.1.</span> <span class="toc-text">慢查询记录的保存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重点回顾-17"><span class="toc-number">22.2.</span> <span class="toc-text">重点回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#监视器"><span class="toc-number">23.</span> <span class="toc-text">监视器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#成为监视器"><span class="toc-number">23.1.</span> <span class="toc-text">成为监视器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#向监视器发送命令信息"><span class="toc-number">23.2.</span> <span class="toc-text">向监视器发送命令信息</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/redisdesign.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">定不辱使命</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">《Redis设计与实现》读书笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-29 13:35:51"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-29</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-31 10:26:10"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-31</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h1><p>Redis没有直接使用C语言传统的字符串表示(以空字符串结尾的字符数组)，而是自己构建了一种名为简单动态字符串SDS的抽象类型，并将SDS用作Redis的默认字符串表示</p>
<p>在Redis中，C字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如打印日志</p>
<p>当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，包含字符串值的键值对底层都是由SDS实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;SET msg &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串msg的SDS</li>
<li>键值对的值也是一个字符串对象，对象底层实现是一个保存着字符串hello world的SDS</li>
</ul>
<p>除了用来保存数据库的中字符串值之外，SDS还被用作缓冲区，AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现的</p>
<h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><p>每个sds.h/sdshdr结构表示一个SDS值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">	&#x2F;&#x2F;记录buf数组已使用字节的数量，等于SDS所保存字符串的长度,不包括空字符</span><br><span class="line">	int len;</span><br><span class="line">	&#x2F;&#x2F;记录buf数组中未使用字节的数量</span><br><span class="line">	int free;</span><br><span class="line">	&#x2F;&#x2F;字节数组，用于保存字符串，最后一个字节保存空字符\0</span><br><span class="line">	char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/001.png"  alt="img"></p>
<p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符串分配额外的1字节空间，以及添加空字符串到字符串末尾等操作都是由SDS函数自动完成的，字符串对于SDS的使用者来说是完全透明的</p>
<h2 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h2><p>C语言使用长度为N+1的字符串数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符\0</p>
<p>C语言字符串的表示方式并不能满足Redis对字符串在安全性，效率以及功能方面的要求</p>
<h3 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h3><p>C字符串并不记录自身的长度信息，要想获取一个C字符串的长度，必须遍历整个字符串，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O(N)</p>
<p>通过使用SDS，Redis将获取字符串长度所需的复杂度从O(N)降低到了O(1),这确保了获取字符串长度的工作不会成为Redis的性能瓶颈</p>
<p>因为字符串键在底层使用SDS来实现，所以即使对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响</p>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出</p>
<p>修改字符串时，如果内存分配不充足，会导致数据溢出，例如执行strcat(s1,”Cluster”)，将s1的内容修改为Redis Cluster。由于没有给s1分配足够的空间，那么在strcat函数执行之后，s1的数据将溢出到s2所在的空间，导致s2保存的内容被意外修改</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/002.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/003.png"  alt="img"></p>
<p>SDS的空间分配策略完全杜绝了发生缓存区溢出的可能，当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓存区溢出问题</p>
<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><p>因为C字符串的长度和底层数组的长度之间存在着关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一个内存重分配操作</p>
<p>拼接操作不扩展底层数组会导致缓冲区溢出；截断操作不释放多余空间会发生内存泄漏</p>
<p>内存重分配涉及复杂的算法，并且可能需要执行系统调用，是一个比较耗时的操作</p>
<p>Redis经常被用于速度要求苛刻，数据被频繁修改的场合，所以不能使用C字符串这种每次修改都需要重分配的数据结构</p>
<p>SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联，在SDS中，buf数组长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就有SDS的free属性记录</p>
<p>通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略</p>
<h4 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h4><p>用于优化SDS的字符串增长操作，当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外额外的未使用空间</p>
<p>如果对SDS进行修改之后，SDS的长度len小于1MB,那么程序分配和len属性同样大小的未使用空间，len和free的值将会相同</p>
<p>如果对SDS进行修改后，SDS的长度len大于1MB,那么程序会分配1MB的未使用空间。例如进行修改后，SDS的len将变成30MB,那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度将为30MB+1MB+1byte</p>
<p>通过空间预分配策略，redis可以减少连续执行字符串增长操作所需的内存重分配次数</p>
<p>通过这个策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次</p>
<h4 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h4><p>惰性空间释放用于优化SDS的字符串缩短操作，当SDSAPI需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用</p>
<p>通过惰性空间释放，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能的增长操作提供了优化</p>
<p>SDS也提供了相应的API，可以真正地释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费</p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>C字符串中的字符必须符合某种编码，并且除了字符串的末尾外，字符串里面不能包空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片，音频，视频，压缩文件这样的二进制数据</p>
<p>SDS的API都是二进制安全的，所有的SDS API都会处理二进制的方式来处理SDS存在在buf数组里的数据，程序不会对其中的数据做任何操作，数据写入时是什么样子，它被读取的时候就是什么样</p>
<p>这也是我们将SDS的buf属性称为字节数组的原因——Redis不是用这个数组来保存字符，而是用它来保存一些列二进制数据</p>
<p>因为SDS使用len属性的值而不是空字符来判断字符串是否结束，所以SDS可以保存特殊格式的数据</p>
<h3 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h3><p>SDS一样遵循C字符串以空字符串结尾的惯例，这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C字符串与SDS之间的区别</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/004.png"  alt="img"></p>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS简单动态字符串作为字符串表示</p>
<h3 id="SDS的优点"><a href="#SDS的优点" class="headerlink" title="SDS的优点"></a>SDS的优点</h3><ol>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串长度是时所需的内存重分配次数</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ol>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表提供了高效的节点重排序能力，以及顺序性的节点访问方式，并且可以用过增删节点来灵活地调整链表的长度</p>
<p>Redis使用的C语言并没有内置链表，Redis构建了自己的链表实现</p>
<h3 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h3><p>每个链表节点使用一个adlist.h/listNode结构来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode&#123;</span><br><span class="line">	&#x2F;&#x2F;前置节点</span><br><span class="line">	struct listNode * prev;</span><br><span class="line">	&#x2F;&#x2F;后置节点</span><br><span class="line">	struct listNode * next;</span><br><span class="line">	&#x2F;&#x2F;节点的值</span><br><span class="line">	void * value;</span><br><span class="line">&#125;listNode</span><br></pre></td></tr></table></figure>

<p>多个listNode可以通过prev和next指针组成双端链表</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/005.png"  alt="img"></p>
<p>虽然使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/006.png"  alt="img"></p>
<p>list结构为链表提供了表头指针head,表尾指针tail，以及链表长度计数器len,而dup,free和match成员则是用于实现多态链表所需的类型特定函数。dup函数用于复制链表节点所保存的值，free函数用于释放链表节点所保存的值，match函数则用于对比链表节点所保存的值和另一个输入值是否相同</p>
<p>下图是一个由list结构和三个listNode结构组成的链表</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/007.png"  alt="img"></p>
<h3 id="Redis链表特性"><a href="#Redis链表特性" class="headerlink" title="Redis链表特性"></a>Redis链表特性</h3><h4 id="双端"><a href="#双端" class="headerlink" title="双端"></a>双端</h4><p>链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</p>
<h4 id="无环"><a href="#无环" class="headerlink" title="无环"></a>无环</h4><p>表头节点的prev指针和表尾节点的next指针都指向null，对链表的访问以NULL为终点</p>
<h4 id="带表头指针和表尾指针"><a href="#带表头指针和表尾指针" class="headerlink" title="带表头指针和表尾指针"></a>带表头指针和表尾指针</h4><p>通过list结构的head和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)</p>
<h4 id="带链表长度计数器"><a href="#带链表长度计数器" class="headerlink" title="带链表长度计数器"></a>带链表长度计数器</h4><p>程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>链表节点使用void*指针来保存节点值，并且可以通过list结构的dup,free,match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值</p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典是一种用于保存键值对的抽象数据结构，在字典中一个键可以和一个值进行关联，字典中的每个键都是独一无二的</p>
<p>Redis所使用的C语言并没有内置这种数据结构，因此Redis构建了自己的字典实现</p>
<p>Redis的数据库就是使用字典作为底层实现的，对数据库的增删改查操作也是建立在对字典的操作之上的</p>
<p>除了用来表示数据库以外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多时，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现</p>
<p>一个字典可以包含多个键值对</p>
<h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>Redis字典所使用的哈希表由dict.h/dictht结构定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht&#123;</span><br><span class="line">	&#x2F;&#x2F;哈希表数组</span><br><span class="line">	dictEntry **table;</span><br><span class="line">	&#x2F;&#x2F;哈希表大小</span><br><span class="line">	unsigned long size;</span><br><span class="line">	&#x2F;&#x2F;哈希表大小掩码，用于计算索引值，总是等于size-1</span><br><span class="line">	unsigned long sizemask;</span><br><span class="line">	&#x2F;&#x2F;该哈希表已有节点的数量</span><br><span class="line">	unsigned long used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>

<ol>
<li>table是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构都保存着一个键值对</li>
<li>size属性记录了哈希表的大小，也就是table的大小</li>
<li>used属性记录哈希表目前已有节点的数量</li>
<li>sizemask属性的值总是等于size-1，这个属性和哈希值一起一起决定一个键应该被放到table数组的哪个索引上</li>
</ol>
<h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry&#123;</span><br><span class="line">	&#x2F;&#x2F;键</span><br><span class="line">	void *key;</span><br><span class="line">	&#x2F;&#x2F;值</span><br><span class="line">	union&#123;</span><br><span class="line">		void *val;</span><br><span class="line">		uint64_tu64;</span><br><span class="line">		int64_ts64;</span><br><span class="line">	&#125;v;</span><br><span class="line">	&#x2F;&#x2F;指向下个哈希表的节点，形成链表</span><br><span class="line">	struct dictEntry *next;</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>

<p>key保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数</p>
<p>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突问题</p>
<h3 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">	&#x2F;&#x2F;类型特定函数</span><br><span class="line">	dictType *type;</span><br><span class="line">	&#x2F;&#x2F;私有数据</span><br><span class="line">	void *privdata;</span><br><span class="line">	&#x2F;&#x2F;哈希表</span><br><span class="line">	dictht ht[2];</span><br><span class="line">	&#x2F;&#x2F;rehash索引</span><br><span class="line">	&#x2F;&#x2F;当rehash不在进行时，值为-1</span><br><span class="line">	in trehashidx</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>

<p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的</p>
<ol>
<li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数</li>
<li>privdata属性则保存了需要传给那些类型特定函数的可选参数</li>
</ol>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/008.png"  alt="img"></p>
<p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下字典只使用ht[0]哈希表，ht[1]哈希表只会对ht[0]哈希表进行rehash时使用</p>
<p>除了ht[1]之外，另一个和rehash有关的属性就是trehashidx,它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1</p>
<p>下图是一个没有进行rehash的普通状态下的字典</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/009.png"  alt="img"></p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面</p>
<p>Redis计算哈希值和索引值的方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash&#x3D;dict-&gt;type-&gt;hashFunction(key);</span><br></pre></td></tr></table></figure>

<p>使用哈希表的sizemask属性和哈希值，计算出索引值</p>
<p>根据情况不同，ht[x]可以是ht[0]或者ht[1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index&#x3D;hash&amp;dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<h3 id="如果要将一个键值对k0和v0添加到字典里面"><a href="#如果要将一个键值对k0和v0添加到字典里面" class="headerlink" title="如果要将一个键值对k0和v0添加到字典里面"></a>如果要将一个键值对k0和v0添加到字典里面</h3><p>计算k0的哈希值,假设计算得出的哈希值是8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash&#x3D;dict-&gt;type-&gt;hashFunction(k0);</span><br></pre></td></tr></table></figure>

<p>计算出键k0的索引值0，这表示包含键值对k0和v0的节点应该被放置到哈希表数组的索引0位置上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index&#x3D;hash&amp;dict-&gt;ht[x].sizemask &#x3D; 8&amp;3 &#x3D; 0;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/010.png"  alt="img"></p>
<h2 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h2><p>当由两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突</p>
<p>Redis的哈希表使用链地址法来解决冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，这就解决了键冲突问题</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设程序要将键值对k2和v2添加到下图所示的哈希表里面，并且计算得出k2的索引值为2,那么键k1和k2将会产生冲突，而解决冲突的办法就是使用next指针将键k2和k1所在的节点链接起来</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着哈希表保存的键值对逐渐地增多或者减少，为了让哈希表的负载因子维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩</p>
<p>扩展和收缩哈希表的工作可以通过执行rehash重新散列操作来完成，Redis对字典的哈希表执行rehash的步骤如下</p>
<ol>
<li>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量(ht[0].used属性的值)</li>
</ol>
<ul>
<li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n</li>
<li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n</li>
</ul>
<ol start="2">
<li>将保存在ht[0]中所有的键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上</li>
<li>当ht[0]包含的所有键值对都迁移到ht[1]之后，ht[0]变为空表，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备</li>
</ol>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/011.png"  alt="img"></p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>要对ht[0]进行扩展，下图是rehash之前的哈希表</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/012.png"  alt="img"></p>
<p>ht[0].used当前的值为4，对于的扩容值是8，为ht[1]分配大小为8的空间</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/013.png"  alt="img"></p>
<p>将ht[0]包含的四个键值对都rehash到ht[1]</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/014.png"  alt="img"></p>
<p>释放ht[0]，并将ht[1]设置为ht[0],然后为ht[1]分配一个空白哈希表，至此，对哈希表的扩展操作执行完毕，程序成功将哈希表的大小从原来的4改变成现在的8</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/015.png"  alt="img"></p>
<h3 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h3><p>当满足下列任意一个条件时，程序会自动开始对哈希表执行扩展操作</p>
<p>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1</p>
<p>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5</p>
<p>哈希表的负载因子可以通过公式：负载因子=哈希表已保存节点数量/哈希表大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor &#x3D; ht[0].used &#x2F; ht[0].size</span><br></pre></td></tr></table></figure>

<p>根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行这两个命令的时候，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存</p>
<p>当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作</p>
<h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>rehash并不是一次性，集中式地完成的，而是分多次，渐进式地完成的，主要目的是为了避免rehash对服务器性能造成影响</p>
<p>以下是哈希表渐进式rehash的像详细步骤</p>
<ol>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始</li>
<li>在rehash进行期间，每次对字典执行添加，删除，查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],当rehash工作完成之后，程序将rehashidx属性的值增一</li>
<li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1],这时程序将rehashidx属性值设为-1，表示rehash操作已完成</li>
</ol>
<p>渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加，删除，查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量</p>
<h3 id="一次渐进式rehash过程"><a href="#一次渐进式rehash过程" class="headerlink" title="一次渐进式rehash过程"></a>一次渐进式rehash过程</h3><p>准备开始rehash</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/016.png"  alt="img"></p>
<p>rehash所索引0上的键值对</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/017.png"  alt="img"></p>
<p>rehash所索引1上的键值对</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/018.png"  alt="img"></p>
<p>rehash所索引2上的键值对</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/019.png"  alt="img"></p>
<p>rehash所索引3上的键值对</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/020.png"  alt="img"></p>
<p>rehash执行完毕</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/021.png"  alt="img"></p>
<p>渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个hash表，对字典的操作会同时在两个哈希表上进行。要在字典里面查找一个键的话，程序会现在ht[0]里面进行查找，如果没有找到的话，就会接着到ht[1]里面查找</p>
<p>在渐进式rehash执行期间，新添加到字典的键值对会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作</p>
<h2 id="重点回顾-1"><a href="#重点回顾-1" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键</p>
<p>Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行时rehash时使用</p>
<p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值</p>
<p>哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表</p>
<p>在对哈希表进行扩展或收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的</p>
<h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</p>
<p>跳跃表支持平均O(logN),最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点</p>
<p>大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来的更为简单，所以有不少程序都使用跳跃表来代替平衡树</p>
<p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/022.png"  alt="img"></p>
<p>有序集合的所有数据都保存在一个跳跃表里面，其中每个跳跃表节点都保存了一款水果的价钱信息，所有水果按照价钱高低从低到高在跳跃表里面排序</p>
<p>和链表，字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构</p>
<h2 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h2><p>Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，zskiplist结构用于保存跳跃表节点的相关信息</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/023.png"  alt="img"></p>
<h3 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h3><ul>
<li>header:指向跳跃表的表头节点</li>
<li>tail:指向跳跃表的表尾节点</li>
<li>level:记录当前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li>
<li>length:记录跳跃表的长度，即跳跃表目前包含节点的数量(表头节点不计算在内)</li>
</ul>
<h3 id="zskiplistNode"><a href="#zskiplistNode" class="headerlink" title="zskiplistNode"></a>zskiplistNode</h3><ul>
<li>level层：节点中用L标记各个层，每个层带有两个属性：前进指针和跨度，前进指针用于访问位于表尾方法的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行</li>
<li>后退指针backward:节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点，后退指针在程序从表尾向表头遍历时使用</li>
<li>分值score:各个节点中的1.0，2.0和3.0是节点所保存的分值，在跳跃表中，节点按各自所保存的分支从小到大排列</li>
<li>成员对象:各个节点中的o1,o2,o3是节点所保存的成员对象</li>
</ul>
<p>表头节点和其他节点的构造是一样的,表头节点也有后退指针，分值，成员对象，不过这些表头节点属性都不会被用到</p>
<h3 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h3><p>跳跃表节点的实现由redis.h/zskiplistNode结构定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode&#123;</span><br><span class="line">	&#x2F;&#x2F;层</span><br><span class="line">	struct zskiplistLevel&#123;</span><br><span class="line">		&#x2F;&#x2F;前进指针</span><br><span class="line">		struct zskiplistNode * forward;</span><br><span class="line">		&#x2F;&#x2F;跨度</span><br><span class="line">		unsigned int span;</span><br><span class="line">	&#125;level[];</span><br><span class="line">	&#x2F;&#x2F;后退指针</span><br><span class="line">	struct zskiplistNode  * backward;</span><br><span class="line">	&#x2F;&#x2F;分值</span><br><span class="line">	double score;</span><br><span class="line">	&#x2F;&#x2F;成员对象；</span><br><span class="line">	robj * obj;</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure>

<h4 id="层"><a href="#层" class="headerlink" title="层"></a>层</h4><p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度也就越快</p>
<p>每次创建一个新的跳跃表节点的时候，程序都根据幂次定律(越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的高度</p>
<h4 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h4><p>每个层都有一个指向表尾方向的前进指针level[i].forward属性，用于从表头向表尾方向访问节点</p>
<h4 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h4><p>层的跨度level[i].span属性用于记录两个节点之间的距离</p>
<p>两个节点之间的跨度越大，它们相距的也就越远</p>
<p>指向null的所有前进指针的跨度都为0，因为它们没有连向任何节点</p>
<p>跨度用来计量排位，在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。下图用虚线标记了在跳跃表中查找分值为3.0，成员对象为o3的节点时，查找的过程只经过一个层，并且层的跨度为3，所以目标节点在跳跃表中的排位为3</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/024.png"  alt="img"></p>
<h4 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h4><p>节点的后退指针用于从表尾向表头方向访问节点，跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。下图用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点，程序首先通过跳跃表的tail指针访问表尾节点，然后通过后退指针访问倒数第二个节点，之后再沿着后退指针访问倒数第三个节点，再之后遇到指向NULL的后退指针，访问结束</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/025.png"  alt="img"></p>
<h4 id="分值和成员"><a href="#分值和成员" class="headerlink" title="分值和成员"></a>分值和成员</h4><p>节点的分值socre是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序</p>
<p>节点的成员对象obj属性是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值</p>
<p>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的，分值相同的节点将按照成员对象在字典序中的大小顺序来进行排序，成员对象较小的节点会排在前面(靠近表头的位置)，而成员对象较大的节点则会排在后面(靠近表尾的方向)</p>
<p>下图则是o1&lt;=o2&lt;=o3</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/026.png"  alt="img"></p>
<h3 id="跳跃表-1"><a href="#跳跃表-1" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>仅靠多个跳跃表节点就可以组成一个跳跃表</p>
<p>通过使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量等信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplist&#123;</span><br><span class="line">	&#x2F;&#x2F;表头节点和表尾节点</span><br><span class="line">	structz skiplistNode * header,*tail;</span><br><span class="line">	&#x2F;&#x2F;表中节点的数量</span><br><span class="line">	unsigned long length;</span><br><span class="line">	&#x2F;&#x2F;表中层数最大的节点的层数</span><br><span class="line">	int level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure>

<h2 id="重点回顾-2"><a href="#重点回顾-2" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>跳跃表是有序集合的底层实现之一</p>
<p>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息(表头节点，表尾节点，长度)，而zskiplistNode则用于表示跳跃表节点</p>
<p>每个跳跃表节点的层高都是1至32之间的随机数</p>
<p>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的</p>
<p>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序</p>
<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现</p>
<h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><p>整数集合intset是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16,int32,int64的整数值，并且保证集合中不会出现重复元素，每个intset.h/intset结构表示一个整数集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">	&#x2F;&#x2F;编码方式</span><br><span class="line">	unit32_t encoding;</span><br><span class="line">	&#x2F;&#x2F;集合包含的元素数量</span><br><span class="line">	uint32_t length;</span><br><span class="line">	&#x2F;&#x2F;保存元素的数组</span><br><span class="line">	int8_t contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>

<p>contents数组是整数集合的底层实现，整数集合的每个元素都是contents数组的一个数组项，各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项</p>
<p>length属性记录了整数集合包含的元素数量，也即是contents数组的长度</p>
<p>虽然intset结构将contents属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值</p>
<p>如果encoding属性的值为int_16,那么contents就是一个int_16类型的数组，数组里的每个项都是一个int16类型的整数值</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面</p>
<p>升级整数集合并添加新元素共分为三步进行</p>
<ol>
<li>根据新元素的类型，扩展整数集合底层数组的大小，并为新元素分配空间</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放到正确的位上，而且在放置元素的过程中，需要维持底层数组的有序性质不变</li>
<li>将新元素添加到底层数组里面</li>
</ol>
<p>举个例子，假设现在有一个int16编码的整数集合，集合中包含三个int16类型的元素，三个int16的元素总占位48，现在假设我们将类型为int32的整数65535添加到整数集合里面，因为65535的类型int32比整数集合当前所有元素的类型都要长，所以在将65535添加到整数集合之前，程序需要先对整数集合进行升级</p>
<p>分配四个元素的空间32*4=128，虽然程序对底层数组进行了空间重分配，但数组原有的三个元素仍然是int16类型，这些元素还保存在数组的前48位里面，所以程序接下来需要将这三个元素转换成int32类型，并将转换后的元素放置到正确的位上面，而且在放置元素的过程中，需要维持底层数组的有序性质不变</p>
<p>首先，因为元素3在1，2，365535四个元素中排名第三，所以它将被移动到contens数组的索引2位置上，也就是数组64位到95位的空间上</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/027.png"  alt="img"></p>
<p>元素2，1同理</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/028.png"  alt="img"></p>
<p>最后程序将整数集合encoding属性的值从int16改为int32，并将length属性的值从3改为4,设置完成之后的整数集合如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/029.png"  alt="img"></p>
<p>每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度位O(N)</p>
<p>整数升级策略能够提升整数集合的灵活性，另一个是尽可能地节约内存</p>
<h4 id="升级后新元素的摆放那个位置"><a href="#升级后新元素的摆放那个位置" class="headerlink" title="升级后新元素的摆放那个位置"></a>升级后新元素的摆放那个位置</h4><p>因为引发升级的新元素的长度总是比现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素</p>
<p>在新元素小于所有元素的情况下，新元素会被放置在底层数组的最开头(索引0)</p>
<p>在新元素大于所有元素的情况下，新元素会被放置在底层数组的最末尾(索length-1)</p>
<h3 id="提升灵活性"><a href="#提升灵活性" class="headerlink" title="提升灵活性"></a>提升灵活性</h3><p>因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。但是整数集合可以通过自动升级底层数组来适应新元素，所以我们可以将int16,int32,int64类型的整数添加到集合中，而不必担心出现类型错误，这种做法非常灵活</p>
<h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态</p>
<h2 id="重点回顾-3"><a href="#重点回顾-3" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>整数集合是集合键的底层实现之一</p>
<p>整数集合的底层实现为数组，这个数组以有序，无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型</p>
<p>升级操作作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存</p>
<p>整数集合只支持升级操作，不支持降级操作</p>
<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>压缩列表ziplist是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现</p>
<p>执行以下命令将创建一个压缩列表实现的列表键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;rpush lst 1 3 5 10086 &quot;hello&quot; &quot;world&quot;</span><br><span class="line">redis&gt;object encoding lst</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>

<p>列表键里面包含的都是1，3，5，10086这样的小整数值，以及“hello”,”world”这样的短字符串</p>
<p>当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是最小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现</p>
<h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值</p>
<h3 id="压缩列表的各个组成部分"><a href="#压缩列表的各个组成部分" class="headerlink" title="压缩列表的各个组成部分"></a>压缩列表的各个组成部分</h3><p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/030.png"  alt="img"></p>
<h3 id="压缩列表各个组成部分的详细说明"><a href="#压缩列表各个组成部分的详细说明" class="headerlink" title="压缩列表各个组成部分的详细说明"></a>压缩列表各个组成部分的详细说明</h3><p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/031.png"  alt="img"></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>列表zlbytes属性的值为0x50(十进制80)，表示压缩列表的总长为80字节</p>
<p>列表zltail属性的值为0x3c(60),这表示如果我们有一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量60，就可以计算出表尾节点entry3的地址</p>
<p>列表zllen属性的值为0x3(十进制3)，表示压缩列表包含三个节点</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/032.png"  alt="img"></p>
<h2 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h2><p>每个压缩列表节点可以保存一个字节数组或者一个整数值，字节数组的长度可以是63(2^6-1)，16383(2^14-1)，4294967295(2^32-1)，而整数值则可以是以下六种长度的其中一种</p>
<ol>
<li>4位长，介于0至12之间的无符号整数</li>
<li>1字节长的有符号整数</li>
<li>3字节长的有符号整数</li>
<li>int16类型整数</li>
<li>int32类型整数</li>
<li>int64类型整数</li>
</ol>
<p>每个压缩列表节点都由length,encoding,content三个部分组成</p>
<h3 id="previous-entry-lenth"><a href="#previous-entry-lenth" class="headerlink" title="previous_entry_lenth"></a>previous_entry_lenth</h3><p>节点的previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度，previous_entry_length属性的长度可以是1字节或者5字节，程序可以根据当前节点的起始地址计算出前一个节点的起始地址，压缩列表的从表尾向表头遍历操作就是使用这一原理实现的</p>
<ul>
<li>如果前一字节的长度小于254字节，那么previous_entry_length属性的长度为1字节，前一节点的长度就保存在这一个字节里面</li>
</ul>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/033.png"  alt="img"></p>
<ul>
<li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节，其中属性的第一字节会被设置为0xFE(254),而之后的四个字节则用于保存前一节点的长度</li>
</ul>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/034.png"  alt="img"></p>
<h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>记录content属性所保存数据的类型及长度</p>
<ul>
<li>一字节，二字节或者五字节长，值的最高位为00，01或者10的是字节数组编码，这种编码表示节点的content属性保存着字节数组，数组长度由编码除去最高两位之后的其他记录</li>
<li>一字节长，值的最高位以11开头的是整数编码，这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码去除最高两位之后的其他位记录</li>
</ul>
<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定</p>
<p>编码的最高两位00表示节点保存的是一个字节数组</p>
<p>编码的后六位001011记录了字节数组的长度11</p>
<p>content属性保存着节点的值hello world</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/035.png"  alt="img"></p>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>如果一个节点的长度小于254字节，那么previous_entry_length属性需要1字节长的空间来保存这个长度值</p>
<p>如果前一节点的长度大于等于254字节，那么previous_entry_length属性需要用5字节长的空间来保存这个长度值</p>
<p>考虑这样一种情况，在一个压缩列表中，有多个连续的，长度介于250字节到253字节之间的节点e1至eN</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/036.png"  alt="img"></p>
<p>因为e1至eN的所有节点的长度都小于254字节，所以记录这些节点的长度只需要1字节长的previous_entry_length属性。这时如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点，那么new将成为e1的前置节点</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/037.png"  alt="img"></p>
<p>因为e1的previous_entry_length属性仅仅长1字节，它没办法保存新节点new的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节点的previous_entry_length从原来的1字节扩展为5字节长</p>
<p>e1原本的长度介于250字节至253字节之间，在为previous_entry_length属性新增四个字节的空间之后，e1的长度就变成了介于254字节至257字节，而这种长度使用一字节的previous_entry_length属性是没办法保存的，所以扩展e1引发对e2的扩展一样，扩展e2也会引发对e3的扩展…</p>
<p>Redis将这种在特殊情况下产生的连续多次空间扩展称之为连锁更新</p>
<p>除了添加节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新</p>
<p>因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N),所以连锁更新的最坏复杂度是O(N^2)</p>
<p>压缩列表产生大面积连锁更新的概率不大，平均复杂度仅为O(N),实际操作中，不必为使用ziplistpush等命令担心</p>
<h2 id="重点回顾-4"><a href="#重点回顾-4" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>压缩列表是一种为节约内存而开发的顺序型数据结构</p>
<p>压缩列表被用作列表键和哈希键的底层实现之一</p>
<p>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数数组</p>
<p>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的概率比较小</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象，列表对象，哈希对象，集合对象和有序集合对象这五种类型的对象，每个对象都用到了至少一种前面所介绍的数据结构</p>
<p>通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以根据不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率</p>
<p>Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放。Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存</p>
<p>Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除</p>
<h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>Redis使用对象来表示数据库中的键和值，每当在Redis中新创建一个键值对时，至少会创建两个对象，一个对象用作键值对的键，另一个对象用作键值对的值</p>
<p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性，encoding属性和ptr属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisobject&#123;</span><br><span class="line">	&#x2F;&#x2F;类型</span><br><span class="line">	unsigned type:4;</span><br><span class="line">	&#x2F;&#x2F;编码</span><br><span class="line">	unsigned encoding:4;</span><br><span class="line">	&#x2F;&#x2F;指向底层实现数据结构的指针</span><br><span class="line">	void *ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>对象的type属性记录了对象的类型，这个属性的值可以是下表中的任意一个</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/038.png"  alt="img"></p>
<p>键总是一个字符串对象，而值则可以是字符串对象，列表对象，哈希对象，集合对象或者有序集合对象的其中一种</p>
<p>对一个数据库键执行TYPE命令时，命令返回的结果为数据库键对应的值对象的类型，而不是键对象的类型</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/039.png"  alt="img"></p>
<h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定</p>
<p>encoding属性记录了对象所使用的编码</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/040.png"  alt="img"></p>
<p>每种类型的对象都至少可以使用了两种不同的编码，下图列出了每种类型的对象可以使用的编码</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/041.png"  alt="img"></p>
<p>使用object encoding命令可以查看一个数据库键的值对象的编码</p>
<p>不同的编码的对象所对应的object encoding命令输出</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/042.png"  alt="img"></p>
<p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象使用不同的编码，从而优化对象在某一场景下的效率</p>
<p>例如，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现</p>
<ul>
<li>压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中</li>
<li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的又是在逐渐消失时，对象就会将底层实现从压缩列表转向功能更强，也更适合保存大量元素的双端链表上面</li>
</ul>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>字符串对象的编码可以是int,raw,embstr</p>
<ol>
<li><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面(将void替换成long),并将字符串对象的编码设置为int</p>
</li>
<li><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串SDS来保存这个字符串值，并将对象的编码设置为raw</p>
</li>
<li><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值</p>
</li>
</ol>
<p>embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分配创建redisobject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构</p>
<p>不同的编码对应着不同的数据结构，也对应着不同的数据结构创建方式</p>
<p>embstr编码的字符串对象在执行命令时，产生的效果和raw编码的字符串对象执行命令时产生的效果是相同的，但使用embstr编码的字符串对象来保存短字符串有以下好处</p>
<ul>
<li>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次</li>
<li>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数</li>
<li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串能够更好地利用缓存带来的优势</li>
</ul>
<p>例如，以下命令创建了一个embstr编码的字符串对象作为msg键的值，值对象如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;set msg &quot;hello&quot;</span><br><span class="line">redis&gt;object encoding msg</span><br><span class="line">embstr</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/043.png"  alt="img"></p>
<p>可以用long double类型表示浮点数在redis中也是作为字符串值来保存的，如果我们要保存一个浮点数到字符串对象里面，那么程序员会先将这个浮点数转换成字符串值，然后再保存转换所得的字符串值</p>
<p>程序会先取出字符串对象里面保存的字符串3.14，将它转化回浮点数值3.14，然后把3.14和2.0相加得出的值5.14转换成字符串5.14，并将这个5.14保存到字符串对象里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;incrbyfloat pi 2.0</span><br><span class="line">&quot;5.14&quot;</span><br><span class="line">redis&gt;object encoding pi</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<p>下图是字符串对象保存各种不同类型的值所使用的编码方式</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/044.png"  alt="img"></p>
<h3 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h3><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象</p>
<p>对于int编码的字符串对象来说，如果向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw</p>
<p>下面的示例，通过append命令，向一个保存整数值的字符串对象追加了一个字符串值，因为追加操作只能对字符串值执行，所以程序会先将之前保存的整数值10086转换为字符串值”10086“，然后再执行追加操作，操作的执行结果就是一个raw编码的，保存了字符串值的字符串对象</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/045.png"  alt="img"></p>
<p>因为redis没有为embstr编码的字符串对象编写任何相应的修改程序，只有int编码的字符串对象和raw编码的字符串对象有这些程序，所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw,然后再执行修改命令，因为这个原因，embstr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/046.png"  alt="img"></p>
<h3 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h3><p>因为字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/047.png"  alt="img"></p>
<h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表对象的编码可以是ziplist或者linkedlist</p>
<p>ziplist编码的列表对象作为底层实现，每个压缩列表节点保存了一个列表元素，如果执行rpush命令，那么服务器将创建一个列表对象作为numbers键的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;rpush numbers 1 &quot;three&quot; 5</span><br></pre></td></tr></table></figure>

<p>如果numbers键的值对象使用的是ziplist编码，这个值对象将会如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/048.png"  alt="img"></p>
<p>linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/049.png"  alt="img"></p>
<p>linkedlist编码的列表对象在底层的双端链表结构中包含了多个字符串对象，这种嵌套字符串对象的行为在哈希对象，集合对象和有序集合对象中都会出现，字符串对象是Redis五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象</p>
<p>为了简化字符串对象的表示</p>
<h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于64字节</li>
<li>列表对象保存的元素数量小于512个</li>
</ol>
<p>不能满足这两个条件的列表对象需要使用linkedlist编码</p>
<p>以上两个条件的上限值是可以修改的</p>
<p>对于ziplist编码的列表对象来说，当使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面，对象编码也会从ziplist变为linkedlist</p>
<p>以下代码展示了列表对象因为保存了长度太大的元素而进行编码转换的情况</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/050.png"  alt="img"></p>
<p>以下代码展示了列表对象因为保存的元素数量过多而进行编码转换的情况</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/051.png"  alt="img"></p>
<h3 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h3><p>因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象来构建的，下图列出了其中一部分列表键命令，以及这些命令在不同编码的列表对象下的实现方法</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/052.png"  alt="img"></p>
<h1 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h1><p>哈希对象的编码可以是ziplist或者hashtable</p>
<p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾</p>
<p>因此保存了同一键值对的两个节点总是紧挨在在一起，保存键的节点在前，保存值的节点在后；先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后添加到哈希对象中的键值对会被放在压缩列表的表尾方向</p>
<p>例如，我们执行以下HSET命令，那么服务器将创建一个列表对象作为profile键的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;HSET profile name &quot;TOM&quot;</span><br><span class="line">redis&gt;HSET profile age 25</span><br><span class="line">redis&gt;HSET profile career &quot;Programmer&quot;</span><br></pre></td></tr></table></figure>

<p>如果profile键的值对象使用的是ziplist编码，那么这个值对象将会如下</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/053.png"  alt="img"></p>
<p>其中对象所使用的压缩列表如下</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/054.png"  alt="img"></p>
<p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存</p>
<ol>
<li>字典的每个键都是一个字符串对象，对象中保存了键值对的键</li>
<li>字典的每个值都是一个字符串对象，对象中保存了键值对的值</li>
</ol>
<p>哈希对象如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/055.png"  alt="img"></p>
<h2 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h2><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节</li>
<li>哈希对象保存的键值对数量小于512个</li>
</ol>
<p>不能满足这两个条件的哈希对象需要使用hashtable编码</p>
<p>对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面，对象的编码也会从ziplist变为hashtable</p>
<p>以下代码展示了哈希对象因为键值对的键长度太大而引起编码转换的情况</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/056.png"  alt="img"></p>
<p>除了键的长度太大会引起编码转换之外，值的长度太大也会引起编码转换，以下代码展示了这种情况</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/057.png"  alt="img"></p>
<p>以下代码展示哈希对象因为包含的键值对数量过多而引起编码转换的情况</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/058.png"  alt="img"></p>
<h2 id="哈希命令的实现"><a href="#哈希命令的实现" class="headerlink" title="哈希命令的实现"></a>哈希命令的实现</h2><p>因为哈希键的值为哈希对象，所以用于哈希键的所有命令都是针对哈希对象来构建的，下图列出了一部分哈希键命令，以及这些命令在不同编码的哈希对象下的实现方法</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/059.png"  alt="img"></p>
<h1 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h1><p>集合对象的编码可以是intset或者hashtable</p>
<p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面</p>
<p>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/060.png"  alt="img"></p>
<h2 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码</p>
<ol>
<li>集合对象保存的所有元素都是整数值</li>
<li>集合对象保存的元素数量不超过512个</li>
</ol>
<p>不能满足这两个条件的集合对象需要使用hashtable编码</p>
<p>对于使用intset编码的集合对象来说，当使用intset编码所需的两个条件的任意一个 不能被满足时，就会执行对象的编码转换操作，原本保存在整数集合中的所有元素都会被转移并保存到字典里面，并且对象的编码也会从intset变为hashtable</p>
<p>以下代码创建了一个只包含整数元素的集合对象，该对象的编码为intset</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;sadd numbers 1 3 5</span><br><span class="line">redis&gt;object encoding numbers</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>

<p>只要往只包含整数元素的集合中添加一个字符串元素，集合对象的编码转移操作就会被执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;sadd numbers &quot;seven&quot;</span><br><span class="line">redis&gt;object encoding numbers</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<p>如果创建一个包含超过512个整数元素的集合对象，那么对象的编码应该hashtable\</p>
<h2 id="集合命令的实现"><a href="#集合命令的实现" class="headerlink" title="集合命令的实现"></a>集合命令的实现</h2><p>因为集合键的值为集合对象，所以用于集合键的所有命令都是针对集合对象来构建的，下图列出了其中一部分集合键命令以及这些命令在不同编码的集合对象下的实现方法</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/061.png"  alt="img"></p>
<h1 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h1><p>有序集合的编码可以是ziplist或者skiplist</p>
<p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个元素则保存元素的分值</p>
<p>压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向</p>
<p>如果执行zadd命令，那么服务器将创建一个有序集合对象作为price键的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;zadd price 8.5 apple 5.0 banana 6.0 cherry</span><br></pre></td></tr></table></figure>

<p>如果price键的值对象使用的是ziplist编码，那么这个值对象如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/062.png"  alt="img"></p>
<p>值对象所使用的压缩列表如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/063.png"  alt="img"></p>
<p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset&#123;</span><br><span class="line">	zskiplist * zsl;</span><br><span class="line">	dict * dict;</span><br><span class="line">&#125;zset;</span><br></pre></td></tr></table></figure>

<p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素，跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，比如zrank,zrange等命令就是基于跳跃表api来完成的</p>
<p>zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，字典的键保存了元素的成员，而字典的值则保存了元素的分值，通过这个字典，程序可以用O(1)复杂度查找给定成员的分值，zscore命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性</p>
<p>有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。虽然zset结构同时使用跳跃表和字典保存有序集合，但这两种数据机构都会通过指针来共享元素的成员和分值，所以同时使用跳跃表和字典来保存元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存</p>
<h2 id="为什么有序集合需要同时使用跳跃表和字典来实现？"><a href="#为什么有序集合需要同时使用跳跃表和字典来实现？" class="headerlink" title="为什么有序集合需要同时使用跳跃表和字典来实现？"></a>为什么有序集合需要同时使用跳跃表和字典来实现？</h2><p>理论上可以单独使用字典或者跳跃表的其中一种结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低</p>
<p>如果只使用跳跃表，因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1)上升到O(logN)</p>
<p>如果price键创建的不是ziplist编码的有序集合对象，而是skiplist编码的有序集合对象，那么这个有序集合对象如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/064.png"  alt="img"></p>
<p>对象所使用的zset结构如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/065.png"  alt="img"></p>
<p>字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也不会因此而浪费任何内存</p>
<h2 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h2><p>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码</p>
<ol>
<li>有序集合保存的元素数量小于128个</li>
<li>有序集合保存的所有元素成员的长度都小于64字节</li>
</ol>
<p>不能满足以上两个条件的有序集合对象将使用skiplist编码</p>
<p>有序集合命令</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/066.png"  alt="img"></p>
<h1 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h1><p>Redis中用于操作键的命令基本上可以分为两种类型，其中一种命令可以对任何类型的键执行，例如DEL命令，EXPIRE命令，RENAME命令，OBJECT命令</p>
<p>另一种命令只能对特定类型的键执行，如下图</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/067.png"  alt="img"></p>
<h2 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h2><p>为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令</p>
<p>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的</p>
<ol>
<li>在执行一个类型特定命令之前，服务器先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令</li>
<li>否则服务器就会执行拒绝命令，并向客户端返回一个类型错误</li>
</ol>
<h2 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h2><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令</p>
<p>如果对一个键执行LLEN命令，那么服务器除了要确保执行命令的列表键之外，还需要根据键的值对象所使用的编码来选择正确的LLEN命令实现</p>
<p>如果列表对象的编码是ziplist，那么说明列表对象的实现为压缩列表，程序将使用ziplistLen函数来返回列表的长度</p>
<p>如果列表对象的编码为linkedlist，那么说明列表对象的实现为双端链表，程序将使用listLength函数来返回双端链表的长度</p>
<p>可以认为LLEN命令是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/068.png"  alt="img"></p>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建一个引用计数技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p>
<p>每个对象的引用计数信息由redisObject结构的refcount属性记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisobject&#123;</span><br><span class="line">	&#x2F;&#x2F;引用计数</span><br><span class="line">	int refcount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象的引用计数信息会随着对象的使用状态而不断变化</p>
<ol>
<li>在创建一个新的对象时，引用计数器的值会被初始化为1</li>
<li>当对象被一个新程序使用时，引用计数值加一</li>
<li>当对象不再被一个程序使用时，它的引用计数值会被减一</li>
<li>当对象的引用计数值变为0时，对象所占用的内存会被释放</li>
</ol>
<p>修改对象引用计数的API</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/069.png"  alt="img"></p>
<p>对象的整个生命周期可以划分为创建对象，操作对象，释放对象三个阶段</p>
<h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用</p>
<p>假设键A创建了一个包含整数值100的字符串对象作为值对象，这时键B也要创建一个同样保存了整数值100的字符串对象作为值对象，那么服务器有以下两种做法</p>
<ol>
<li>让键B新创建一个包含整数值100的字符串对象</li>
<li>让键A和键B共享同一个字符串对象</li>
</ol>
<p>Redis让多个键共享同一个值对象需要执行以下两个步骤</p>
<ol>
<li>将数据库键的值指针指向一个现有的值对象</li>
<li>将被共享的值对象的引用计数增一</li>
</ol>
<p>Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值0到9999的字符串对象时，服务器就会使用这些共享对象，而不是创建新对象</p>
<p>创建共享字符串对象的数量可以通过修改redis.h/redis_shared_integers常量来修改</p>
<p>如果创建一个值为100的键A，并使用object refcount命令查看键A的值对象的引用计数，会发现值对象的引用计数为2，引用这个值对象的两个程序分别是持有这个值对象的服务器程序，以及共享这个值对象的键A</p>
<p>共享对象不单单只有字符串键可以使用，那些在数据结构中嵌套了字符串对象的对象，例如列表对象，哈希对象，集合对象，有序集合对象都可以使用这些共享对象</p>
<h3 id="为什么Redis不共享包含字符串的对象"><a href="#为什么Redis不共享包含字符串的对象" class="headerlink" title="为什么Redis不共享包含字符串的对象"></a>为什么Redis不共享包含字符串的对象</h3><p>当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想要创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的cpu时间就会越多。因此Redis只对包含整数值的字符串对象进行共享</p>
<h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>除了前面介绍的type,encoding,ptr,refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令访问的时间</p>
<p>object idletime命令可以打印出给定键的空转时间，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的</p>
<h1 id="单机数据库的实现"><a href="#单机数据库的实现" class="headerlink" title="单机数据库的实现"></a>单机数据库的实现</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>Redis服务器将所有的数据库都保存在服务器状态redis.h/redisServer结构db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">	&#x2F;&#x2F;一个数组，保存着服务器中所有的数据库</span><br><span class="line">	redisDB*db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer&#123;	</span><br><span class="line">	&#x2F;&#x2F;服务器的数据库数量</span><br><span class="line">	int dbnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dbnum属性的值由服务器配置的database选项决定，该选项的值为16，所以redis服务器默认会创建16个数据库</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/070.png"  alt="img"></p>
<h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>Redis客户端的默认目标数据库为0号数据库，但客户端可以通过执行select命令来切换目标数据库</p>
<p>在服务器内部，客户端redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisClient&#123;</span><br><span class="line">	&#x2F;&#x2F;记录客户端当前正在使用的数据库</span><br><span class="line">	redisDb * db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/071.png"  alt="img"></p>
<p>通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能，这就是select命令的实现原理</p>
<h3 id="谨慎处理多数据库程序"><a href="#谨慎处理多数据库程序" class="headerlink" title="谨慎处理多数据库程序"></a>谨慎处理多数据库程序</h3><p>Redis没有可以返回客户端目标数据库的命令，虽然redis-cli客户端会在输入符旁边提示当前所使用的目标数据库。但如果你在其他语言的客户端中执行redis命令，数次切换数据库之后，很可能会忘记当前正在使用的是哪个数据库，为了避免对数据库进行误操作，在执行redis命令尤其是flushdb这样的危险命令之前，最好先执行一个select命令，显示地切换到指定的数据库，然后才执行别的命令</p>
<h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><p>redis是一个键值对数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典成为键空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb&#123;</span><br><span class="line">	&#x2F;&#x2F;数据库键空间，保存着数据库中过的所有键值对</span><br><span class="line">	dict * dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>键空间和用户所见的数据库是直接对应的</p>
<p>键空间的键也就是数据库的键，每个键都是一个字符串对象</p>
<p>键空间的值也就是是数据库的值，每个值可以是字符串对象，列表对象，哈希表对象，集合对象和有序集合对象中的任意一种redis对象</p>
<p>例如，如果在空白的数据库中执行以下命令</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/072.png"  alt="img"></p>
<p>这些命令执行以后，数据库的键空间就会如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/073.png"  alt="img"></p>
<p>数据库的键空间是一个字典</p>
<h3 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;set date &quot;200&quot;</span><br></pre></td></tr></table></figure>

<h3 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;del book;</span><br></pre></td></tr></table></figure>

<h3 id="更新键"><a href="#更新键" class="headerlink" title="更新键"></a>更新键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;set message &quot;balabala&quot;</span><br></pre></td></tr></table></figure>

<h3 id="对键取值"><a href="#对键取值" class="headerlink" title="对键取值"></a>对键取值</h3><p>实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同</p>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/074.png"  alt="img"></p>
<h4 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;LRANGE alphabet 0 -1</span><br><span class="line">1)&quot;a&quot;</span><br><span class="line">2)&quot;b&quot;</span><br><span class="line">3)&quot;c&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/075.png"  alt="img"></p>
<h3 id="其他键空间操作"><a href="#其他键空间操作" class="headerlink" title="其他键空间操作"></a>其他键空间操作</h3><p>flushdb:通过删除键空间中的所有键值对来实现的，用于清空整个数据库</p>
<p>randomkey:就是通过在键空间中随机返回一个键来实现的</p>
<p>dbsize:通过返回键空间中包含的键值对的数量来实现的，返回数据库键数量</p>
<h3 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h3><p>当使用redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作</p>
<p>读取一个键之后(读操作和写操作都要对键进行读取)，服务器会根据键是否存在来更新服务器的键空间命中次数或键空间不命中次数</p>
<p>在读取一个键之后，服务器会更新键的LRU(最后一次使用)时间，这个值可以用于计算键的闲置时间</p>
<p>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的操作</p>
<p>如果有客户端使用watch命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏，从而让事务程序注意到这个键已经被修改，服务器每次修改一个键之后，都会对脏键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作</p>
<p>如果服务器开启了数据通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知</p>
<h3 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h3><p>通过expire命令或者pexpire命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间TTL,在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;set key value;</span><br><span class="line">redis&gt;expire key 5</span><br><span class="line">redis&gt;get key &#x2F;&#x2F;五秒之内</span><br><span class="line">“value&quot;</span><br><span class="line">redis&gt;get key &#x2F;&#x2F;五秒之后</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>setex命令可以在设置一个字符串键的同时为键设置过期时间，因为这个命令是一个类型限定的命令(只能用于字符串键)，setex命令设置过期时间的原理和expire命令设置过期时间的原理是一样的</p>
<p>与expire命令和pexpire命令类似，客户端可以通过expireat命令或pexpireat命令，以秒或者毫秒精度给数据库中的某个键设置过期时间</p>
<p>过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;set key value</span><br><span class="line">redis&gt;expireat key 1377257300</span><br><span class="line">redis&gt;TIME</span><br><span class="line">&quot;1377257296&quot;</span><br><span class="line">&quot;296543&quot;</span><br><span class="line"></span><br><span class="line">redis&gt;get key  &#x2F;&#x2F;1377257300之前</span><br><span class="line">&quot;value&quot;</span><br><span class="line">redis&gt;TIME</span><br><span class="line">&quot;1377257303&quot;</span><br><span class="line">&quot;230656&quot;</span><br><span class="line">redis&gt;get key	&#x2F;&#x2F;1377257300之后</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/076.png"  alt="img"></p>
<h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><p>redis有四个不同的命令可以用于设置键的生存时间或过期时间</p>
<ol>
<li>expire<key><ttl>命令用于将键key的生存时间设置为ttl秒</ttl></key></li>
<li>pexpire<key><ttl>命令用于将键key的生存时间设置为ttl毫秒</ttl></key></li>
<li>expireat<key><timestamp>命令用于将键key的生存时间设置为timestamp所指定的秒数时间戳</timestamp></key></li>
<li>pexpireat<key><timestamp>命令用于将键key的生存时间设置为timestamp所指定的毫秒数时间戳</timestamp></key></li>
</ol>
<p>以上四个命令都是基于pexpireat命令来实现的，无论通过那种方式设置过期时间，经过转换之后，最终的执行效果都和执行pexpireat命令一样</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/077.png"  alt="img"></p>
<h3 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h3><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称之为字典的过期字典</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象</li>
<li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间，一个毫秒精度的UNIX时间戳</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb&#123;</span><br><span class="line">	&#x2F;&#x2F;过期字典，保存着键的过期时间</span><br><span class="line">	dict *expires;</span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure>

<p>下图展示了一个带有过期字典的数据库列子，键空间保存了数据库中的所有键值对，而过期字典则保存了数据库键的过期时间</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/078.png"  alt="img"></p>
<p>第一个键值对的键位alphabet键对象，值为1385877600000(2013年12月1日零时)</p>
<p>当客户端执行pexpireat命令为一个数据库键设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间</p>
<h3 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h3><p>persist命令可以移除一个键的过期时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;pexpireat message 1391234400000</span><br><span class="line">redis&gt;TTL message</span><br><span class="line">13893281</span><br><span class="line">redis&gt;persist message</span><br><span class="line">1</span><br><span class="line">redis&gt;TTL message</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>persist命令就是pexpireat命令的反操作，persist命令在过期字典中查找给定的键，并解除键和值在过期字典中过的关联</p>
<h3 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h3><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL以毫秒为单位返回键的剩余生存时间</p>
<p>TTL和PTTL两个命令都是通过计算键的过期时间和当前时间之间的差来实现的</p>
<h3 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h3><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期</p>
<p>检查给定键是否存在于过期字典，如果存在，那么获取键的过期时间</p>
<p>检查当前UNIX时间戳是否大于键的过期时间，如果是的话，那么键已经过期，否则的话，键未过期</p>
<p>对某个键执行TTL/PTTL命令，返回值大于0，该键未过期，反之则过期</p>
<h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><ol>
<li>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作</li>
<li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键</li>
<li>定期删除：每个一段时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定</li>
</ol>
<p>这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略</p>
<h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>对cpu不太友好，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分cpu，在内存不紧张但是cpu时间非常紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响</p>
<p>如果有大量的命令请求在等待服务器处理，并且服务器当前不缺少内存，那么服务器应该优先将cpu时间用在处理客户端的命令上面，而不是用在删除过期键上面</p>
<p>创建一个定时器需要用到redis服务器中的时间事件，而当前时间事件的实现方式——无序列表，查找一个事件的事件复杂度O(N)并不能高效地处理大量时间事件，因此要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>对cpu时间来说是非常友好的，程序只会在取出键时才对键进行过期检查，可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关过期键上花费任何cpu时间</p>
<p>但是对内存是最不友好的是最不友好的，如果一个键已经过期，而这个键又仍然保存在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放</p>
<p>在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远都不会被删除(除非用户手动执行flushdb),我们甚至可以将这种情况看作是一种内存泄漏，无用的垃圾占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖内存的redis服务器来说，肯定不是一个好消息</p>
<p>对于一些和时间有关的数据，比如日志，在某个时间点之后，对它们的访问就会大大减少，甚至不再访问，如果这类过期数据大量地积压在数据库中，用户却以为已经删除了，那么造成的后果肯定是非常严重的</p>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>定时删除占用太多cpu时间，影响服务器的响应时间和吞吐量</p>
<p>惰性删除浪费太多内存，有内存泄漏的危险</p>
<h5 id="定期策略是前两种策略的一种整合折中"><a href="#定期策略是前两种策略的一种整合折中" class="headerlink" title="定期策略是前两种策略的一种整合折中"></a>定期策略是前两种策略的一种整合折中</h5><ol>
<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作执行时长和频率来减少删除操作对CPU时间的影响</li>
<li>除此之外，通过定期删除过期键，有效地减少了因为过期键而带来的内存浪费</li>
</ol>
<h5 id="定期删除策略的难点是确定是删除操作执行的时长和频率"><a href="#定期删除策略的难点是确定是删除操作执行的时长和频率" class="headerlink" title="定期删除策略的难点是确定是删除操作执行的时长和频率"></a>定期删除策略的难点是确定是删除操作执行的时长和频率</h5><ol>
<li>如果删除操作执行太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将cpu时间过多地消耗在删除过期键上面</li>
<li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况</li>
</ol>
<p>因此如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率</p>
<h2 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h2><p>Redis服务器实际上使用的是惰性删除和定期删除两种策略，通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡</p>
<h2 id="AOF，RDB和复制功能对过期键的处理"><a href="#AOF，RDB和复制功能对过期键的处理" class="headerlink" title="AOF，RDB和复制功能对过期键的处理"></a>AOF，RDB和复制功能对过期键的处理</h2><h3 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h3><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中</p>
<h3 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h3><p>如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入</p>
<p>如果服务器以主服务器模式运行，那么载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被加载到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响</p>
<p>如果服务器从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中，因为主从服务器在进行数据同步的时候，从服务器的数据库会被清空，所以过期键对载入RDB文件的从服务器也不会造成影响</p>
<h3 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h3><p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响</p>
<p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，来显示地记录该键已被删除</p>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>在生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存不会被保存到重写后的AOF文件中</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制</p>
<ol>
<li>主服务器在删除一个过期键之后，会显示地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键</li>
<li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是像处理未过期的键一样处理过期键</li>
<li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键</li>
</ol>
<p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会接着存在</p>
<h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>数据库通知是redis2.8版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况</p>
<p>以下代码展示了客户端如何获取0号数据库中针对message键执行的所有命令</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/079.png"  alt="img"></p>
<p>先后公有set,expire,del三个命令对键message进行了操作</p>
<p>这一类关注某个键执行了什么命令的通知称为键空间通知，除此以外，还有另一类称为键事件通知的通知，它们关注的是某个命令被什么键执行了</p>
<p>以下是一个键事件通知的例子，代码展示了客户端如何获取0号数据库中所有执行DEL命令的键</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/080.png"  alt="img"></p>
<p>根据发回的通知显示，key,number,message三个键先后执行了DEL命令</p>
<p>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/081.png"  alt="img"></p>
<h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><h3 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h3><h2 id="重点回顾-5"><a href="#重点回顾-5" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存</li>
<li>客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库</li>
<li>数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间</li>
<li>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的</li>
<li>数据库的键总是一个字符串对象，而值则可以是任意一种redis对象类型，包括字符串对象，哈希表对象，集合对象，列表对象和有序集合对象，分别对应字符串键，哈希表键，集合键，列表键和有序集合键</li>
<li>expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳</li>
<li>Redis使用惰性删除和定期删除两种策略来删除过期的键，惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键</li>
<li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包括已经过期的键</li>
<li>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键</li>
<li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键</li>
<li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一，中心化的过期键删除策略可以保证主从数据库的一致性</li>
<li>当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知</li>
</ul>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，我们将服务器中的非空数据库以及它们的键值对统称为数据库状态</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/082.png"  alt="img"></p>
<p>因为Redis是内存数据库，它将自己的数据库状态存储在内存里面，所以如果不想办法将存储在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见</p>
<p>RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态</p>
<h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>SAVE,BGSAVE这两个命令可以用于生成RDB文件</p>
<p>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</p>
<p>BGSAVE命令会派生出一个子进程，然后又子进程负责创建RDB文件，服务器进程(父进程)接着处理命令请求</p>
<p>创建RDB文件的实际工作由rdb.c/rdbsave函数完成，SAVE命令和BGSAVE命令会以不同的方式调用这个函数</p>
<p>和使用SAVE命令或者BGSAVE命令创建RDB文件不同，RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件</p>
<p>因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p>
<ol>
<li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态</li>
<li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态</li>
</ol>
<h4 id="BGSAVE命令执行期间，服务器处理SAVE，BGSAVE，BGREWRITEAOF三个命令的方式会和平时有所不同"><a href="#BGSAVE命令执行期间，服务器处理SAVE，BGSAVE，BGREWRITEAOF三个命令的方式会和平时有所不同" class="headerlink" title="BGSAVE命令执行期间，服务器处理SAVE，BGSAVE，BGREWRITEAOF三个命令的方式会和平时有所不同"></a>BGSAVE命令执行期间，服务器处理SAVE，BGSAVE，BGREWRITEAOF三个命令的方式会和平时有所不同</h4><p>在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE和BGSAVE命令同时执行是为了避免父进程(服务器进程)和子进程同时执行两个rdbSave调用，防止产生竞争条件</p>
<p>BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件</p>
<h4 id="BGREWRITEAOF和BGSAVE两个命令不能同时执行"><a href="#BGREWRITEAOF和BGSAVE两个命令不能同时执行" class="headerlink" title="BGREWRITEAOF和BGSAVE两个命令不能同时执行"></a>BGREWRITEAOF和BGSAVE两个命令不能同时执行</h4><p>如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行</p>
<p>如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝</p>
<p>因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，不是一个好主意</p>
<p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止</p>
<h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p>SAVE会阻塞服务器，而BGSAVE命令则不会，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令</p>
<p>用户可以通过save选项设置多个保存条件，只要其中任意一个条件被满足，服务器就会执行BGSAVE命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60  10000</span><br></pre></td></tr></table></figure>

<p>只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行</p>
<ol>
<li>900秒之内，对数据库进行了至少1次修改</li>
<li>300秒之内，对数据库进行了至少10次修改</li>
<li>60秒之内，对数据库进行了至少10000次修改</li>
</ol>
<h3 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h3><p>用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60  10000</span><br></pre></td></tr></table></figure>

<p>接着，服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性，saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存一个save选项设置的保存条件</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/083.png"  alt="img"></p>
<h3 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h3><p>服务器还维持着一个dirty计数器，以及一个lastsave属性</p>
<ol>
<li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态进行了多少次修改(包括写入，删除，更新等操作)</li>
<li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间</li>
</ol>
<h3 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h3><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足，就执行BGSAVE命令</p>
<h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/084.png"  alt="img"></p>
<p>全大写单词表示常量，全小写单词表示变量和数据</p>
<p>RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着REDIS五个字符，通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否是RDB文件</p>
<p>因为RDB文件保存的是二进制数据，而不是C字符串，为了简便起见，我们用REDIS符号代表R,E,D,I,S五个字符，而不是带‘\0’结尾符号的C字符串</p>
<p>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如0006就代表RDB文件的版本为第六版</p>
<p>database部分包含着零个或者任意多个数据库，以及各个数据库中的键值对数据</p>
<ol>
<li>如果服务器的数据库状态为空，那么这个部分也为空，长度为0个字节</li>
<li>如果服务i去的数据库状态为非空，那么这个部分也为非空，根据数据库所保存键值对的数量，类型和内容不同，这个部分的长度也会有所不同</li>
</ol>
<p>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有的数据库键值对都已经载入完毕了</p>
<p>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS,db_version,databases,EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况发生</p>
<h3 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h3><p>一个RDB文件的databases部分可以保存任意多个非空数据库，例如，如果服务器的0号数据库和3号数据库非空，那么服务器将创建一个如下图所示的RDB文件</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/085.png"  alt="img"></p>
<p>每个非空数据库在RDB文件中都可以保存为SELECTDB，db_number,key_value_pairs三部分，如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/086.png"  alt="img"></p>
<p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码</p>
<p>db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节，2字节或者5字节。当程序读入db_number部分之后，服务器会调用select命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确数据库中</p>
<p>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起，根据键值对的数量，类型，内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所改变</p>
<p>下图展示了RDB文件中，0号数据库的结构</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/087.png"  alt="img"></p>
<p>下图展示了一个完整的RDB文件，文件中包含了0号数据库和3号数据库</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/088.png"  alt="img"></p>
<h3 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h3><p>RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的化，那么键值对的过期时间也会被保存在内</p>
<p>不带过期时间的键值对在RDB文件中由TYPE,key,value三部分组成</p>
<p>TYPE记录了value的类型，长度为1字节，值可以是以下常量的其中一个</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/089.png"  alt="img"></p>
<p>以上列出的每个TYPE常量都代表了一种对象类型或者底层编码，当服务器读入RDB文件中的键值对数据时，程序会根据TYPE的值来决定如何读入和解释value的数据</p>
<h4 id="key和value分别保存了键值对的键对象和值对象"><a href="#key和value分别保存了键值对的键对象和值对象" class="headerlink" title="key和value分别保存了键值对的键对象和值对象"></a>key和value分别保存了键值对的键对象和值对象</h4><ul>
<li>其中key总是一个字符串对象，它的编码方式和REDIS_RDB_TYPE_STRING类型的value一样，根据内容长度的不同，key的长度也会有所不同</li>
<li>根据TYPE类型的不同，以及保存内容长度的不同，保存value的结构和长度也会有所不同</li>
</ul>
<p>带有过期时间的键值对在RDB文件中的结构如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/090.png"  alt="img"></p>
<p>带有过期时间的键值对中的TYPE,key,value三个部分的意义，和前面不带过期时间的键值对的TYPE,key,value三个部分的意义完全相同，新增的EXPIRETIME_MS和ms意义如下</p>
<p>EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间</p>
<p>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/091.png"  alt="img"></p>
<h3 id="value编码"><a href="#value编码" class="headerlink" title="value编码"></a>value编码</h3><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构，长度也会有所不同</p>
<h2 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h2><h3 id="不包含任何键值对的RDB文件"><a href="#不包含任何键值对的RDB文件" class="headerlink" title="不包含任何键值对的RDB文件"></a>不包含任何键值对的RDB文件</h3><p>创建一个数据库状态为空的RDB文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;flushall</span><br><span class="line">redis&gt;save</span><br></pre></td></tr></table></figure>

<p>然后调用od命令，打印RDB文件</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/092.png"  alt="img"><br>根据之前学习的RDB文件结构知识，当一个RDB文件没有包含任何数据库数据时，这个RDB文件将由以下四个部分组成</p>
<ol>
<li>五个字节的REDIS字符串</li>
<li>四个字节的版本号db_version</li>
<li>一个字节的EOF常量</li>
<li>八个字节的校验和check_sum</li>
</ol>
<p>从od命令的输出中可以看出，最开头的是REDIS字符串，之后的0006是版本号，再之后的一个字节377代表EOF常量，最后的334 263 C 360 Z 334 362 V八个字节则代表RDB文件的校验和</p>
<h3 id="包含字符串键的RDB文件"><a href="#包含字符串键的RDB文件" class="headerlink" title="包含字符串键的RDB文件"></a>包含字符串键的RDB文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;flushall</span><br><span class="line">redis&gt;set msg &quot;hello&quot;</span><br><span class="line">redis&gt;save</span><br></pre></td></tr></table></figure>

<p>执行od命令</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/093.png"  alt="img"></p>
<p>当一个数据库被保存到RDB文件时，这个数据库将由以下三部分组成</p>
<ol>
<li>一个一字节长的特殊值SELECTDB</li>
<li>一个长度可能为一字节，两字节或者五字节的数据库号码db_number</li>
<li>一个或以上数量的键值对key_value_pairs</li>
</ol>
<p>观察od命令打印的输出，RDB文件的最开始仍然是REDIS和版本号0006，376代表SELECTDB常量，再之后\0代表整数0，表示被保存的数据库为0号数据库</p>
<p>在数据库号码之后，直到代表EOF常量的377为止，RDB文件包含有以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\0 003 M S G 005 H E L L O</span><br></pre></td></tr></table></figure>

<p>\0就是字符串类型的TYPE值REDIS_RDB_TYPE_STRING(这个常量的实际值为整数0)，之后的003是键MSG的长度值，再之后的005则是HELLO的长度</p>
<h3 id="包含带有过期时间的字符串键的RDB文件"><a href="#包含带有过期时间的字符串键的RDB文件" class="headerlink" title="包含带有过期时间的字符串键的RDB文件"></a>包含带有过期时间的字符串键的RDB文件</h3><p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/094.png"  alt="img"></p>
<h3 id="包含一个集合键的RDB文件"><a href="#包含一个集合键的RDB文件" class="headerlink" title="包含一个集合键的RDB文件"></a>包含一个集合键的RDB文件</h3><p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/095.png"  alt="img"></p>
<h3 id="关于分析RDB文件的说明"><a href="#关于分析RDB文件的说明" class="headerlink" title="关于分析RDB文件的说明"></a>关于分析RDB文件的说明</h3><p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/096.png"  alt="img"></p>
<h2 id="重点回顾-6"><a href="#重点回顾-6" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据</li>
<li>SAVE命令由服务器进程直接执行保存操作，所有该命令会阻塞服务器</li>
<li>BGSAVE命令由子进程执行保存操作，所以该命令不会阻塞服务器</li>
<li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令</li>
<li>RDB文件是一个经过压缩的二进制文件，由多个部分组成</li>
<li>对于不同类型的键值对，RDB文件会使用不同的方式来保存它们</li>
</ul>
<h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h1><p>与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的</p>
<p>AOF持久化功能的实现可以分为命令追加，文件写入，文件同步三个步骤</p>
<h3 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h3><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾</p>
<h3 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h3><p>Redis的服务器进程就是一个事件循环loop,这个循环中的文件事件负责接受客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数</p>
<p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面</p>
<p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定，各个不同值产生的行为如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/097.png"  alt="img"><br>如果用户没有主动为appendfsync选项设置值，那么appendfsync选项的默认值为everysec</p>
<p>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满，或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。这种做法虽然效率高，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性</p>
<p>例如，服务器在处理文件事件期间，执行了以下三个写入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sadd databases &quot;redis&quot; &quot;mongodb&quot; &quot;mariadb&quot;</span><br><span class="line">set data &quot;2013-9-5&quot;</span><br><span class="line">INCR click_counter 10086</span><br></pre></td></tr></table></figure>

<p>那么aof_buf缓冲区将包含这三个命令的协议内容，这时如果flushAppendOnlyFile函数被调用，假设服务器当前appendfsync选项的值为everysec，并且距离上次同步AOF文件已经超过一秒钟，那么服务器会先将aof_buf中的内容写入到AOF文件中，然后再对AOF文件进行同步</p>
<h4 id="AOF持久化的效率和安全"><a href="#AOF持久化的效率和安全" class="headerlink" title="AOF持久化的效率和安全"></a>AOF持久化的效率和安全</h4><p>服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性</p>
<p>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件，所以always的效率是appendfsync选项三个值当中最慢的一个，但从安全性来说，always也是最安全的，因为即使出现故障停机，AOF持久化也只会丢失一个事件循环所产生的命令数据</p>
<p>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。everysec模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据</p>
<p>当appendfsync的值为no时，服务器在每隔事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。因为处于no模式下的flushAppendOnlyFile调用无需执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似，当出现故障停机时，使用no模式的服务器将丢失上次同步AOF文件之后的所有写命令数据</p>
<h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态</p>
<p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/098.png"  alt="img"></p>
<ol>
<li>创建一个不带网络链接的伪客户端：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络链接，所以服务器使用了一个没有网络链接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络链接的客户端执行命令的效果完全一样</li>
<li>从AOF文件中分析并读取出一条命令</li>
<li>使用伪客户端执行被读出的写命令</li>
<li>一直执行步骤2和步骤3,直到AOF文件中的所有写命令都被处理完毕为止</li>
</ol>
<h2 id="AOF重写-1"><a href="#AOF重写-1" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>体积过大的AOF文件很可能对Redis服务器，甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的事件也就越多</p>
<p>例如，如果客户端执行以下命令：</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/099.png"  alt="img"></p>
<p>光是记录这个list键的状态，AOF文件就需要保存六条命令</p>
<p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写功能，通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新的AOF文件不会包含任何浪费空间的冗余命令，所以新的AOF文件的体积通常会比旧的AOF文件的体积要小得多</p>
<h3 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h3><p>AOF文件重写并不需要对现有的AOF文件进行任何读取，分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的</p>
<p>例如，如果服务器对list键执行了以下命令</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/100.png"  alt="img"></p>
<p>最简单高效的办法是直接从数据库中读取键list的值，然后用一条RPUSH list C D E F G命令来代替保存在AOF文件中的六条命令，这样就可以将保存list键所需的命令从六条减少到一条了</p>
<p>因为aof_rewrite函数生成的新的AOF文件只包含还原当前数据库状态所必须的命令，所以新AOF文件不会浪费任何磁盘空间</p>
<p>为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表，哈希表，集合，有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素，如果元素的数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。当前版本中，该常量的值是64，一个集合键包含了超过了64个元素，那么重写程序会用多条SADD命令来记录这个集合，并且每条命令设置的元素数量也为64个，其余数据结构同理</p>
<h3 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h3><p>因为AOF重写程序aof_write函数可以很好地完成创建一个新AOF文件的任务，但是，因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_write函数的话，那么在重写AOF文件期间，服务器键将无法处理客户端发来的命令请求</p>
<p>所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：</p>
<ol>
<li>子进程进行AOF重写期间，服务器进程(父进程)可以接着处理命令请求</li>
<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以避免使用锁的情况下，保证数据的安全性</li>
</ol>
<p>使用子进程有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要接着处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致</p>
<p>下图展示了一个AOF文件重写列子</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/102.png"  alt="img"></p>
<p>为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF从写缓冲区。也就是说，在子进程执行AOF重写期间，服务器进程需要执行以下三个工作</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/103.png"  alt="img"></p>
<ol>
<li>执行客户端发来的命令</li>
<li>将执行后的写命令追加到AOF缓冲区</li>
<li>将执行后的写命令追加到AOF重写缓冲区</li>
</ol>
<p>这样一来可以保证：</p>
<ol>
<li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行</li>
<li>从创建子进程开始，服务器执行的所有命令都会被记录到AOF重写缓冲区里面</li>
</ol>
<p>当子进程完成AOF重写工作之后，它会向父进程发送一个型号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作</p>
<ol>
<li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致</li>
<li>对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换</li>
</ol>
<p>在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程造成阻塞，其他时候，AOF后台重写都不会阻塞父进程</p>
<h2 id="重点回顾-7"><a href="#重点回顾-7" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态</p>
<p>AOF文件中的所有命令都以Redis命令请求协议的格式保存</p>
<p>命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件</p>
<p>appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响</p>
<p>服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态</p>
<p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小</p>
<p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无需对现有AOF文件进行任何读入，分析或者写入操作</p>
<p>在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件</p>
<ol>
<li>文件事件：Redis服务器通过套接字与客户端(或者其他Redis服务器)进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端(或者其他服务器)的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作</li>
<li>事件操作：Redis服务器中的一些操作，比如serverCron函数需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象</li>
</ol>
<h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器</p>
<ul>
<li>文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器</li>
<li>当被监听的套接字准备好执行连接应答，读取，写入，关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器即实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性</p>
<h3 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h3><p>文件事件处理器由套接字，I/O多路复用程序，文件事件分派器，以及事件处理器组成</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/104.png"  alt="img"></p>
<p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答，写入，读取，关闭等操作时，就会产生一个文件事件，因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现</p>
<h2 id="重点回顾-8"><a href="#重点回顾-8" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类</p>
<p>文件事件处理器是基于Reactor模式实现的网络通讯程序</p>
<p>文件事件是对套接字操作的抽象，每次套接字变为可应答，可写或者可读时，相应的文件事件就会产生</p>
<p>文件事件分为AE_READABLE事件(读事件)和AE_WRITEABLE写事件两类</p>
<p>时间事件分为定时事件和周期性事件，定时事件只在指定的时间到达一次，而周期性时间则每隔一段时间到达一次</p>
<p>服务器在一般情况下只执行serverCron函数一个时间，并且这个事件是周期性事件</p>
<p>文件事件和时间事件之间是合作关系，服务器会流转处理这两种事件，并且处理事件的过程中也不会进行抢占</p>
<p>时间事件的实际处理时间通常会比设定的到达时间晚一些</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Redis服务器是典型的一对多服务器程序，一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接受并处理客户端发送的命令请求，并向客户端返回命令回复</p>
<p>通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并于多个客户端进行网络通讯</p>
<p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构，这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构，其中包括：</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/105.png"  alt="img"></p>
<p>Redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历clients链表来完成</p>
<p>下图展示了一个与三个客户端进行连接的服务器</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/106.png"  alt="img"></p>
<p>下图是这个服务器clients链表的样子</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/107.png"  alt="img"></p>
<h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>客户端状态包含的属性可以分为两类：</p>
<p>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，它们都要用到这些属性</p>
<p>另一类是和特定功能相关的属性，比如操作数据库时需要用到的db属性和dictid属性，执行事务时需要用到的mstate属性，以及执行WATCH命令时需要用到的watched_keys属性等等</p>
<h3 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h3><p>客户端状态的fd属性记录了客户端正在使用的套接字描述符</p>
<p>根据客户端类型的不同，fd属性的值可以是-1或者是大于-1的整数</p>
<h3 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h3><p>默认情况下，一个连接到服务器的客户端是没有名字</p>
<p>比如下面展示的client list命令示例中，两个客户端的name域都是空白的</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/108.png"  alt="img"></p>
<p>使用client setname命令可以为客户端设置一个名字，让客户端的身份变得更清晰</p>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>客户端的标志属性flags记录了客户端的角色role，以及客户端目前所处的状态</p>
<h3 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h3><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求，输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但它的最大大小不能超过1GB，否则服务器将关闭这个客户端</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/109.png"  alt="img"></p>
<h3 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h3><p>在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性</p>
<p>argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数</p>
<p>argc属性则负责记录argv数组的长度</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/110.png"  alt="img"></p>
<h3 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h3><p>当服务器从协议中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数</p>
<p>下图展示了一个命令表示列，该表是一个字典，字典的键是一个SDS结构，保存了命令的名字，字典的值是命令所对应的redisCommand结构，这个结构保存了命令的实现函数，命令的标记，命令应该给定的参数个数，命令的总执行次数和总消耗时长等统计信息</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/111.png"  alt="img"></p>
<p>当程序在命令表中找到argv[0]所对应的redisCommand结构时，它会将客户端状态的cmd指针指向这个结构，之后服务器就可以使用cmd属性所指向的redisCommand结构，以及argv，argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令</p>
<p>下图演示了服务器在argv[0]为set时，查找命令表并将客户端状态的cmd指针指向目标redisCommand结构的整个过程</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/112.png"  alt="img"></p>
<h3 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h3><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的</p>
<ul>
<li>固定大小的缓冲区用于保存那些长度比较小的回复，比如ok,简短的字符串值，整数值，错误回复等等</li>
<li>可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合</li>
</ul>
<p>客户端的固定大小缓冲区由buf和bufpos两个属性组成</p>
<p>buf是一个大小为REDIS_REPLY_CHUNK_BYTES字节的字节数组，而bufpos属性则记录了buf数组目前已经使用的字节数量，REDIS_REPLY_CHUNK_BYTES常量目前的默认值为16*1024，也就是说，buf数组的默认大小为16KB</p>
<p>下图展示了一个使用固定大小缓冲区来保存返回值的例子</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/113.png"  alt="img"></p>
<p>通过使用链表来连接多个字符串对象，服务器可以为客户端保存一个非常长的命令回复，而不必受到固定大小缓冲区16KB大小的限制</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/114.png"  alt="img"></p>
<h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>客户端状态的authenticated属性用于记录客户端是否通过身份验证，如果authenticated的值为0，那么表示客户端未通过身份验证，如果值为1，那么表示客户端已经通过了身份验证</p>
<p>authenticated属性仅在服务器启用了身份验证功能时使用，如果服务器没有启用身份验证功能的话，即便authenticated值为0，服务器也不会拒绝执行客户端发送的命令请求</p>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>ctime属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒，client list命令的age域记录了这个秒数</p>
<p>lastinteraction记录了客户端与服务器最后一次进行互动的时间，这里的互动可以是客户端向服务器发送命令请求，也可以是服务器向客户端发送命令回复，可以用来计算客户端的空转时间</p>
<p>obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制的时间</p>
<h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><h3 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h3><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/115.png"  alt="img"></p>
<h3 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h3><p>一个普通客户端可以因为多种原因而被关闭</p>
<ol>
<li>如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭</li>
<li>如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会被服务器关闭</li>
<li>如果客户端称为client kill命令的目标，那么它也会被关闭</li>
<li>如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过timeout选项设置的值时，客户端将被关闭</li>
<li>如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小1GB，那么客户端会被服务器关闭</li>
<li>如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭</li>
</ol>
<p>可变大小缓冲区由一个链表和任意多个字符串对象组成，理论上来说，这个缓冲区可以保存任意长的命令回复，但是为了避免客户端的回复过大，占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作</p>
<p>服务器使用两种模式来限制客户端输出缓冲区的大小</p>
<ol>
<li>硬性限制：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端</li>
<li>软性限制：如果输出缓冲区的大小超过了软性限制所设置的大小 ，但还没有超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间，之后服务器会接着监视客户端，如果输出缓冲区的大小一直超过软性限制，并且持续时间超过服务器设定的时长，那么服务器会关闭客户端；相反地，如果输出缓冲区的大小在指定时间之内，不再超出软性限制，那么客户端就不会被关闭，并且obuf_soft_limit_reached_time属性的值也会被清零</li>
</ol>
<p>使用client-output-buffer-limit选项可以为普通客户端，从服务器客户端，执行发布与订阅功能的客户端分别设置不同的软性限制和硬性限制，该选项的格式如下</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/116.png"  alt="img"></p>
<p>以下是三个设置示例</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/117.png"  alt="img"></p>
<p>第一行设置将普通客户端的硬性限制和软性限制都设置为0，表示不限制客户端的输出缓冲区大小</p>
<p>第二行设置将从服务器客户端的硬性限制设置为256MB,而软性限制设置为64MB，软性限制的时长为60s</p>
<p>第三行设置将执行发布与订阅功能的客户端的硬性限制设置为32MB，软性限制设置为8MB，软性限制的时长为60s</p>
<h3 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h3><p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中</p>
<p>lua_client伪客户端在服务器运行的整个声明周期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭</p>
<h3 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h3><p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端</p>
<h2 id="重点回顾-9"><a href="#重点回顾-9" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾</p>
<p>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态</p>
<p>输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB</p>
<p>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数</p>
<p>客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16kb,而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值</p>
<p>输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭，除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭</p>
<p>当一个客户端通过网络连接上服务器时，服务器会为这个客户端创建相应的客户端状态，网络连接关闭，发送了不合协议格式的命令请求，称为client kill命令的目标，空转时间超时，输出缓冲区的大小超过限制，以上原因都会造成客户端被关闭</p>
<p>处理Lus脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，追到服务器关闭</p>
<p>载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转</p>
<h3 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h3><p>一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作，如果我们使用客户端执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;set key value</span><br></pre></td></tr></table></figure>

<p>那么从客户端发送set key value命令到获得回复ok期间，客户端和服务器共需要执行以下操作</p>
<p>1.客户端向服务器发送命令请求set key value</p>
<p>2.服务器接受并处理客户端发送来的命令请求set key value,在数据库中进行设置操作，并产生命令回复ok</p>
<p>3.服务器将命令回复ok发送给客户端</p>
<p>4.客户端接受服务器返回的命令会ok，并将这个回复打印给用户看</p>
<h4 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h4><p>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/118.png"  alt="img"></p>
<p>假设在客户端键入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure>

<p>那么客户端会将这个命令转换成协议，然后将这段协议内容发送给服务器</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/119.png"  alt="img"></p>
<h4 id="读取命令请求"><a href="#读取命令请求" class="headerlink" title="读取命令请求"></a>读取命令请求</h4><p>当客户端与服务器直接啊你的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作</p>
<p>1.读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面</p>
<p>2.对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面</p>
<p>3.调用命令执行器，执行客户端指定的命令</p>
<p>下图展示了程序将命令请求保存到客户端状态的输入缓冲区之后，客户端状态的样子</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/120.png"  alt="img"></p>
<p>之后，分析程序将对输入缓冲区中的协议进行分析，并将得出的分析结果保存到客户端状态的argv属性和argc属性里面</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/121.png"  alt="img"></p>
<p>之后，服务器将通过命令执行器来完成执行命令所需的余下步骤</p>
<h4 id="命令执行器1：查找命令实现"><a href="#命令执行器1：查找命令实现" class="headerlink" title="命令执行器1：查找命令实现"></a>命令执行器1：查找命令实现</h4><p>命令执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面</p>
<p>命令表是一个字典，字典的键是一个个个命令名字；字典的值则是一个个redisCommand结构，每个redisCommand结构记录了一个redis命令的实现信息，下表记录了这个结构的各个主要属性的类型和作用</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/122.png"  alt="img"></p>
<p>下图列出了sflags属性可以使用的标识值，以及这些标识的意义</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/123.png"  alt="img"></p>
<p>下图展示了命令表的样子，并且以set命令和get命令作为列子，展示了redisCommand结构</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/124.png"  alt="img"></p>
<ul>
<li><p>set命令的名字为set，实现函数为setCommand，命令的参数个数为-3，表示命令接受三个或以上数量的参数，命令的标识为wm,表示set命令是一个写入命令，并且在执行这个命令之前，服务器应该对占用内存状况进行检查，因为这个命令可能会占用大量的内存</p>
</li>
<li><p>get命令的名字为get,实现函数是getCommand函数，命令的参数个数为2，表示命令只接受两个参数，命令的标识为r,表示这是一个只读命令</p>
</li>
</ul>
<p>命令名字的大小写不影响命令表的查找结果，因为命令表使用的是大小写无关的查找算法，所以只要命令的名字是正确的，无论大小写都能找到相应的redisCommand结构</p>
<h4 id="命令执行器2：执行预备操作"><a href="#命令执行器2：执行预备操作" class="headerlink" title="命令执行器2：执行预备操作"></a>命令执行器2：执行预备操作</h4><p>到目前为止，服务器已经将执行命令所需的命令实现函数都收集齐了，但在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确顺利地被执行，这些命令包括：</p>
<ol>
<li>检查客户端状态的cmd指针是否指向NULL，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误</li>
<li>根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接返回一个错误</li>
<li>检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误</li>
<li>如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺序执行，如果内存回收失败，那么不再执行后续步骤，并向客户端返回一个错误</li>
<li>如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop_writes_on_bgsave_error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并且向客户端返回一个错误</li>
<li>如果客户端当前正在用subscribe命令订阅频道，或者正在使用psubscribe命令订阅模式，那么服务器只会执行客户端发来的subscribe，psubscribe,unsubscribe，punsubscribe四个命令，其他的命令都会被服务器拒绝</li>
<li>如果服务器正在进行数据载入，那么客户端发送的命令必须带有1表示(比如INFO,SHUTDOWN,PUBLISH等)才会被服务器执行，其他命令都会被服务器拒绝</li>
<li>如果服务器因为执行Lua脚本而超时并进行阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和script kill命令，其他命令都会被服务器拒绝</li>
<li>如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC,discard,multi,WATCH四个命令，其他命令都会被放进事务队列中</li>
<li>如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器，当完成以上预备操作之后，服务器就可以开始真正执行命令了</li>
</ol>
<p>以上只是列出了服务器在单机模式下执行命令时的检查操作，当服务器在复制或者集群模式下执行命令时，预备操作还会多一些</p>
<h4 id="命令执行器3：调用命令的实现函数"><a href="#命令执行器3：调用命令的实现函数" class="headerlink" title="命令执行器3：调用命令的实现函数"></a>命令执行器3：调用命令的实现函数</h4><p>在前面的操作中，服务器已经将要执行命令的实现保存到了客户端状态的cmd属性里面，并将命令的参数和参数个数分别保存到了客户端状态的argv,argc属性里面，当服务器决定要执行命令时，它只要执行以下语句就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;client是指向客户端状态的指针</span><br><span class="line">client-&gt;cmd-&gt;proc(client);</span><br></pre></td></tr></table></figure>

<p>命令的实现函数只需要一个指向客户端状态的指针作为参数即可，即执行setCommand(client);</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/125.png"  alt="img"></p>
<p>被调用的命令实现函数会执行指定的操作，并产生相应的命令回复，这些回复会被保存在客户端状态的输出缓冲区里面，之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回客户端，回复会被保存到客户端状态的buf属性里面</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/126.png"  alt="img"></p>
<h4 id="命令执行器4：执行后续工作"><a href="#命令执行器4：执行后续工作" class="headerlink" title="命令执行器4：执行后续工作"></a>命令执行器4：执行后续工作</h4><p>在执行完实现函数之后，服务器还需要执行一些后续工作</p>
<ul>
<li><p>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行的命令请求添加一条新的慢查询日志</p>
</li>
<li><p>根据刚刚执行命令所消耗的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增1</p>
</li>
<li><p>如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面</p>
</li>
<li><p>如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器</p>
</li>
</ul>
<p>服务器对于当前命令的执行到此就告一段落了，之后服务器就可以接着从文件事件处理器中去除并处理下一条命令请求了</p>
<h4 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h4><p>命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端</p>
<p>当命令回复发送完毕之后，回复处理器会清空客户端状态和输出缓冲区，为处理下一个命令请求做好准备</p>
<h4 id="客户端接受并打印命令回复"><a href="#客户端接受并打印命令回复" class="headerlink" title="客户端接受并打印命令回复"></a>客户端接受并打印命令回复</h4><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户看</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/127.png"  alt="img"></p>
<p>以上就是Redis客户端和服务器执行命令请求的整个过程了</p>
<h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><p>Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转</p>
<h4 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h4><p>Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存</p>
<p>因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高</p>
<ol>
<li>服务器只会在打印日志，更新服务器的LRU时钟，决定是否执行持久化任务，计算服务器上线时间这类对时间精度要求不高的功能上</li>
<li>对于为键设置过期时间，添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最精确的系统当前时间</li>
</ol>
<h4 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h4><p>服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性，mstime属性一样，都是服务器时间缓存的一种</p>
<p>每个Redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间</p>
<p>当服务器要计算一个数据库键的空转时间，程序会用服务器的lruclock属性记录的时间减去对象的lru属性记录的时间，得出的计算结果就是这个对象的空转时间</p>
<p>serverCron函数默认会以每10秒一次的频率更新lruclock属性的值，因为这个时钟不是实时的，所以根据这个属性计算出来的LRU时间实际上只是一个模糊的估算值</p>
<p>lruclock时钟的当前值可以通过INFO server命令的lru_clock域查看</p>
<h4 id="处理sigterm信号"><a href="#处理sigterm信号" class="headerlink" title="处理sigterm信号"></a>处理sigterm信号</h4><p>在启动服务器时，Redis会为服务器进程的sigterm信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接收sigterm信号时，打开服务器状态shutdown_asap标识</p>
<p>每次serverCron函数运行时，程序都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器</p>
<h4 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h4><p>serverCron函数每次执行都会调用clientsCron函数，clientsCron函数会对一定数量的客户端进行以下两个检查</p>
<p>如果客户端与服务器之间的连接已经超时，那么程序释放这个客户端</p>
<p>如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费过多的内存</p>
<h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>一个Redis服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等</p>
<h4 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h4><p>初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值，由redis.c/initServerConfig函数完成</p>
<ul>
<li>设置服务器的运行ID</li>
<li>设置服务器的默认运行频率</li>
<li>设置服务器的默认配置文件路径</li>
<li>设置服务器的默认端口</li>
<li>设置服务器的默认RDB持久化条件和AOF持久化条件</li>
<li>初始化服务器的LRU时钟</li>
<li>创建命令表</li>
</ul>
<p>initServerConfig函数设置的服务器状态属性基本都是一些整数，浮点数，或者字符串属性，除了命令表之外，initServerConfig函数没有创建服务器状态的其他数据结构，数据库，慢查询日志，Lua环境，共享对象这些数据结构在之后的步骤才会被创建出来</p>
<h4 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h4><p>在启动服务器时，用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置</p>
<p>如果在终端中输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server --port 10086</span><br></pre></td></tr></table></figure>

<h3 id="重点回顾-10"><a href="#重点回顾-10" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>一个命令请求从发送到完成主要包含以下步骤</p>
<ol>
<li>客户端将命令请求发送给服务器</li>
<li>服务器读取命令请求，并分析出命令参数</li>
<li>命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复</li>
<li>服务器将命令回复返回给客户端</li>
</ol>
<p>serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接受的sigterm信号，管理客户端资源和数据库状态，检查并执行持久化操作等</p>
<p>服务器从启动到能处理客户端名请求需要执行以下步骤</p>
<ol>
<li>初始化服务器状态</li>
<li>载入服务器配置</li>
<li>初始化服务器数据结构</li>
<li>还原数据库状态</li>
<li>执行事件循环</li>
</ol>
<h1 id="复制-1"><a href="#复制-1" class="headerlink" title="复制"></a>复制</h1><p>在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，我们称呼被复制的服务器为主服务器，而对主服务器进行复制的服务器则被称为从服务器</p>
<h2 id="旧版复制功能的实现"><a href="#旧版复制功能的实现" class="headerlink" title="旧版复制功能的实现"></a>旧版复制功能的实现</h2><p>Redis的复制功能分为同步和命令传播两个操作</p>
<ol>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态</li>
<li>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从给服务器的数据库重新回到一致状态</li>
</ol>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，将从服务器的数据库状态更新至主服务器当前所处的数据库状态</p>
<p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤</p>
<p>1.从服务器向主服务器发生SYNC命令</p>
<p>2.收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令</p>
<p>3.当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据状态更新至主服务器执行BGSAVE命令时的数据库状态</p>
<p>4.主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/128.png"  alt="img"></p>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不会一尘不变，每当服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致</p>
<p>为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作，主服务器会将自己执行的写命令发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器再次回到一致状态</p>
<h2 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h2><p>在Redis中，从服务器对主服务器的复制可以分为以下两种情况</p>
<ul>
<li><p>初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同</p>
</li>
<li><p>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接上了主服务器，并接着复制主服务器</p>
</li>
</ul>
<p>对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/129.png"  alt="img"></p>
<p>在时间T0091,从服务器终于重新连接上主服务器，因为这时主从服务器的状态已经不再一致，所以从服务器将向主服务器发送SYNC命令，而主服务器会将包含键k1至键k10089的RDB文件发送给从服务器，从服务器通过接收和载入这个RDB文件来将自己的数据库更新至主服务器数据库当前所处的状态</p>
<p>虽然再次发送SYNC命令可以让主从服务器重新回到一致状态，但如果我们仔细研究这个断线重复制过程，就会发现传送RDB文件这一步实际上并不是非做不可的</p>
<p>SYNC命令是一个非常耗费资源的操作，所以Redis有必要保证在真正有需要时才执行SYNC命令</p>
<h2 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h2><p>为了解决旧版本复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作</p>
<p>PSYNC命令具有完整重同步和部分重同步两种模式</p>
<ul>
<li><p>完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步</p>
</li>
<li><p>部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时。如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接受并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态</p>
</li>
</ul>
<p>下图是使用PSYNC命令来执行断线后重复制</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/130.png"  alt="img"></p>
<p>PSYNC少了SYNC命令需要生成，传送和载入整个RDB文件的过程，部分重同步只需要将从服务器缺少的写命令发送给从服务器执行就可以了</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/131.png"  alt="img"></p>
<h2 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h2><p>部分重同步功能由以下三个部分构成</p>
<ol>
<li>主服务器的复制偏移量和从服务器的复制偏移量</li>
<li>主服务器的复制积压缓冲区</li>
<li>服务器的运行ID</li>
</ol>
<h3 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h3><p>执行复制的双方，即主从服务器会分别维护一个复制偏移量</p>
<ol>
<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li>
<li>从服务器每次接收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li>
</ol>
<p>通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态</p>
<h3 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h3><p>复制积压缓冲区是由主服务器维护的一个固定长度先进先出队列，默认大小1MB</p>
<p>固定长度先进先出队列的入队和出队规则跟普通的先进先出队列一样，新元素从一边进入队列，而旧元素从另一边弹出队列</p>
<p>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/132.png"  alt="img"></p>
<p>因此主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量</p>
<p>当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作</p>
<ol>
<li>如果offset偏移量之后的数据(offset+1开始的数据)仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作</li>
<li>如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作</li>
</ol>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/133.png"  alt="img"></p>
<h3 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h3><p>除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID</p>
<ul>
<li>每个Redis服务器，无论主服务器还是从服务器，都会有自己的运行ID</li>
<li>运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成</li>
<li>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来</li>
<li>当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID</li>
<li>如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以接着尝试执行部分重同步操作</li>
<li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作</li>
</ul>
<h2 id="PSYNC命令的实现"><a href="#PSYNC命令的实现" class="headerlink" title="PSYNC命令的实现"></a>PSYNC命令的实现</h2><p>PSYNC命令的调用方法有两种</p>
<p>如果从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC？-1命令，主动请求主服务器进行完整重同步</p>
<p>如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC runid offset命令，其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行那种同步操作</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/134.png"  alt="img"></p>
<h2 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h2><p>通过向从服务器发送SLAVEOF命令，可以让一个从服务器去复制一个主服务器</p>
<h3 id="步骤一：设置主服务器的地址和端口"><a href="#步骤一：设置主服务器的地址和端口" class="headerlink" title="步骤一：设置主服务器的地址和端口"></a>步骤一：设置主服务器的地址和端口</h3><p>当客户端从服务器发送以下命令时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：12345&gt;slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口号6379保存到服务器状态的masterhost属性和masterport属性里面</p>
<p>slaveof命令是一个异步命令，在完成masterhost属性和masterport属性的设置工作之后，从服务器将向发送slaveof命令的客户端返回ok,表示复制指令已经被接受，而实际的复制工作将在ok返回之后才真正开始执行</p>
<h3 id="步骤二：建立套接字连接"><a href="#步骤二：建立套接字连接" class="headerlink" title="步骤二：建立套接字连接"></a>步骤二：建立套接字连接</h3><p>slaveof命令执行之后，从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接</p>
<p>如果从服务器创建的套接字能成功连接到主服务器，那么从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令</p>
<p>主服务器在接受从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，这时从服务器将同时具有服务器和客户端两个身份，从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复</p>
<p>复制工作接下来的几个步骤都会以从服务器向主服务器发送命令请求的形式来进行，从服务器是主服务器的客户端</p>
<h3 id="步骤三：发送PING命令"><a href="#步骤三：发送PING命令" class="headerlink" title="步骤三：发送PING命令"></a>步骤三：发送PING命令</h3><p>从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送一个PING命令，这个PING命令有两个做用</p>
<ol>
<li>虽然主从服务器成功建立起了套接字连接，但双方并为使用该套接字进行过任何通信，通过发送PING命令可以检查套接字的读写状态是否正常</li>
<li>因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以检查主服务器能否正常处理命令请求</li>
</ol>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/135.png"  alt="img"></p>
<h3 id="步骤四：身份验证"><a href="#步骤四：身份验证" class="headerlink" title="步骤四：身份验证"></a>步骤四：身份验证</h3><p>如果从服务器设置了masterauth选项，那么进行身份验证。如果没有设置masterauth选项，那么不进行身份验证</p>
<p>在需要进行身份验证的情况下，从服务器将向主服务器发送一条AUTH命令，命令的参数为从服务器masterauth的值</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/136.png"  alt="img"></p>
<h3 id="步骤五：发送端口信息"><a href="#步骤五：发送端口信息" class="headerlink" title="步骤五：发送端口信息"></a>步骤五：发送端口信息</h3><p>在身份验证步骤之后，从服务器将执行replconf listening-port port-number,向主服务器发送从服务器的监听端口号</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/137.png"  alt="img"></p>
<p>主服务器在接受到这个命令之后，会将端口号记录在从服务器所对应的客户端状态的slave_listening_port属性中，该属性目前唯一的作用就是在主服务器执行INFO replication命令时打印出从服务器的端口号</p>
<h3 id="步骤六：同步"><a href="#步骤六：同步" class="headerlink" title="步骤六：同步"></a>步骤六：同步</h3><p>从服务器向主服务器发送PSYNC命令，执行同步操作，并将自己的数据库更新至主数据库当前所处的状态</p>
<p>在同步操作执行之前，只有从服务器是主服务器的客户端，但是在执行同步操作之后，主服务器也会成为从服务器的客户端</p>
<ul>
<li>如果PSYNC命令执行的是完整重同步操作，那么主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行</li>
<li>如果PSYNC命令执行的是部分重同步操作，那么主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令</li>
</ul>
<p>因此，在同步操作执行之后，主从服务器双方都是对方的客户端，它们可以相互向对方发送命令请求，或者互相向对方返回命令回复</p>
<p>正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命令传播操作的基础</p>
<h3 id="步骤七：命令传播"><a href="#步骤七：命令传播" class="headerlink" title="步骤七：命令传播"></a>步骤七：命令传播</h3><p>完成同步操作之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接受并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了</p>
<h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replconf ack &lt;replication_offset&gt;</span><br></pre></td></tr></table></figure>

<p>其中replication_offset是从服务器当前的复制偏移量</p>
<p>发送replconf ack命令对于主从服务器有三个作用</p>
<ol>
<li>检测主从服务器的网络连接状态</li>
<li>辅助实现min-slaves选项</li>
<li>检测命令丢失</li>
</ol>
<h3 id="检测主从服务器的网络连接状态"><a href="#检测主从服务器的网络连接状态" class="headerlink" title="检测主从服务器的网络连接状态"></a>检测主从服务器的网络连接状态</h3><h3 id="辅助实现min-slaves配置选项"><a href="#辅助实现min-slaves配置选项" class="headerlink" title="辅助实现min-slaves配置选项"></a>辅助实现min-slaves配置选项</h3><p>Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令</p>
<p>举个列子，如果我们向服务器提供以下设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-wrtie 3</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<p>那么在从服务器的数量少于三个，或者三个从服务器的延迟lag值都大于或等于10秒时，主服务器将拒绝执行写命令，这里的延迟值就是上面提到的INFO replication命令的lag值</p>
<h3 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h3><p>如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送replconf ack命令时，主服务器将发觉从服务器当前的复制便宜量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器</p>
<h2 id="重点回顾-11"><a href="#重点回顾-11" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>Redis2.8以前的复制功能不能高效地处理断线后重复值情况，但Redis2.8新添加的部分重同步功能可以解决这个问题</p>
<p>部分重同步通过复制偏移量，复制积压缓冲区，服务器运行ID三个部分来实现</p>
<p>在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器就会互相成为对方的客户端</p>
<p>主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器发发送命令来进行心跳检测，以及命令丢失检测</p>
<h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p>sentinel哨兵是redis的高可用解决方案，有一个或者多个sentinel实例组成的sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器接着处理命令请求</p>
<p>服务器于sentinel系统</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/138.png"  alt="img"></p>
<p>主服务器下线</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/139.png"  alt="img"></p>
<p>故障转移</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/140.png"  alt="img"></p>
<p>原来的主服务器被降级为从服务器</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/141.png"  alt="img"></p>
<h2 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h2><p>启动一个sentinel可以使用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-sentinel &#x2F;path&#x2F;to&#x2F;you&#x2F;sentinel.cof</span><br></pre></td></tr></table></figure>

<p>或者,两个命令的效果完全相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server &#x2F;path&#x2F;to&#x2F;you&#x2F;sentinel.cof --sentinel</span><br></pre></td></tr></table></figure>

<p>当一个Sentinel启动时，它需要执行以下步骤：</p>
<ol>
<li>初始化服务器</li>
<li>将普通redis服务器使用的代码替换成sentinel专用代码</li>
<li>初始化sentinel状态</li>
<li>根据给定的配置文件，初始化sentinel的监视主服务器列表</li>
<li>创建连向主服务器的网络连接</li>
</ol>
<h3 id="初始化服务器-1"><a href="#初始化服务器-1" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>因为sentinel本质上只是一个运行在特殊模式下的redis服务器，所以启动sentinel的第一步，就是初始化一个普通的redis服务器</p>
<p>因为sentinel执行的工作和普通redis服务器执行的工作不同，所以sentinel的初始化过程和普通redis服务器的初始化过程并不完全相同</p>
<p>普通服务器在初始化时会通过载入RDB文件或者AOF文件来还原数据库状态，但是因为Sentinel并不使用数据库，所以初始化sentinel时就不会载入RDB文件或者AOF文件</p>
<p>Sentinel模式下Redis服务器主要功能的使用情况</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/142.png"  alt="img"></p>
<h3 id="使用Sentinel专用代码"><a href="#使用Sentinel专用代码" class="headerlink" title="使用Sentinel专用代码"></a>使用Sentinel专用代码</h3><p>启动sentinel的第二个步骤就是将一部分普通Redis服务器使用的代码替换成sentinel专用代码，比如说，普通Redis服务器使用redis.h/REDIS_SERVERPORT常量的值作为服务器端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define REDIS_SERVERPORT 6379</span><br></pre></td></tr></table></figure>

<p>而Sentinel则使用sentinel.c/REDIS_SENTINEL_PORT常量的值作为服务器端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define REDIS_SENTINEL_PORT 26379</span><br></pre></td></tr></table></figure>

<h3 id="初始化Sentinel状态"><a href="#初始化Sentinel状态" class="headerlink" title="初始化Sentinel状态"></a>初始化Sentinel状态</h3><p>在应用了sentinel的专用代码之后，接下来，服务器会初始化一个sentinel.c/sentinelState结构，这个结构保存了服务器中所有和Sentinel功能有关的状态</p>
<h3 id="初始化Sentinel状态的masters属性"><a href="#初始化Sentinel状态的masters属性" class="headerlink" title="初始化Sentinel状态的masters属性"></a>初始化Sentinel状态的masters属性</h3><p>sentinel状态中的masters字典记录了所有被sentinel监视的主服务器的相关信息</p>
<ul>
<li><p>字典的键是被监视主服务器的名字</p>
</li>
<li><p>而字典的值则是被监视主服务器对应的sentinel.c/sentinelRedisInstance结构</p>
</li>
</ul>
<p>每个sentinelRedisInstance结构代表一个被Sentinel监视的Redis服务器实例，这个实例可以是主服务器，从服务器，或者另外一个Sentinel</p>
<h3 id="创建连向主服务器的网络连接"><a href="#创建连向主服务器的网络连接" class="headerlink" title="创建连向主服务器的网络连接"></a>创建连向主服务器的网络连接</h3><p>初始化sentinel最后一步是创建连向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息</p>
<p>对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接</p>
<ul>
<li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接受命令回复</li>
<li>另一个是订阅连接，这个连接专门用于订阅主服务器<em>_sentinel</em>:hello频道</li>
</ul>
<p>为什么又两个连接？</p>
<p>在Redis目前的发布与订阅功能中，被发送的信息都不会保存在Redis服务器里面，如果在信息发送时，想要接受信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息，因此，为了不丢失<em>_sentinel</em>:hello频道的任何信息，Sentinel必须专门用一个订阅连接来接收该频道的信息</p>
<p>除了订阅频道之外，sentinel还必须向主服务器发送命令，以此来与主服务器进行通讯，所以Sentinel还必须向主服务器创建命令连接</p>
<p>因为Sentinel需要与多个实例创建多个网络连接，所以Sentinel使用的是异步连接</p>
<p>下图展示了一个Sentinel向被它监视的两个主服务器master1和master2创建命令连接和订阅连接</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/143.png"  alt="img"></p>
<h2 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h2><p>Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/144.png"  alt="img"></p>
<p>通过分析主服务器返回的INFO命令回复，Sentinel可以获取以下两方面的信息</p>
<ul>
<li><p>一方面是关于主服务器本身的信息，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色</p>
</li>
<li><p>另一方面是关于主服务器属下所有从服务器的信息，每个从服务器都由一个slave字符串开头的行记录，每行的ip=域记录了从服务器的IP地址，而port=域则记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无需用户提供从服务器的地址信息，就可以自动发现从服务器</p>
</li>
<li><p>根据run_id域和role域记录的信息，Sentinel将对主服务器的实例结构进行更新，例如主服务器重启之后，它的运行ID就会和实例结构之气保存的运行ID不同，Sentinel检测到这一情况之后，就会对实例结构的运行ID进行更新</p>
</li>
</ul>
<p>主服务器返回的从服务器信息，则会用于更新主服务器实例结构的slaves字典，这个字典记录了主服务器属下从服务器的名单</p>
<ul>
<li>字典的键是由Sentinel自动设置的从服务器名字，格式为ip:port，例如127.0.0.1：11111</li>
<li>字典的值则是服务器对于的实例结构</li>
</ul>
<p>Sentinel在分析INFO命令中共包含的从服务器信息时，会检查从服务器对应的实例结构是否存在于slaves字典</p>
<ul>
<li><p>如果从服务器对应的实例结构已经存在，那么sentinel对从服务器的实例结构进行更新</p>
</li>
<li><p>如果从服务器对应的实例结构不存在，那么说明这个从服务器是新发现的从服务器，sentinel会在slaves字典中为这个从服务器创建一个实例结构</p>
</li>
</ul>
<p>为主从服务器创建实例结构</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/145.png"  alt="img"></p>
<p>主服务器实例结构和从服务器实例结构之间的区别：</p>
<ul>
<li>主服务器实例结构的flags属性的值为SRI_MASTER,而从服务器实例结构的flags属性的值为SRI_SLAVE</li>
<li>主服务器实例结构的name属性的值是用户sentinel配置文件设置的，而从服务器实例结构的name属性的值则是sentinel根据从服务器的IP地址和端口号自动设置的</li>
</ul>
<h2 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h2><p>当Sentinel发现主服务器由新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/146.png"  alt="img"></p>
<p>在创建命令连接之后，Sentinel在默认情况下，会以每十秒一次的频率通过命令连接向从服务器发送INFO命令，并获得类似于以下内容的回复</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/147.png"  alt="img"></p>
<p>根据INFO命令的回复，Sentinel会提取出以下信息</p>
<ul>
<li>从服务器的运行IDrun_id</li>
<li>从服务器的角色role</li>
<li>主服务器的IP地址master_host，以及主服务器的端口号master_port</li>
<li>主从服务器的连接状态master_link_status</li>
<li>从服务器的优先级slave_priority</li>
<li>从服务器的复制偏移量slave_repl_offset</li>
</ul>
<p>根据这些信息，Sentinel会对从服务器的实例结构进行更新，更新之后实例结构如下</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/148.png"  alt="img"></p>
<h2 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="headerlink" title="向主服务器和从服务器发送信息"></a>向主服务器和从服务器发送信息</h2><p>默认情况下，Sentinel会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/149.png"  alt="img"></p>
<p>该条命令向服务器<em>sentinel_</em>:hello频道发送了一条信息，信息的内容由多个参数组成</p>
<ul>
<li>以s_开头的参数记录的是Sentinel本身的信息，各个参数的意义如下表</li>
<li>而m_开头的参数记录的则是主服务器的信息。如果sentinel正在监视的是主服务器，那么这些参数记录的就是主服务器的信息；如果Sentinel正在监视的是从服务器，那么这些参数记录的就是从服务器正在复制的主服务器的信息</li>
</ul>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/150.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/151.png"  alt="img"></p>
<p>以下是一条Sentinel通过publish命令向主服务器发送的信息示例</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/152.png"  alt="img"></p>
<ul>
<li>Sentinel的IP地址为127.0.0.1端口号为26379，运行ID为e955b……，当前的配置纪元为0</li>
<li>主服务器的名字为mymaster,IP地址为127.0.0.1，端口号为6379，当前的配置纪元为0</li>
</ul>
<h2 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h2><p>当Sentinel与一个主服务器或者从服务器建立起订阅连接之后，Sentinel就会通过订阅连接，向服务器发送以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe _sentinel_:hello</span><br></pre></td></tr></table></figure>

<p>sentinel对<em>sentinel_</em>:hello频道的订阅会一直持续到sentinel与服务器的连接断开为止，对每个与Sentinel连接的服务器，Sentinel既通过命令连接向服务器的<em>sentinel_</em>:hello频道发送信息，又通过订阅连接从服务器的该频道接收信息，Sentinel同时向服务器发送和接收信息</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/153.png"  alt="img"></p>
<p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于更新其他sentinel对被监视服务器的认知</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/154.png"  alt="img"></p>
<ul>
<li>如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID相同，那么说明这条信息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理</li>
<li>如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID不相同，那么说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，对相应主服务器的示例结构进行更新</li>
</ul>
<h3 id="更新sentinels字典"><a href="#更新sentinels字典" class="headerlink" title="更新sentinels字典"></a>更新sentinels字典</h3><p>sentinel为主服务器创建的示例结构中的sentinels字典保存了除Sentinel本身之外，所有同样监视这个服务器的其他sentinel的资料</p>
<ul>
<li>sentinels字典的键是其中过一个sentinel的名字，格式为IP:PORT</li>
<li>setinels字典的值则是键所对应的sentinel的实例结构</li>
</ul>
<p>当一个sentinel接收到其他sentinel发来的信息时，目标sentinel会从信息中分析并提取出以下两方面的参数</p>
<ul>
<li><p>与sentinel有关的参数：源sentinel的IP地址，端口号，运行ID和配置纪元</p>
</li>
<li><p>与主服务器有关的参数：源sentinel正在监视的主服务器的名字，IP地址，端口号和配置纪元</p>
</li>
</ul>
<p>根据信息中提取出的主服务器参数，目标sentinel会在自己的sentinel状态的masters字典中查找相应的主服务器实例结构，然后根据提取出的sentinel参数，检查主服务器实例结构的sentinels字典中，源sentinel的实例结构是否存在</p>
<ul>
<li><p>如果源sentinel的实例结构已经存在，那么对源sentinel的实例结构进行更新</p>
</li>
<li><p>如果源sentinel的实例结构不存在，那么说明源sentinel是刚刚开始监视主服务器的新sentinel，目标sentinel会为源sentinel创建一个新的实例结构，并将这个结构添加到sentinels字典里面</p>
</li>
</ul>
<p>假设分别有127.0.0.1：26379，127.0.0.1：26380，127.0.0.1：26381三个sentinel正在监视主服务器127.0.0.1：6379，那么当127.0.0.1：26379这个sentinel接收到以下信息时：</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/155.png"  alt="img"></p>
<p>sentinel将执行以下动作：</p>
<ul>
<li><p>第一条信息的发送者为127.0.0.1：26379自己，这条信息会被忽略</p>
</li>
<li><p>第二条信息的发生者为127.0.0.1：26381，sentinel会根据这条信息中提取出的内容，对sentinels字典中127.0.0.1：26381对应的实例结构进行更新</p>
</li>
<li><p>第三条信息的发送者为127.0.0.1：26380，sentinel会根据这条信息中提取出的内容，对sentinels字典中127.0.0.1：26380所对应的实例结构进行更新</p>
</li>
</ul>
<p>下图展示了sentinel 127.0.0.1：26379为主服务器127.0.0.1：6379创建的实例结构，以及结构中sentinels字典</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/156.png"  alt="img"></p>
<p>和127.0.0.1：26379一样，其他两个sentinel也会创建上图所示的sentinels字典，区别在于字典中保存的sentinel信息不同，保存的是除自己以外其他的sentinel的信息</p>
<p>因为一个sentinel可以通过分析接收到的频道信息来获知其他sentinel的存在，并通过发送频道信息来让其他sentinel知道自己的存在，所以用户在使用sentinel的时候并不需要提供各个sentinel的地址信息，监视同一个主服务器的多个sentinel可以自动发现对方</p>
<h2 id="创建连向其他sentinel的命令连接"><a href="#创建连向其他sentinel的命令连接" class="headerlink" title="创建连向其他sentinel的命令连接"></a>创建连向其他sentinel的命令连接</h2><p>当sentinel通过频道信息发现一个新的sentinel时，它不仅会为新sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新sentinel的命令连接，而新sentinel也同样会创建连向这个sentinel的命令连接，最终监视同一主服务器的多个sentinel将形成相互连接的网络</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/157.png"  alt="img"></p>
<p>sentinel之间不会创建订阅连接</p>
<p>sentinel在连接主服务器或者从服务器时，会同时创建命令连接和订阅连接，但是在连接其他sentinel时，却只会创建命令连接，而不创建订阅连接，这是因为sentinel需要通过接收主服务器或者从服务器发来的频道信息来发信未知的新sentinel，所以才需要建立订阅连接，而相互已知的sentinel只要使用命令连接来进行通讯就足够了</p>
<h2 id="检查主观下线状态"><a href="#检查主观下线状态" class="headerlink" title="检查主观下线状态"></a>检查主观下线状态</h2><p>默认情况下，sentinel会以每秒一次的频率向所有创建了命令连接的实例(包括主服务器，从服务器，其他sentinel在内)发送PING命令，并通过实例返回的PING命令回复来判断实例是否在在线</p>
<p>下图带箭头的连线显示了sentinel1和sentinel2是如何向实例发送PING命令的</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/158.png"  alt="img"></p>
<p>实例对PING命令的回复可以分为以下两种情况</p>
<ul>
<li><p>有效回复：实例返回+PONG,-LOADING,-MASTERDOWN三种回复的其中一种</p>
</li>
<li><p>无效回复：有效回复以外的回复或者在指定时间限制内没有返回任何回复</p>
</li>
</ul>
<p>sentinel配置文件中的down-after-milliseconds选项指定了sentinel判断实例进入主观下线所需的时间长度，如果一个实例在down-after-milliseconds毫秒内，连续向sentinel返回无效回复，那么sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN标识，以此来表示这个实例已经进入主观下线状态</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/159.png"  alt="img"></p>
<h3 id="主观下线时长选项的作用范围"><a href="#主观下线时长选项的作用范围" class="headerlink" title="主观下线时长选项的作用范围"></a>主观下线时长选项的作用范围</h3><p>用户设置的down-after-milliseconds选项的值，不仅会被sentinel用来判断主服务器的主观下线状态，还会被用于判断主服务器属下的所有从服务器，以及所用同时监视这个服务器的其他sentinel的主观下线状态。如果用户向sentinel设置了以下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor master 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds master 50000</span><br></pre></td></tr></table></figure>

<p>那么50000毫秒不仅会成为sentinel判断master进入主观下线状态的标准，还会成为sentinel判断master属下所有从服务器，以及所有同样监视master的其他sentinel进入主观下线的标准</p>
<h3 id="多个Sentinel设置的主观下线时长可能不同"><a href="#多个Sentinel设置的主观下线时长可能不同" class="headerlink" title="多个Sentinel设置的主观下线时长可能不同"></a>多个Sentinel设置的主观下线时长可能不同</h3><p>对于监视同一个主服务器的多个sentinel来说，这些sentinel所设置的down-after-milliseconds选项值也可能不同，因此，当一个sentinel将主服务器判断为主观下线时，其他sentinel可能仍然会认为主服务器处于在线状态</p>
<p>sentinel1载入以下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor master 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds master 50000</span><br></pre></td></tr></table></figure>

<p>sentinel2载入以下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor master 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds master 10000</span><br></pre></td></tr></table></figure>

<p>那么当master的断线时长超过1000毫秒之后，sentinel2会将master判断为主观下线，而sentinel却仍然认为master在线</p>
<h2 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h2><p>当sentinel将一个主服务器判断为主观下线之后，为了确定这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他sentinel进行询问，看它们是否也确认主服务器已经进入下线状态，当sentinel从其他sentinel那里接收到足够数量的已下线判断之后，sentinel就会将从服务器判断为客观下线，并对主服务器执行故障转移操作</p>
<h3 id="发送sentinel-is-master-down-by-addr命令"><a href="#发送sentinel-is-master-down-by-addr命令" class="headerlink" title="发送sentinel is-master-down-by-addr命令"></a>发送sentinel is-master-down-by-addr命令</h3><p>sentinel使用</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/160.png"  alt="img"></p>
<p>命令询问其他sentinel是否同意主服务器已下线，命令中的各个参数的意义如下</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/161.png"  alt="img"></p>
<p>举个列子，如果被sentinel判断为主观下线的主服务器的IP为127.0.0.1，端口号为6379，并且sentinel当前的配置纪元为0，那么sentinel将向其他sentinel发送以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel is-master-down-by-addr 127.0.0.1 6379 0 *</span><br></pre></td></tr></table></figure>

<h3 id="接收sentinel-is-master-down-by-addr命令"><a href="#接收sentinel-is-master-down-by-addr命令" class="headerlink" title="接收sentinel is-master-down-by-addr命令"></a>接收sentinel is-master-down-by-addr命令</h3><p>当一个sentinel接收到另一个sentinel发来的sentinel is-master-down-by-addr命令时，目标sentinel会分析并取出命令请求中包含的各个参数，并根据其中的主服务器IP和端口号，检查服务器是否已下线，然后向源sentinel返回一个包含三个参数的Multi Bulk回复作为sentinel is-master-down-by命令的回复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">down_state</span><br><span class="line">leader_runid</span><br><span class="line">leader_epoch</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/162.png"  alt="img"></p>
<p>如果一个sentinel返回以下回复作为sentinel is-master-down-by-addr命令的回复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">*</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>那么说明sentinel也同意主服务器已下线</p>
<h3 id="接收sentinel-is-master-down-by-addr命令的回复"><a href="#接收sentinel-is-master-down-by-addr命令的回复" class="headerlink" title="接收sentinel is-master-down-by-addr命令的回复"></a>接收sentinel is-master-down-by-addr命令的回复</h3><p>sentinel将统计其他sentinel同意主服务器已下线的数量，当这一数量达到配置指定的判断客观下线所需的数量时，sentinel会将主服务器实例结构flags属性的SRI_O_DOWN表示打开，表示主服务器已经进入客观下线状态</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/163.png"  alt="img"></p>
<h4 id="客观下线状态的判断条件"><a href="#客观下线状态的判断条件" class="headerlink" title="客观下线状态的判断条件"></a>客观下线状态的判断条件</h4><p>当认为主服务器已经进入下线状态的sentinel的数量超过sentinel配置中设置的quorum参数的值，那么该sentinel就会认为主服务器已经进入客观下线状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor master 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure>

<p>只要两个sentinel认为主服务器已经下线，那么当前sentinel就将主服务器判断为客观下线</p>
<h4 id="不同的sentinel判断客观下线的条件可能不同"><a href="#不同的sentinel判断客观下线的条件可能不同" class="headerlink" title="不同的sentinel判断客观下线的条件可能不同"></a>不同的sentinel判断客观下线的条件可能不同</h4><p>不同的sentinel可以配置不同的参数</p>
<h2 id="选举领头sentinel"><a href="#选举领头sentinel" class="headerlink" title="选举领头sentinel"></a>选举领头sentinel</h2><p> 当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个sentinel会进行协商，选举出一个sentinel，并由领头sentinel对下线主服务器执行故障转移</p>
<p>以下是Redis选举领头sentinel的规则和方法</p>
<ul>
<li>所有在线的sentinel都有被选举为领头sentinel的资格，也就是说监视同一个主服务器的多个在线sentinel中的任意一个都有可能成为领头sentinel</li>
<li>每次进行领头sentinel选举之后，不论选举是否成功，所有sentinel的配置纪元的值都会自增一次，配置纪元实际上就是一个计数器，并没有什么特别的</li>
<li>在一个配置纪元里面，所有的sentinel都有一次将某个sentinel设置为局部领头sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改</li>
<li>每个发现主服务器进入客观下线的sentinel都会要求其他sentinel将自己设置为局部领头sentinel</li>
<li>当一个源sentinel向另一个目标sentinel发送sentinel is-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源sentinel的运行ID时，这表示源sentinel要求目标sentinel将前者设置为后者的局部领头sentinel</li>
<li>sentinel设置局部领头sentinel的规则是先到先得，最先向目标sentinel发送设置要求的源sentinel将成为目标sentinel的局部领头sentinel，而后收到的所有设置要求都会被目标sentinel拒绝</li>
<li>目标sentinel在接收到sentinel is-master-down-by-addr命令之后，将向源sentinel返回一条命令回复，回复中的leader-runid参数和leader-epoch参数分别记录了目标sentinel和局部sentinel的运行ID和配置纪元</li>
<li>源sentinel在接收目标sentinel返回的命令回复之后，会检查回复中leader_epoch参数的值和自己的配置纪元是否相同，如果相同过的话，那么源sentinel接着取出回复中的leader_runid参数，如果leader_runid参数的值和源sentinel的运行ID一致，那么表示目标sentinel将源sentinel设置成了局部领头sentinel</li>
<li>如果有某个sentinel被半数以上的sentinel设置成了局部领头sentinel，那么这个sentinel成为领头sentinel，例如一个由10个sentinel组成的sentinel系统里面，只要有大于等于10/2+1=6个sentinel将某个sentinel设置为局部领头sentinel，那么被设置的那么sentinel就会成为领头sentinel</li>
<li>因为领头sentinel的产生需要半数以上sentinel的支持，并且每个sentinel在每个配置纪元里面只能被设置一次局部领头sentinel,所以在一个配置纪元里面，只会出现一个领头sentinel</li>
<li>如果在给定时限内，没有一个sentinel被选举为领头sentinel，那么各个sentinel将在一段时间之后再次进行选举，直到选出领头sentinel为止</li>
</ul>
<p>下面来看一个完整的选举领头sentinel的过程，假设现在有三个sentinel正在监视同一个主服务器，并且这三个sentinel之前已经通过sentinel is-master-down-by-addr命令确定主服务器进入了客观下线状态</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/164.png"  alt="img"></p>
<p>为了选举出领头sentinel，三个sentinel将再次向其他sentinel发送sentinel is-master-down-by-addr命令</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/165.png"  alt="img"></p>
<p>和检测客观下线状态时发送的sentinel is-master-down-by-addr命令不同，sentinel这次发送的命令会带有sentinel自己的运行ID</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel is-master-down-by-addr 127.0.0.1 6379 0 123456</span><br></pre></td></tr></table></figure>

<p>如果接收到这个命令的sentinel还没有设置局部变量领头sentinel的话，它会将运行ID为123456的sentinel设置为自己的局部领头sentinel，并返回类似以下的命令回复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">123456</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>然后接收到命令回复的sentinel就可以根据这一回复，统计出有多少个sentinel将自己设置成为了局部领头sentinel</p>
<p>根据命令请求发送的先后顺序不同，可能会有某个sentinel的sentinel is-master-down-by-addr命令比起其他sentinel发送的相同命令都更快到达，并最终胜出领头sentinel的选举，然后这个领头sentinel就可以开始对主服务器执行故障转移操作了</p>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>在选举产生出领头sentinel之后，领头sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤</p>
<ol>
<li>在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器</li>
<li>让已下线主服务器属下的所有从服务器改为复制新的主服务器</li>
<li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器</li>
</ol>
<h3 id="选出新的主服务器"><a href="#选出新的主服务器" class="headerlink" title="选出新的主服务器"></a>选出新的主服务器</h3><p>故障转移操作第一步要做的就是在已下线主服务器属下的所有从服务器中，挑选出一个状态良好，数据完整的从服务器，然后向这个从服务器发送SLAVEOF no one命令，将这个从服务器转化为主服务器</p>
<h4 id="新的主服务器是怎样挑选出来的"><a href="#新的主服务器是怎样挑选出来的" class="headerlink" title="新的主服务器是怎样挑选出来的"></a>新的主服务器是怎样挑选出来的</h4><p>领头sentinel会将已下线主服务器的所有从服务器保存到一个列表里面，然后按照以下规则，一项一项地对列表进行过滤</p>
<ol>
<li>删除列表中所有处于下线或者断线状态的从服务器，保证列表中剩余的从服务器都是正常在线的</li>
<li>删除列表中所有最近五秒内没有回复过领头sentinel的INFO命令的从服务器，这可以保证列表中剩余的从服务器都是最近成功进行过通信的</li>
<li>删除所有与已下线主服务器连接断开超过down-after-milliseconds * 10毫秒的从服务器down-after-milliseconds选项指定了判断主服务器下线所需的时间，而删除断开时长超过down-after-milliseconds * 10毫秒的从服务器，则可以保证列表中剩余的从服务器都没有过早地与主服务器断开连接，列表中剩余的从服务器保存的数据都是比较新的</li>
<li>领头sentinel将根据从服务器的优先级，对列表中剩余的从服务器进行排序，并选出其中优先级最高的从服务器</li>
<li>如果有多个具有相同最高优先级的从服务器，那么领头羊sentinel将按照从服务器的复制偏移量，对具有相同最高优先级的从服务器进行排序，并选出其中偏移量最大的从服务器(保存最新数据的从服务器)</li>
<li>如果有多个优先级最高，复制偏移量最大的从服务器，那么领头sentinel将按照运行ID对这些从服务器进行排序，并选出其中运行ID最小的从服务器</li>
</ol>
<p>下图展示了一次故障转移操作，领头sentinel向被选中的从服务器server2发送SLAVEOF on on命令的情形</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/166.png"  alt="img"></p>
<p>在发送slaveof on one命令之后，领头sentinel会以每秒一次的频率(平均是每十秒一次)，向被升级的从服务器发送INFO命令，并观察命令回复中的角色信息，当被升级服务器的role从原来的slave变为master时，领头sentinel就直到被选中的从服务器已经顺利升级为主服务器了</p>
<p>领头sentinel会一直向server2发送INFO命令，当server2返回的命令回复发生以下变化时</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/167.png"  alt="img"></p>
<p>这时server2升级为主服务器，sentinel也知道server2已经升级为主服务器了</p>
<h3 id="修改主服务器的复制目标"><a href="#修改主服务器的复制目标" class="headerlink" title="修改主服务器的复制目标"></a>修改主服务器的复制目标</h3><p>当新的主服务器出现之后，领头的sentinel下一步要做的就是，让已下线主服务器属下的所有从服务器去复制新的主服务器，这一动作可以通向从服务器发送SLAVEOF命令来实现</p>
<p>让从服务器复制新的主服务器</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/168.png"  alt="img"></p>
<p>server3和server4成为server2的从服务器</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/169.png"  alt="img"></p>
<h3 id="将旧的主服务器变为从服务器"><a href="#将旧的主服务器变为从服务器" class="headerlink" title="将旧的主服务器变为从服务器"></a>将旧的主服务器变为从服务器</h3><p>因为旧的主服务器已经下线，所以这种设置是保存在server1对应的实例结构里面的，当server1重新上线时，sentinel就会向它发送slaveof命令，让它成为server2的从服务器</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/170.png"  alt="img"></p>
<h2 id="重点回顾-12"><a href="#重点回顾-12" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>Sentinel只是一个运行在特殊模式下的Redis服务器，它使用了和普通模式不同的命令表，所以Sentinel模式能够使用的命令和普通Redis服务器能够使用的命令不同</li>
<li>Sentinel会读入用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接，其中命令连接用于向主服务器发送命令请求，而订阅连接则用于接受指定频道的消息</li>
<li>sentinel通过向主服务器发送INFO命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接</li>
<li>一般情况下，sentinel以每十秒一次的频率向被监视的主服务器和从服务器发送INFO命令，当主服务器处于下线状态，或者sentinel正在对主服务器进行故障转移操作时，sentinel向从服务器发送INFO命令的频率会改为每秒一次</li>
<li>对于监视同一个主服务器和从服务器的多个sentinel来说，它们会以每两秒一次的频率，通过向被监视服务器sentinel:hello频道发送消息来向其他sentinel宣告自己的存在</li>
<li>每个sentinel也会从sentinel:hello频道中接收其他sentinel发来的信息，并根据这些信息为其他sentinel创建相应的实例结构，以及命令连接</li>
<li>sentinel只会与主服务器和从服务器创建命令连接和订阅连接，sentinel与sentinel之间则只创建命令连接</li>
<li>sentinel以每秒一次的频率向实例(主从服务器，其他sentinel)发送PING命令，并根据实例对PING命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向sentinel发送无效回复时，sentinel会将这个实例判断为主观下线</li>
<li>当sentinel将一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其他sentinel进行询问，看它们是否同意这个主服务器已经进入主观下线状态</li>
<li>当sentinel收集到足够多的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作</li>
</ul>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>一个Redis集群通常由多个节点组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群</p>
<p>连接各个节点的工作可以使用cluster meet命令来完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>

<p>向一个节点node发送cluster meet命令，可以让node节点与ip和port所指定的节点进行握手，当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中</p>
<p>例如，假设现在有三个独立的节点127.0.0.1：7000，127.0.0.1：7001，127.0.0.1：7002，首先使用客户端连上节点7000，通过发送cluster node命令可以看到，集群目前只包含7000自己一个节点</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/171.png"  alt="img"></p>
<p>通过向节点7000发送以下命令，可以将节点7001添加到节点7000所在的集群里面</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/172.png"  alt="img"></p>
<p>接着向节点7000发送以下命令，可以将节点7002也添加到节点7000和节点7001所在的集群里面</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/173.png"  alt="img"></p>
<p>现在这个集群里面包含了7000，70001和7002三个节点，下图展示了三个节点进行握手的整个过程</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/174.png"  alt="img"></p>
<h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据cluster-enabled配置选项是否为yes来决定是否开启服务器的集群模式</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/175.png"  alt="img"></p>
<p>运行在集群模式下的Redis服务器会接着使用所有在单机模式中使用的服务器组件，比如说：</p>
<ul>
<li>节点会接着使用文件事件处理器来处理命令请求和返回命令回复</li>
<li>节点会接着使用时间事件处理器来执行serverCron函数，而serverCron函数又会调用集群模式特有的clusterCron函数。clusterCron函数负责执行在集群模式下需要执行的常规操作，例如向集群中的其他节点发送Gossip消息，检查节点是否断线，或者检查是否需要对下线节点进行自动故障转移</li>
<li>节点会接着使用数据库来保持键值对数据，键值对依然会是各种不同类型的对象</li>
<li>节点会接着使用RDB持久化模块和AOF持久化模块来执行持久化工作</li>
<li>节点会接着使用发布与订阅模块来执行publish，subscribe等命令</li>
<li>节点会接着使用复制模块来进行节点的复制工作</li>
<li>节点会接着使用Lua脚本环境来执行客户端输入的Lua脚本</li>
</ul>
<p>除此之外，节点会接着使用redisServer结构来保存服务器的状态，使用redisClient结构来保存客户端的状态，至于那些只有在集群模式下才会用到的数据，节点将它们保存到了cluster.h/clusterNode结构，cluster.h/clusterLink结构，以及cluster.h/clusterState结构里面</p>
<h3 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h3><p>clusterNode结构保存了一个节点的当前状态，比如节点的创建时间，节点的名字，节点当前的配置纪元，节点的IP地址和端口号等等</p>
<p>每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所其他节点都创建一个相应的clusterNode结构，以此来记录其他节点的状态</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/176.png"  alt="img"></p>
<p>link属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/177.png"  alt="img"></p>
<h4 id="redisClient和clusterLink结构的异同之处"><a href="#redisClient和clusterLink结构的异同之处" class="headerlink" title="redisClient和clusterLink结构的异同之处"></a>redisClient和clusterLink结构的异同之处</h4><p>redisClient结构和clusterLink结构都有自己的套接字描述符和输入，输出缓冲区，这两个结构的区别在于，redisClient结构中的套接字和缓冲区是用于连接客户端的，而clusterLink结构中的套接字和缓冲区则是用于连接节点的</p>
<p>每个节点都保存着一个clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，例如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/178.png"  alt="img"></p>
<p>下图展示了节点7000创建的clusterState结构，这个结构从节点7000的角度记录了集群以及集群包含的三个节点的当前状态</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/179.png"  alt="img"></p>
<ul>
<li>currentEpoch属性的值为0，表示集群当前的配置纪元为0</li>
<li>size值为0，表示集群目前没有任何节点在处理槽，因此结构的state属性的值为REDIS_CLUSTER_FAIL，这表示集群目前处于下线状态</li>
<li>nodes字典记录了集群目前包含的三个节点，这三个节点分别由三个clusterNode结构表示，myself指针指向代表节点7000的clusterNode结构，而字典中的另外两个指针则分别指向代表节点7001和7002的clusterNode结构，这两个节点是节点7000已知的在集群中的其他节点</li>
<li>三个节点的clusterNode结构的flags属性都是REDIS_NODE_MASTER，说明三个节点都是主节点</li>
</ul>
<p>节点7001和节点7002也会创建类似于clusterState的结构</p>
<ul>
<li>不过节点7001创建的clusterState结构中，myself指针将指向代表节点7001的clusterNode结构，而节点7000和节点7002则是集群中的其他节点</li>
</ul>
<h3 id="CLUSTER-MEET命令的实现"><a href="#CLUSTER-MEET命令的实现" class="headerlink" title="CLUSTER MEET命令的实现"></a>CLUSTER MEET命令的实现</h3><p>通过向节点A发送Cluster meet命令，客户端可以让接收命令的节点A将另一个节点B添加到节点A当前所在的集群里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster meet &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>

<p>收到命令的节点A将与节点B进行握手，以此来确认彼此的存在，并为将来的进一步通信打好基础</p>
<ol>
<li>节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面</li>
<li>节点A将根据Cluster meet命令给定的IP地址和端口号，向节点B发送一条meet消息</li>
<li>节点B接收到节点A发送的meet消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面</li>
<li>节点B将向节点A返回一条PONG消息</li>
<li>节点A接收到节点B返回的PING消息，通过这条PONG消息，节点A可以知道节点B已经成功地接收到了自己发送的MEET消息</li>
<li>节点A将向节点B返回一条PING消息</li>
<li>节点B接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成、</li>
</ol>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/180.png"  alt="img"></p>
<p>之后，节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B进行握手，最终节点B会被集群中的所有节点认识</p>
<h2 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h2><p>Redis集群通过分片的方式来保存数据库中的键值对，集群中的整个数据库被分为16384个槽，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽</p>
<p>当数据库中的16384个槽都有节点在处理时，集群处于上线状态ok;如果数据库中任何一个槽没有得到处理，那么集群处于下线状态fail</p>
<p>使用cluster meet命令将7000，7001，7002三个节点连接到同一个集群里面，不过这个集群目前仍然处于下线状态，因为集群中的三个节点都没有在处理任何槽</p>
<p>通过向节点发送cluster addslots命令，可以将一个或多个槽指派给节点负责，执行以下命令可以将槽0至槽5000指派给节点7000负责</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1：7000&gt;cluster addslots 0 1 2 3 4...5000</span><br></pre></td></tr></table></figure>

<p>为了让7000，7001，7002三个节点所在的集群进入上线状态，将槽5001至槽10000指派给节点7001负责</p>
<p>将槽10001至槽16383指派给7002负责</p>
<p>执行完成之后，数据库中的16384个槽都已经被指派给相应的节点，集群进入上线状态</p>
<h3 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h3><p>clusterNode结构的slots属性和numslot属性记录了节点负责处理那些槽</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/181.png"  alt="img"></p>
<p>slots属性是一个二进制位数组，这个数组的长度为16384/8=2048个字节，共包含16384个二进制位</p>
<p>Redis以0为起始索引，16383为终止索引，对slots数组中的16383个二进制位进行编号，并根据索引i上的二进制的值来判断节点是否负责处理槽i</p>
<ul>
<li>如果slots数组在索引i上的二进制位的值为1，那么表示节点负责处理槽i</li>
<li>如果slots数组在索引i上的二进制位的值为0，那么表示节点不负责处理槽i</li>
</ul>
<p>下图展示了一个slots数组示例，这个数组索引0至索引7上的二进制位的值都为1，其余所有二进制位的值都是为0，这表示节点负责处理槽0至槽7</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/182.png"  alt="img"></p>
<p>因为取出和设置slots数组中的任意一个二进制的值的复杂度仅为O(1),所以对于一个给定节点的slots数组来说，程序检查节点是否负责处理某个槽，又或者将某个槽指派给节点负责，这两个动作的复杂度都是O(1)</p>
<p>numslots属性则记录节点负责处理的槽的数量，也即是slots数组中值为1的二进制数量</p>
<h3 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h3><p>一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots属性之外，它还会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理那些槽</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/183.png"  alt="img"></p>
<p>因为集群中的每个节点都会将自己的slots数组通过消息发送给集群中的其他节点，并且每个接收到slots数组的节点都会将数组保存到相应节点的clusterNode结构里面，因此，集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的那些节点</p>
<h3 id="记录集群所有槽的指派信息"><a href="#记录集群所有槽的指派信息" class="headerlink" title="记录集群所有槽的指派信息"></a>记录集群所有槽的指派信息</h3><p>cluster结构中的slots数组记录了集群中所有16384个槽的指派信息</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/184.png"  alt="img"></p>
<p>slots数组包含了16384个项，每个数组项都是一个指向clusterNode结构的指针</p>
<ul>
<li>如果slots[i]指针指向NULL,那么表示槽i尚未指派给任何节点</li>
<li>如果slots[i]指针指向一个clusterNode结构，那么表示槽i已经指派给了clusterNode结构所代表的节点</li>
</ul>
<p>对于7000，7001，7002三个节点来说，它们的clusterState结构的slots数组将会如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/185.png"  alt="img"></p>
<ul>
<li>数组项slots[0]至slots[5000]的指针都指向代表节点7000的clusterNode结构，表示槽0至5000都指派给了节点7000</li>
<li>数组项slots[5001]至slots[10000]的指针都指向代表节点的7001的clusterNode结构，表示槽5001至10000都指派给了节点7001</li>
<li>数组项slots[10001]至slots[16383]的指针都指向代表节点的7002的clusterNode结构，表示槽10001至16383都指派给了节点70012</li>
</ul>
<p>如果只将槽指派信息保存在各个节点的clusterNode.slots数组里，会出现一些无法高效地解决的问题，而clusterState.slots数组的存在解决了这些问题</p>
<ul>
<li>如果节点只使用clusterNode.slots数组来记录槽的指派信息，那么为了知道槽i是否已经被指派，或者槽i被指派给了哪个节点，程序需要遍历clusterState.nodes字典中的所有clusterNode结构，检查这些结构的slots数组，直到找到负责处理槽i的节点为止，这个过程的复杂度为O(N)，其中N为clusterState.nodes字典保存的clusterNode结构的数量</li>
<li>而通过将所有的槽的指派信息保存在clusterState.slots数组里面，程序要检查槽i是否已经被指派，又或者取得负责处理槽i的节点，只需要访问clusterState.slots[i]的值即可，</li>
</ul>
<p>例如，如果程序需要知道槽10002被指派给了哪个节点，那么只要访问数组项slots[10002],就可以马上知道槽10002被指派给了节点7002</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/186.png"  alt="img"></p>
<p>虽然clusterState.slots数组记录了集群中所有槽的指派信息，但使用clusterNode结构的slots数组来记录单个节点的槽指派想你洗仍然是很有必要的</p>
<ul>
<li><p>因为当程序需要将某个节点的槽指派信息通过消息发送给其他节点时，程序只需要将相应节点的clusterNode.slots数组整个发送出去就可以了</p>
</li>
<li><p>另一个方面，如果redis不使用clusterNode.slots数组，而单独使用clusterState.slots数组的话，那么每次要将节点A的槽指派信息传播给其他节点时，程序必须先遍历整个clusterState.slots数组，记录节点A负责处理哪些槽，然后才能发送节点A的槽指派信息，这比直接发送clusterNode.slots数组要低效得多</p>
</li>
</ul>
<p>clusterState.slots数组记录了集群中所有槽的指派信息，而clusterNode.slots数组只记录了clusterNode结构所代表的节点的槽指派信息，这是两个slots数组的关键区别所在</p>
<h3 id="CLUSTER-ADDSLOTS命令的实现"><a href="#CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="CLUSTER ADDSLOTS命令的实现"></a>CLUSTER ADDSLOTS命令的实现</h3><p>CLUSTER ADDSLOTS命令接受一个或多个槽作为参数，并将所有输入的槽指派给接收该命令的节点负责</p>
<h2 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h2><p>在对数据库中的16384个槽都进行指派之后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了</p>
<p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库属于哪个槽，并检查这个槽是否指派给了自己</p>
<ul>
<li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令</li>
<li>如果键所指的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向至正确的节点，并再次发送之前想要执行的命令</li>
</ul>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/187.png"  alt="img"></p>
<h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点(源节点)的槽改为指派给另一个节点(目标节点)，并且相关槽所属的键值对也会从源节点被移动到目标节点</p>
<p>重新分片操作可以在线进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以接着处理命令请求</p>
<p>Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的，Redis提供了进行重新分片所需的所有命令，而redis-trib则通过向源节点和目标节点发送命令来进行重新分片操作</p>
<h2 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h2><p>在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种情况，属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面</p>
<p>274-290跳过</p>
<h2 id="重点回顾-13"><a href="#重点回顾-13" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>节点通过握手来将其他节点添加到自己所处的集群当中</li>
<li>集群中的16384个槽可以分别指派给集群中的各个节点，每个节点都会记录那些槽指派给了自己，而那些槽又被指派给了其他节点</li>
<li>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个MOVED错误，MOVED错误携带的信息可以指引客户端转向正在负责相关槽的节点</li>
<li>对Redis集群的重新分片工作是由redis-trib负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点</li>
<li>如果节点A正在迁移槽i至节点B，那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A会向客户端返回一个ASK错误，指引客户端到节点B接着查找指定的数据库键</li>
<li>MOVED错误表示槽的负责权已经从一个节点转移到另一个节点，而ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施</li>
<li>集群里的从节点用于复制主节点，并在主节点下线时，代替主节点接着处理命令请求</li>
<li>集群中的节点通过发送和接收消息来进行通讯，常见的消息包括MEET，PING，PONG，PUBLISH，FAIL五种</li>
</ul>
<h1 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h1><p>Redis的发布与订阅功能由publish,subscribe,psubscribe等命令组成</p>
<p>通过执行subscribe命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者，每当有其他客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条信息</p>
<p>假设A，B，C三个客户端都执行了命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe &quot;news.it&quot;</span><br></pre></td></tr></table></figure>

<p>那么这三个客户端就是news.it频道的订阅者</p>
<p>如果这时某个客户端执行命令,向new.it频道发送消息hello,那么news.it的三个订阅者都将收到这条消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish &quot;news.it&quot; &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/188.png"  alt="img"></p>
<p>除了订阅频道之外，客户端还可以通过执行psubscribe命令订阅一个或多个模式，从而成为这些模式的订阅者，每当有其他客户端向某个频道发送信息时，消息不仅会被发送给这个频道的所有订阅者，它还会被发送给所有与这个频道相匹配的模式的订阅者</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/189.png"  alt="img"></p>
<ul>
<li><p>客户端A正在订阅news.it</p>
</li>
<li><p>客户端B正在订阅频道news.et</p>
</li>
<li><p>客户端C和客户端D正在订阅news.it频道和news.et频道相匹配的模式news.[ie]t</p>
</li>
</ul>
<p>如果这时某个客户端执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish &quot;news.it&quot; &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<p>向news.it频道发送消息hello,那么不仅正在订阅news.it频道的客户端A会收到消息，客户端C和D也同样会收到消息</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/190.png"  alt="img"></p>
<h2 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h2><p>Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键时某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端。频道被订阅和退订的时候，就是通过修改目标链表而实现的</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/191.png"  alt="img"></p>
<h2 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h2><p>服务器将所有的模式和订阅关系都保存在服务器状态的pubsub_patterns属性里面</p>
<p>pubsub_patterns属性是一个链表，链表中的每个节点都包含着一个pubsubpattern结构，这个结构的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/192.png"  alt="img"></p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>当一个Redis客户端执行PUBLISH <channel> <message>命令将message发送给频道channel的时候，服务器需要执行以下两个动作</message></channel></p>
<ul>
<li>将消息message发送给channel频道的所有订阅者</li>
<li>如果一个或多个模式pattern与频道channel相匹配，那么将消息message发送给pattern模式的订阅者</li>
</ul>
<h3 id="将消息发送个频道订阅者"><a href="#将消息发送个频道订阅者" class="headerlink" title="将消息发送个频道订阅者"></a>将消息发送个频道订阅者</h3><p>找到目标频道或模式的链表对应的客户端，发送消息</p>
<h2 id="查看订阅消息"><a href="#查看订阅消息" class="headerlink" title="查看订阅消息"></a>查看订阅消息</h2><p>pubsub,客户端可以通过这个命令来查看频道或者模式的相关信息</p>
<h3 id="pubsub-channels-patttern"><a href="#pubsub-channels-patttern" class="headerlink" title="pubsub channels[patttern]"></a>pubsub channels[patttern]</h3><ul>
<li>如果不给定pattern参数，命令返回服务器当前被订阅的所有频道</li>
<li>如果给定pattern参数，那么命令返回服务器当前被订阅的频道中那些与pattern模式相匹配的频道</li>
</ul>
<p>这个子命令是通过遍历服务器pubsub_channels字典的所有键(每个键都是一个被订阅的频道)，然后记录并返回所有符合条件的频道来实现的</p>
<h3 id="pubsub-numsub-channel-1-channel-2…channel-n"><a href="#pubsub-numsub-channel-1-channel-2…channel-n" class="headerlink" title="pubsub numsub[channel-1 channel-2…channel-n]"></a>pubsub numsub[channel-1 channel-2…channel-n]</h3><p>该子命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量</p>
<p>是通过在pubsub_channels字典中找到频道对应的订阅者链表，然后返回订阅者链表的长度来实现的</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/194.png"  alt="img"></p>
<h3 id="pubsub-numpat"><a href="#pubsub-numpat" class="headerlink" title="pubsub numpat"></a>pubsub numpat</h3><p>该子命令用于返回服务器当前被订阅模式的数量</p>
<p>是通过返回pubsub_patterns链表的长度来实现的</p>
<h2 id="重点回顾-14"><a href="#重点回顾-14" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>服务器状态在pubsub_channels字典保存了所有频道的订阅关系，subscribe命令负责将客户端和被订阅频道关联到这个字典里面，而unsubscribe命令则负责解除客户端和被退订频道之间的关联</li>
<li>服务器状态在pubsub_patterns链表保存了所有模式的订阅关系，psubscribe命令负责将客户端和被订阅的模式记录到这个链表中，而punsubscribe命令则负责移除客户端和被退订模式在链表中的记录</li>
<li>publish命令通过访问pubsub_channels字典来向频道的所有订阅者发送消息，通过访问pubsub_patterns链表来向所有匹配频道的模式的订阅者发送消息</li>
<li>pubsub命令的三个子命令都是通过读取pubsub_channels字典和pubsub_patterns链表中的信息来实现的</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis通过multi,exec,watch等命令来实现事务功能，事务提供了一种将多个命令请求打包，然后一次性，按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求</p>
<p>事务以一个multi命令为开始，接着将多个命令放入事务中，最后由exec命令将这个事务提交给服务器执行</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/195.png"  alt="img"></p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><h3 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h3><p>multi命令的执行标志着事务的开始，multi命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI表示来完成的</p>
<h3 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h3><p>当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行</p>
<p>当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作</p>
<ul>
<li>如果客户端发送的命令为exec,discrad,watch,multi四个命令的其中一个，那么服务器立即执行这个命令</li>
<li>如果客户端发送的是上述四个命令以外的命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回queued回复</li>
</ul>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/196.png"  alt="img"></p>
<h3 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h3><p>每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里面</p>
<p>事务状态mstate包含一个事务队列，以及一个已入队命令的计数器(事务队列的长度)</p>
<p>事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针，命令的参数，以及参数的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof struct multiCmd&#123;</span><br><span class="line">	&#x2F;&#x2F;参数</span><br><span class="line">	robj ** argv;</span><br><span class="line">	&#x2F;&#x2F;参数数量</span><br><span class="line">	int argc;</span><br><span class="line">	&#x2F;&#x2F;命令指针</span><br><span class="line">	struct redisCommand *cmd;</span><br><span class="line">&#125;multiCmd</span><br></pre></td></tr></table></figure>

<p>事务队列以先进先出的方式保存入队命令</p>
<p>如果客户端执行以下命令</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/197.png"  alt="img"></p>
<p>客户端的数据结构如下</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/198.png"  alt="img"></p>
<h3 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h3><p>当一个处于事务状态的客户端向服务器发送exec命令时，这个exec命令将立即被服务器执行，服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端</p>
<h2 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h2><p>watch命令是一个乐观锁，它可以在exec命令执行之前，监视任意数量的数据库键，并在exec命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复</p>
<p>以下是一个事务执行失败的例子</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/199.png"  alt="img"></p>
<p>下图展示了上面的例子是如何失败的</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/200.png"  alt="img"></p>
<p>时间T4时，客户端B修改了name键的值，当客户端A在T5执行EXE命令时，服务器会发现WATCH监视的键name已经被修改，因此服务器拒绝执行客户端A的事务，并向客户端A返回空回复</p>
<h3 id="使用watch命令监视数据库键"><a href="#使用watch命令监视数据库键" class="headerlink" title="使用watch命令监视数据库键"></a>使用watch命令监视数据库键</h3><p>每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端</p>
<p>通过watched_keys字典，服务器可以清楚地知道那些数据库键正在被监视，以及哪些客户端正在监视这些数据库键</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/201.png"  alt="img"></p>
<h3 id="监视机制的触发"><a href="#监视机制的触发" class="headerlink" title="监视机制的触发"></a>监视机制的触发</h3><p>所有对数据库进行修改的命令，在执行之后都会调用multi.c/touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，表示该客户端的事务安全性已经被破坏</p>
<h3 id="判断事务是否安全"><a href="#判断事务是否安全" class="headerlink" title="判断事务是否安全"></a>判断事务是否安全</h3><p>当服务器接收到客户端发送来的exec命令时，服务会根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/202.png"  alt="img"></p>
<h3 id="一个完整的WATCH事务执行过程"><a href="#一个完整的WATCH事务执行过程" class="headerlink" title="一个完整的WATCH事务执行过程"></a>一个完整的WATCH事务执行过程</h3><p>假设当前客户端为c10086,而数据库watched_keys字典 的当前状态如下图所示</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/203.png"  alt="img"></p>
<p>当c10086执行以下WATCH命令之后，watched_keys字典将更新至下图</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/204.png"  alt="img"></p>
<p>客户端c10086接着向服务器发送multi命令，并将一个set命令放入事务队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c10086&gt;multi</span><br><span class="line">c10086&gt;set &quot;name&quot; &quot;peter&quot;</span><br></pre></td></tr></table></figure>

<p>这时，另一个客户端c999向服务器发送了一条set命令，将name键的值设置为join，这会导致正在监视name键的所有客户端的REDIS_DIARY_CAS标识被打开，其中包括客户端c10086</p>
<p>当c10086向服务器发送exec命令的时候，因为c10086的REDIS_DIARY_CAS标识已经被打开，所以服务器将拒绝执行它提交的事务</p>
<h2 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h2><p>在Redis中，事务总是具有原子性A，一致性C，隔离性I，并且当Redis运行在某种特定的持久化模式下时，事务也具有耐久性D</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行</p>
<p>Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制rollback，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会接着执行下去，直到将事务队列中的所有命令都执行完毕为止</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/205.png"  alt="img"></p>
<p>???不支持回滚和原子性不是冲突了吗？</p>
<p>作者认为，事务回滚这种复杂的功能和Redis追求简单高效的设计主旨不相符，并且认为Redis事务的执行时错误都是认为造成的，可以人为避免</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>事务一致性是指，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的</p>
<p>一致指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据</p>
<p>Redis通过谨慎的错误检测和简单的设计来保证事务一致性</p>
<h4 id="入队错误"><a href="#入队错误" class="headerlink" title="入队错误"></a>入队错误</h4><p>如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么Redis将拒绝这个事务</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/206.png"  alt="img"></p>
<p>因为服务器会拒绝执行入队过程中出现错误的事务，所以Redis事务的一致性不会被带有入队错误的事务影响</p>
<h4 id="执行错误"><a href="#执行错误" class="headerlink" title="执行错误"></a>执行错误</h4><ul>
<li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时被触发</li>
<li>即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会接着执行事务中余下的其他命令，并且已执行的命令不会被出错的命令影响</li>
</ul>
<p>对数据库键执行了错误类型的操作是事务执行期间最常见的错误之一</p>
<p>对字符串键使用只能用于列表键的RPUSH命令，这将引发一个错误，并且这种错误只能在事务执行期间被发现</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/207.png"  alt="img"></p>
<p>错误的命令会被服务器识别出来，并进行相应的错误处理，所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响</p>
<h4 id="服务器停机"><a href="#服务器停机" class="headerlink" title="服务器停机"></a>服务器停机</h4><p>如果Redis服务器在执行事务的过程中停机，那么根据服务器所使用的持久化模式，可能有以下情况出现</p>
<ul>
<li>如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的</li>
<li>如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来回复数据，从而将数据库还原到一个一致的状态。如果找不到可供提供使用的RDB文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的</li>
<li>如果服务器运行在AOF模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来回复数据，从而将数据库还原到一个一致状态</li>
</ul>
<p>综上所述，无论Redis服务器运行在那种持久化模式下，事务执行中途发生的停机都不会影响数据库的一致性</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>事务的隔离性是指，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同</p>
<p>因为Redis使用单线程的方式来执行事务(以及事务队列中的命令)，并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的</p>
<h3 id="耐久性"><a href="#耐久性" class="headerlink" title="耐久性"></a>耐久性</h3><p>事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质(例如硬盘)里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失</p>
<p>因为Redis的事务不过是简单地用队列包裹起了一组Redis命令，Redis并没有为事务提供任何额外的持久化功能，所以Redis事务的耐久性由Redis所使用的持久化模式决定</p>
<ul>
<li>当服务器在无持久化的内存模式下运作时，事务不具有耐久性，一旦服务器停机，包括事务数据在内的所有服务器数据都将丢失</li>
<li>当服务器在RDB持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行BGSAVE命令，对数据库进行保存操作，并且异步执行的BGSAVE不能保证事务数据被第一时间保存到硬盘里面，因此RDB持久化模式下的事务也不具有耐久性</li>
<li>当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，程序总会在执行命令之后调用同步sync函数，将命令数据真正地保存到硬盘里面，因此这种配置下的事务是具有耐久性的</li>
<li>AOF模式下，appendfsync选项的值为everysec时，程序会每秒同步以此命令数据到硬盘，因为停机可能会敲好发生在等待同步的那一秒内，这可能会造成事务数据丢失，所以这种配置下的事务不具有耐久性</li>
<li>AOF模式下，并且appendfsync选项的值为no时，程序会交由操作系统来决定何时将命令数据同步到硬盘，因为事务数据可能在等待同步的过程中丢失，所以这种配置下的事务不具有耐久性</li>
</ul>
<p>当no-appendfsync-on-rewrite选项处于打开状态时，在执行BGSAVE命令或者BGREWRITEAOF命令期间，服务器会暂时停止对AOF文件进行同步，从而尽可能地减少I/O阻塞，因为在服务器停止对AOF文件进行同步期间，事务结果可能会因为停机而丢失，所以如果服务器开启了no-appendfsync-on-rewrite选项，那么即使服务器运行在always模式的AOF持久化之下，事务也不具有耐久性，默认情况下，no-appendfsync-on-rewrite处于关闭状态</p>
<p>无论Redis在什么模式下运作，在一个事务的最后加上SAVE命令总可以保证事务的耐久性，只是效率太低，不实用</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/208.png"  alt="img"></p>
<h2 id="重点回顾-15"><a href="#重点回顾-15" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>事务提供了一种将多个命令打包，然后一次性，有序地执行的机制</li>
<li>多个命令会被入队到事务队列中，然后按先进先出的顺序执行</li>
<li>事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束</li>
<li>带有watch命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的REDIS_DIRTY_CAS标志打开</li>
<li>只有在客户端的REDIS_DIRTY_CAS标志未被打开时，服务器才会执行客户端提交的事务，否则的话，服务器将决绝执行客户但提交的事务</li>
<li>Redis事务总是具有ACID中的原子性，一致性和隔离性，当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性</li>
</ul>
<h1 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h1><p>通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令</p>
<p>使用EVAL命令可以直接对输入的脚本进行求值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;eval &quot;return &#39;hello world&#39;&quot; 0</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<p>使用EVALSHA命令则可以根据脚本的SHA1校验和来对脚本进行求职，但这个命令要求校验和对应的脚本必须至少被EVAL命令执行过一次</p>
<h2 id="创建并修改Lua环境"><a href="#创建并修改Lua环境" class="headerlink" title="创建并修改Lua环境"></a>创建并修改Lua环境</h2><p>Redis服务器创建并修改Lua环境的整个过程由以下步骤组成</p>
<ol>
<li>创建一个基础的Lua环境，之后的所有修改都是针对这个环境进行的</li>
<li>载入多个函数到Lua环境里面，让Lua脚本可以使用这些函数库来进行数据操作</li>
<li>创建全局表格redis，这个表格包含了对Redis进行操作的函数，比如用于在Lua脚本中执行Redis命令的redis.call函数</li>
<li>使用Redis自制的随机函数来替换Lua原有的带有副作用的随机函数，从而避免在脚本中引入副作用</li>
<li>创建排序辅助函数，Lua环境使用这个辅助函数来对一部分Redis命令的结果进行排序，从而消除这些命令的不确定性</li>
<li>创建redis.pcall函数的错误报告辅助函数，这个函数可以提供更详细的出错信息</li>
<li>对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本的过程中，将额外的全局变量添加到Lua环境中</li>
<li>将完成修改的Lua环境保存到服务器状态的Lua属性中，等待执行服务器传来的Lua脚本</li>
</ol>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>Redis的SORT命令可以对列表键，集合键或者有序集合键的值进行排序</p>
<p>以下代码展示了SORT命令对列表键进行排序的例子</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/209.png"  alt="img"></p>
<p>以下代码展示了SORT命令使用ALPHA选项，对一个包含字符串值的集合键进行排序的例子</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/210.png"  alt="img"></p>
<p>接下来的例子使用了SORT命令和BY选项，以jack_number,peter_number,tom_number三个键的值为权重，对有序集合test-result中的jack,peter,tom三个成员进行排序</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/211.png"  alt="img"></p>
<h2 id="SORT命令的实现"><a href="#SORT命令的实现" class="headerlink" title="SORT命令的实现"></a>SORT<key>命令的实现</key></h2><p>这个命令可以对一个包含数字值的键key进行排序，以下展示了如何使用SORT命令对一个包含三个数字值的列表键进行排序</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/212.png"  alt="img"></p>
<p>服务器执行SORT numbers命令的详细步骤如下</p>
<ol>
<li><p>创建一个和numbers列表长度相同的数组，该数组的每个项都是一个redis.h/redisSortObject结构</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/213.png"  alt="img"></p>
</li>
<li><p>遍历数组，将各个数组项的obj指针分别指向numbers列表的各个项，构成obj指针和列表项之间的一对一关系</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/214.png"  alt="img"></p>
</li>
<li><p>遍历数组，将各个obj指针所指向的列表项转换成一个double类型的浮点数，并将这个浮点数保存在相应数组项的u.score属性里面</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/215.png"  alt="img"></p>
</li>
<li><p>根据数组项u.score属性的值，对数组进行数字值排序，排序后的数组项按u.score属性的值从小到大排序</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/216.png"  alt="img"></p>
</li>
<li><p>遍历数组，将各个数组项的obj指针所指向的列表项作为排序结果返回给客户端</p>
</li>
</ol>
<h2 id="ALPHA选项的实现"><a href="#ALPHA选项的实现" class="headerlink" title="ALPHA选项的实现"></a>ALPHA选项的实现</h2><p>通过使用ALPHA选项，SORT命令可以对包含字符串值的键进行排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SORT &lt;key&gt; ALPHA</span><br></pre></td></tr></table></figure>

<p>以下命令展示了如何使用SORT命令对一个包含三个字符串值的集合键进行排序</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/217.png"  alt="img"></p>
<p>服务器执行SORT fruits ALPHA命令的详细步骤如下：</p>
<ol>
<li>创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小</li>
<li>遍历数组，将各个数组项的obj指针分别指向fruits集合的大小</li>
<li>根据obj指针所指向的集合元素，对数组进行字符串排序，排序后的数组项按集合元素的字符串值从小到大排列</li>
<li>遍历数组，依次将数组项的obj指针所指向的元素返回给客户端</li>
</ol>
<h2 id="ASC选项和DESC选项的实现"><a href="#ASC选项和DESC选项的实现" class="headerlink" title="ASC选项和DESC选项的实现"></a>ASC选项和DESC选项的实现</h2><p>默认情况下，SORT命令执行升序排序，排序后的结果按值的大小从小到大排列</p>
<h2 id="BY选项的实现"><a href="#BY选项的实现" class="headerlink" title="BY选项的实现"></a>BY选项的实现</h2><p>默认情况下，SORT命令使用被排序键包含的元素作为排序的权重，元素本身决定了元素在排序之后所处的位置，在下面的例子当中，排序fruits集合所使用的权重就是apple,banana,cherry三个元素本身</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/218.png"  alt="img"></p>
<p>SORT可以使用BY选项指定某些字符串键，或者某个哈希键所包含的某些域来作为元素的权重，对一个键进行排序</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/219.png"  alt="img"></p>
<p>服务器执行SORT fruits BY * -price命令的详细步骤如下</p>
<ol>
<li>创建一个redisSortObject结构数组，数组的长度等于fruits集合的大小</li>
<li>遍历数组，将各个数组项的obj指针所指向的集合元素，以及BY选项所给定的模式*-price，查找相应的权重键</li>
</ol>
<ul>
<li><p>apple元素，查找程序返回权重键apple-price</p>
</li>
<li><p>banana元素，查找程序返回权重键banana-price</p>
</li>
<li><p>cherry元素，查找程序返回权重键cherry-price</p>
<p>3.将各个权重键的值转换成一个double类型的浮点数，然后保存在相应数组项的u.score属性里面</p>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/220.png"  alt="img"></p>
<p>  4.以数组项u.socre属性的值为权重，对数组进行排序，得到一个按u.socre属性的值从小到大排序的数组</p>
<h2 id="带有ALPHA选项的BY选项的实现"><a href="#带有ALPHA选项的BY选项的实现" class="headerlink" title="带有ALPHA选项的BY选项的实现"></a>带有ALPHA选项的BY选项的实现</h2><p>BY选项默认假设权重键保存的键为数字值，如果权重键保存的是字符串值的话，那么就需要在使用BY选项的同时，配合使用ALPHA选项</p>
<h2 id="LIMIT选项的实现"><a href="#LIMIT选项的实现" class="headerlink" title="LIMIT选项的实现"></a>LIMIT选项的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT &lt;offset&gt; &lt;count&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>offset参数表示要跳过的已排序元素的数量</li>
<li>count参数表示跳过给定数量的已排序元素之后，要返回的已排序元素数量</li>
</ul>
<h2 id="GET选项的实现"><a href="#GET选项的实现" class="headerlink" title="GET选项的实现"></a>GET选项的实现</h2><p>默认情况下，SORT命令在对键进行排序之后，总是返回被排序键本身所包含的元素</p>
<p>通过get选项，可以让SORT命令在对键进行排序之后，根据被排序的元素，以及GET选项所指定的模式，查找并返回某些键的值</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/221.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/222.png"  alt="img"></p>
<h2 id="STORE选项的实现"><a href="#STORE选项的实现" class="headerlink" title="STORE选项的实现"></a>STORE选项的实现</h2><p>默认情况下，SORT命令只向客户端返回排序结果，而不保存排序结果，但是使用store选项，可以将排序结果保存在指定的键里面，并在有需要时重用这个排序结果</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/223.png"  alt="img"></p>
<h2 id="多个选项的执行顺序"><a href="#多个选项的执行顺序" class="headerlink" title="多个选项的执行顺序"></a>多个选项的执行顺序</h2><p>一个SORT命令通常会用到多个选线，而这些选项的执行顺序是有先后之分的</p>
<h3 id="选项的执行顺序"><a href="#选项的执行顺序" class="headerlink" title="选项的执行顺序"></a>选项的执行顺序</h3><p>一个sort命令的执行过程可以分为以下四步</p>
<ol>
<li>排序，命令会使用ALPHA,ASC,DESC,BY这几个选项，对输入键进行排序，并得到一个排序结果集</li>
<li>限制排序结果集的长度，命令会使用LIMIT选项，对排序结果集的长度进行限制，只有LIMIT选项指定的那部分元素会被保留在排序结果集中</li>
<li>获取外部键，命令会使用get选项，根据排序结果集中的元素，以及get选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集</li>
<li>保存排序结果集，命令会使用store选项，将排序结果集保存到指定的键上面去</li>
<li>向客户端返回排序结果集，命令遍历排序结果集，并以此向客户端返回排序结果集中的元素</li>
</ol>
<p>后一个步骤必须在前一个步骤完成之后进行</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/224.png"  alt="img"></p>
<h3 id="选项的摆放顺序"><a href="#选项的摆放顺序" class="headerlink" title="选项的摆放顺序"></a>选项的摆放顺序</h3><p>调用SORT命令时，除了GET选项外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序</p>
<h2 id="重点回顾-16"><a href="#重点回顾-16" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>SORT命令通过将被排序键包含的元素载入到数组里面，然后对数组进行排序来完成对键进行排序的工作</li>
<li>默认情况下，SORT命令假设被排序键包含的都是数字值，并且以数字值的方式来进行排序</li>
<li>如果SORT命令使用了ALPHA选项，那么SORT命令假设被排序键包含的都是字符串值，并且以字符串值的方式来进行排序</li>
<li>SORT命令的排序操作由快速排序算法实现</li>
<li>SORT命令会根据用户是否使用DESC选项来决定升降序</li>
<li>当SORT命令使用了BY选项时，命令使用其他键的值作为权重来进行排序操作</li>
<li>当SORT命令使用了GET选项时，命令会根据排序结果集中的元素，以及GET选项给定的模式，查找并返回其他键的值，而不是返回被排序的元素</li>
</ul>
<h1 id="二进制位数组"><a href="#二进制位数组" class="headerlink" title="二进制位数组"></a>二进制位数组</h1><p>Redis提供了SETBIT,GETBIT,BITCOUNT,BITOP四个命令用于处理二进制数组(bit array,位数组)</p>
<p>setbit命令用于为位数组指定偏移量上的二进制位设置值，位数组的偏移量从0开始计数，而二进制的值则可以是0或1</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/225.png"  alt="img"></p>
<p>getbit命令则用于获取位数组指定偏移量上的二进制位的值</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/226.png"  alt="img"></p>
<p>bitcount命令用于统计位数组里面，值为1的二进制位的数量</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/227.png"  alt="img"></p>
<p>bitop命令既可以对多个位数组进行按位与and,按位或or,按位异或xor运算</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/228.png"  alt="img"></p>
<p>也可以对给定的位数组进行取反not运算</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/229.png"  alt="img"></p>
<h2 id="位数组的表示"><a href="#位数组的表示" class="headerlink" title="位数组的表示"></a>位数组的表示</h2><p>Redis使用字符串对象来表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的，所以程序可以直接使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/230.png"  alt="img"></p>
<ul>
<li>redisObject.type的值为REDIS_STRING，表示这是一个字符串对象</li>
<li>sdshdr.len的值为1，表示这个SDS保存了一个一字节长的位数组</li>
<li>buf数组中的buf[0]字节保存了一个字节长度的位数组</li>
<li>buf数组中的buf[1]字节保存了SDS程序自动追加到值的末尾的空字符’\0‘</li>
</ul>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/231.png"  alt="img"></p>
<h2 id="GETBIT命令的实现"><a href="#GETBIT命令的实现" class="headerlink" title="GETBIT命令的实现"></a>GETBIT命令的实现</h2><p>getbit命令的执行过程如下</p>
<ol>
<li>计算byte=offset/8,byte值记录了offset偏移量指定的二进制位保存在位数组的哪个字节</li>
<li>计算bit=(offset mod 8)+1,bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位</li>
<li>根据byte值和bit值，在位数组bitarray中定位offset偏移量指定的二进制位，并返回这个值</li>
</ol>
<h2 id="SETBIT命令的实现"><a href="#SETBIT命令的实现" class="headerlink" title="SETBIT命令的实现"></a>SETBIT命令的实现</h2><p>setbit用于将位数组bitarray在offset偏移量上的二进制位的值设置为value,并向客户端返回二进制位被设置之前的旧值</p>
<p>以下是setbit命令的执行过程</p>
<ol>
<li>计算len=offset/8+1,len值记录了保存offset偏移量指定的二进制位至少需要多少字节</li>
<li>检查bitarray键保存的位数组SDS的长度是否小于len,如果是的话，将SDS的长度扩展为len字节，并将所有新扩展空间的二进制位的值设置为0</li>
<li>计算byte=[offset/8],byte值记录了offset偏移量指定的二进制位保存在位数组的哪个字节</li>
<li>计算bit=(offset mod 8)+1,bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位</li>
<li>根据byte值和bit值，在位数组bitarray中定位offset偏移量指定的二进制位，首先将指定二进制位现在值保存在oldvalue变量，然后将新值value设置为这个二进制位的值</li>
<li>向客户端返回oldvalue变量的值</li>
</ol>
<h2 id="BITCOUNT命令的实现"><a href="#BITCOUNT命令的实现" class="headerlink" title="BITCOUNT命令的实现"></a>BITCOUNT命令的实现</h2><p>bitcount命令用于统计给定位数组中，值为1的二进制的数量</p>
<h3 id="二进制位统计算法1：遍历算法"><a href="#二进制位统计算法1：遍历算法" class="headerlink" title="二进制位统计算法1：遍历算法"></a>二进制位统计算法1：遍历算法</h3><h3 id="二进制位统计算法2：查表算法"><a href="#二进制位统计算法2：查表算法" class="headerlink" title="二进制位统计算法2：查表算法"></a>二进制位统计算法2：查表算法</h3><p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/232.png"  alt="img"></p>
<h3 id="二进制位统计算法3：variable-precision-SWAR算法"><a href="#二进制位统计算法3：variable-precision-SWAR算法" class="headerlink" title="二进制位统计算法3：variable-precision SWAR算法"></a>二进制位统计算法3：variable-precision SWAR算法</h3><p>统计一个位数组中非0二进制位的数量，在数学上被称为计算汉明重量</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/233.png"  alt="img"></p>
<h3 id="二进制位统计算法4：Redis的实现"><a href="#二进制位统计算法4：Redis的实现" class="headerlink" title="二进制位统计算法4：Redis的实现"></a>二进制位统计算法4：Redis的实现</h3><p>BITCOUNT命令的实现用到了查表和variable-precisionSWAR两种算法</p>
<ul>
<li>查表算法使用键长为8为的表，表中记录了0000 0000到1111 1111在内的所有二进制位的汉明重复</li>
<li>SWAR算法方面，BITCOUNT命令在每次循环中载入128个二进制位，然后调用四次32位SWAR算法来计算128个二进制位的汉明重复</li>
</ul>
<p>在执行BITCOUNT命令时，程序会根据未处理的二进制位的数量来决定使用那种算法</p>
<ul>
<li>如果未处理的二进制位的数量大于等于128位，程序会使用SWAR算法来计算二进制位的汉明重复</li>
<li>如果未处理的二进制位的数量小于128位，那么程序使用查表算法来计算二进制位的汉明重复</li>
</ul>
<h2 id="BITOP命令的实现"><a href="#BITOP命令的实现" class="headerlink" title="BITOP命令的实现"></a>BITOP命令的实现</h2><p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/234.png"  alt="img"></p>
<p>bitop命令的所有操作都使用C语言内置的位操作实现</p>
<h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度</p>
<p>服务器配置有两个和慢查询日志相关的选项</p>
<ul>
<li>slowlog-log-slower-than选项指定执行时间超过多少微秒(1秒等于1000000微秒)的命令请求会被记录到日志上</li>
<li>slowlog-max-len选项指定服务器最多保存多少条慢查询日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;config set slowlog-log-slower-than 0</span><br><span class="line">redis&gt;config set slowlog-max-len 5</span><br><span class="line">redis&gt;slowlog get</span><br></pre></td></tr></table></figure>

<h2 id="慢查询记录的保存"><a href="#慢查询记录的保存" class="headerlink" title="慢查询记录的保存"></a>慢查询记录的保存</h2><p>服务器状态中包含了几个和慢查询日志功能有关的属性</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/235.png"  alt="img"></p>
<p>slowlog_entry_id属性的初始值为0，每当创建一条新的慢查询日志时，这个属性的值就会用作新日志的id值，之后程序会对这个属性的值增一</p>
<p>slowlog链表保存了服务器中的所有慢查询日志，链表中的每个节点都保存了一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/236.png"  alt="img"></p>
<h2 id="重点回顾-17"><a href="#重点回顾-17" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>Redis的慢查询日志功能用于记录执行时间超过指定时长的命令</li>
<li>Redis服务器将所有的慢查询日志都保存在服务器的slowlog链表中，每个链表节点都包含一个slowlogEntry结构，每个slowlogEntry结构代表一条慢查询日志</li>
<li>打印和删除慢查询日志可以通过遍历slowlog链表完成</li>
<li>slowlog链表的长度就是服务器所保存慢查询日志的数量</li>
<li>新的慢查询日志会被添加到slowlog链表的表头，如果日志的数量超过slowlog-max-len选项的值，那么多出来的日志会被删除</li>
</ul>
<h1 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h1><p>通过执行monitor命令，客户端可以将自己变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/237.png"  alt="img"></p>
<p>每当一个客户端向服务器发送给一条命令请求时，服务器除了会处理这条命令请求之外，还会将关于这条命令请求的信息发送给所有监视器</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/238.png"  alt="img"></p>
<h2 id="成为监视器"><a href="#成为监视器" class="headerlink" title="成为监视器"></a>成为监视器</h2><p>发送monitor命令可以让一个普通客户端变为一个监视器</p>
<p>如果客户端c10086向服务器发送monitor命令，那么这个客户端的redis-monitor标志会被打开，并且这个客户端本身会被添加到monitors链表的末尾</p>
<p><img src="/" class="lazyload" data-src="/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/239.png"  alt="img"></p>
<h2 id="向监视器发送命令信息"><a href="#向监视器发送命令信息" class="headerlink" title="向监视器发送命令信息"></a>向监视器发送命令信息</h2><p>服务器在每次处理命令请求之前，都会调用replicationFeedMonitors函数，由这个函数将被处理的命令请求的相关信息发送给各个监视器</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">李上</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">http://yoursite.com/2020/06/29/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">定不辱使命</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/02/rocketmq/"><img class="prev_cover lazyload" data-src="/img/rocketmq.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RocketMQ学习笔记</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/23/kafka/"><img class="next_cover lazyload" data-src="/img/kafka.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">kafka学习笔记</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 李上</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>