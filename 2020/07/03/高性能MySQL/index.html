<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《高性能MySQL》读书笔记 | 定不辱使命</title><meta name="description" content="《高性能MySQL》读书笔记"><meta name="author" content="李上"><meta name="copyright" content="李上"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《高性能MySQL》读书笔记"><meta name="twitter:description" content="《高性能MySQL》读书笔记"><meta name="twitter:image" content="http://yoursite.com/img/highmysql.jpg"><meta property="og:type" content="article"><meta property="og:title" content="《高性能MySQL》读书笔记"><meta property="og:url" content="http://yoursite.com/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/"><meta property="og:site_name" content="定不辱使命"><meta property="og:description" content="《高性能MySQL》读书笔记"><meta property="og:image" content="http://yoursite.com/img/highmysql.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/"><link rel="prev" title="JVM学习笔记" href="http://yoursite.com/2020/07/03/jvm/"><link rel="next" title="RocketMQ学习笔记" href="http://yoursite.com/2020/07/02/rocketmq/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql的架构与历史"><span class="toc-number">1.</span> <span class="toc-text">Mysql的架构与历史</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL高级特性"><span class="toc-number">2.</span> <span class="toc-text">MySQL高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分区表"><span class="toc-number">2.1.</span> <span class="toc-text">分区表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分区的原理"><span class="toc-number">2.1.1.</span> <span class="toc-text">分区的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分区表的类型"><span class="toc-number">2.1.2.</span> <span class="toc-text">分区表的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#视图"><span class="toc-number">2.2.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可更新视图"><span class="toc-number">2.2.1.</span> <span class="toc-text">可更新视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图对性能的影响"><span class="toc-number">2.2.2.</span> <span class="toc-text">视图对性能的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图的限制"><span class="toc-number">2.2.3.</span> <span class="toc-text">视图的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外键约束"><span class="toc-number">2.3.</span> <span class="toc-text">外键约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在MySQL内部存储代码"><span class="toc-number">2.4.</span> <span class="toc-text">在MySQL内部存储代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#存储过程和函数"><span class="toc-number">2.4.1.</span> <span class="toc-text">存储过程和函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#游标"><span class="toc-number">2.5.</span> <span class="toc-text">游标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全文索引"><span class="toc-number">2.6.</span> <span class="toc-text">全文索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式-XA-事务"><span class="toc-number">2.7.</span> <span class="toc-text">分布式(XA)事务</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/highmysql.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">定不辱使命</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">《高性能MySQL》读书笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-03 09:26:09"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-03</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-20 13:17:42"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-20</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>第一章：Mysql的架构与历史</p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={A77A36AC-1CF5-4D6B-8E60-4FCED8BFCD0D}&29&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.1mysql的逻辑架构：</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={DEF41E91-C38A-4346-9E88-DC4444B0FA3B}&2A&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.1.1连接管理与安全性</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={DEF41E91-C38A-4346-9E88-DC4444B0FA3B}&36&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.12优化与执行</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={DEF41E91-C38A-4346-9E88-DC4444B0FA3B}&4B&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.2并发控制</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={DEF41E91-C38A-4346-9E88-DC4444B0FA3B}&51&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.2.1读写锁</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={6E4EC7F7-048E-4742-84C2-5D48DD303697}&17&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.2.2锁粒度：锁定的范围大小</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={EC736589-0220-485E-ABEA-7FFC8A8F206B}&F&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.3事务</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={EC736589-0220-485E-ABEA-7FFC8A8F206B}&36&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.3.1隔离级别;较低级别的隔离通常可以执行更高的并发，系统的开销也更低</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={22E5736E-270E-463C-9BA6-5B6CA1E224FE}&51&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.3.2死锁</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={22E5736E-270E-463C-9BA6-5B6CA1E224FE}&70&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.3.3事务日志</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={22E5736E-270E-463C-9BA6-5B6CA1E224FE}&82&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.3.4mysql中的事务</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={22E5736E-270E-463C-9BA6-5B6CA1E224FE}&AF&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.4多版本并发控制</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={22E5736E-270E-463C-9BA6-5B6CA1E224FE}&E3&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.5Mysql的存储引擎</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={22E5736E-270E-463C-9BA6-5B6CA1E224FE}&EE&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.5.1InnoDB存储引擎</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={0AFC7F0A-E498-4ABF-8AF3-FD34D3E5905F}&14&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.5.2MyISAM存储引擎</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={0AFC7F0A-E498-4ABF-8AF3-FD34D3E5905F}&37&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.5.5选择合适的引擎</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={0AFC7F0A-E498-4ABF-8AF3-FD34D3E5905F}&41&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.5.6转换表的引擎</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={0AFC7F0A-E498-4ABF-8AF3-FD34D3E5905F}&78&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">1.8总结</a></p>
<p>第二章：Mysql基准测试，这一章主要是要弄懂Jmeter,sysbeach的使用？？</p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={0AFC7F0A-E498-4ABF-8AF3-FD34D3E5905F}&C6&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">2.2基准测试的策略</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={0AFC7F0A-E498-4ABF-8AF3-FD34D3E5905F}&DC&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">2.2.1测试何种指标</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={0AFC7F0A-E498-4ABF-8AF3-FD34D3E5905F}&E9&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">2.3基准测试常见错误</a></p>
<p>第三章：服务器性能剖析</p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={FAEFC2A7-AD49-4CCE-8FCC-15669474D851}&10&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">3.1性能优化简介：围绕响应时间来探讨</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={371BB273-114D-4835-A500-940AB45DF5E8}&F&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">3.6总结</a></p>
<p>第四章：schema与数据类型优化</p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={371BB273-114D-4835-A500-940AB45DF5E8}&1B&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.1选择优化的数据类型</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={371BB273-114D-4835-A500-940AB45DF5E8}&58&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.1.1整形类型</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={371BB273-114D-4835-A500-940AB45DF5E8}&72&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.1.2实数类型：带有小数部分的数字，包括浮点型double,float和decimal</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={371BB273-114D-4835-A500-940AB45DF5E8}&99&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.1.3字符串类型</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={5DFC94CF-900D-41DC-A004-FAFF5502B747}&97&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.1.4日期和时间类型</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={33F5D0B3-30D3-44B0-87AA-BB9929D9C97C}&61&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.1.5位数据类型</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={33F5D0B3-30D3-44B0-87AA-BB9929D9C97C}&E3&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.1.6选择标识符</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={66206B41-2A89-4044-AFF2-A32263C66BE7}&25&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.1.7特殊类型数据</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={66206B41-2A89-4044-AFF2-A32263C66BE7}&6A&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.2Mysql schema 设计中的陷阱</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={66206B41-2A89-4044-AFF2-A32263C66BE7}&AD&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.3范式和反范式</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={FC885F03-B997-4654-8012-179023CC0916}&82&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.3.1范式的优点与缺点</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={FC885F03-B997-4654-8012-179023CC0916}&73&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.3.2反范式的优点和缺点</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={FC885F03-B997-4654-8012-179023CC0916}&C1&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.4.1物化视图</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={FC885F03-B997-4654-8012-179023CC0916}&C5&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.4.2计数器表</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={FC885F03-B997-4654-8012-179023CC0916}&D1&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.5加快alter table操作的速度</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={9D1C1B2C-F7A1-411F-BD5C-53A070EDF0E8}&1A&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.5.1只修改.frm文件</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={9D1C1B2C-F7A1-411F-BD5C-53A070EDF0E8}&57&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.5.2快速创建MyISAM索引</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={9D1C1B2C-F7A1-411F-BD5C-53A070EDF0E8}&8B&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">4.6总结</a></p>
<p>第五章：创建高性能的索引</p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={69975388-3C5D-4CC8-8267-7BF9C048FB2E}&B&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.1索引基础</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={69975388-3C5D-4CC8-8267-7BF9C048FB2E}&1E&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.1.1索引的类型</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={AA0ABFBA-C538-40CE-A64D-B53BB354DFB8}&8B&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.2索引的优点</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={AA0ABFBA-C538-40CE-A64D-B53BB354DFB8}&A1&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.3.1独立的列</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={AA0ABFBA-C538-40CE-A64D-B53BB354DFB8}&C8&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.3.2前缀索引和索引选择性</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={AA0ABFBA-C538-40CE-A64D-B53BB354DFB8}&D0&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.3.3多列索引</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={67F0A81F-BFF8-4AAF-A939-D96CE821202B}&82&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.3.4选择合适的索引列顺序</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={4575A23A-3448-4419-83B2-03D40D36272C}&E&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.3.5聚簇索引</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={4575A23A-3448-4419-83B2-03D40D36272C}&50&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.3.6覆盖索引</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={4575A23A-3448-4419-83B2-03D40D36272C}&98&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.3.7使用索引扫描来做排序</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={4575A23A-3448-4419-83B2-03D40D36272C}&C1&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.3.8压缩（前缀压缩）索引</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={4575A23A-3448-4419-83B2-03D40D36272C}&CA&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.3.9冗余和重复索引</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={4575A23A-3448-4419-83B2-03D40D36272C}&F5&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.3.11索引和锁</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={AC21FE04-41BA-4798-87FF-42F48D30B0C9}&3D&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.4索引案例学习</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={AFD63F28-950B-4CBF-8C15-AA8E81517192}&7F&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.4.3优化排序</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={AFD63F28-950B-4CBF-8C15-AA8E81517192}&C0&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.5维护索引和表</a></p>
<p><a href="onenote:#第一章：Mysql的架构与历史&section-id={C836C760-D3A9-4AB6-A451-065FD719E75F}&page-id={9AAA72BD-6B47-41A0-B914-959460356869}&object-id={806B5447-8E9C-404D-B480-173DA5B459E8}&3B&base-path=https://d.docs.live.net/f1caa3b5ca97fabc/文档/SQL/《高性能mysql》读书笔记.one">5.6总结</a></p>
<p>第六章：查询性能优化</p>
<h1 id="Mysql的架构与历史"><a href="#Mysql的架构与历史" class="headerlink" title="Mysql的架构与历史"></a>Mysql的架构与历史</h1><p>1.1mysql的逻辑架构：</p>
<p>mysql数据库主要分为三层架构</p>
<p>1.上层服务，非mysql独有，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构，比如连接处理</p>
<p>2.第二层是mysql所有的跨存储引擎的功能所在的一层，比如查询，分析，优化，缓存，内置函数，存储过程，触发器，视图等</p>
<p>3.第三层主要是存储引擎，存储引擎负责数据的存储和提取，每个存储引擎 都有其优劣势。服务器通过api和存储引擎通讯，这些接口屏蔽了存储引擎之间的差异。存储引擎之家不会相互通讯，只会响应上层服务器的请求</p>
<p>存储引擎不会解析SQL,INNDB例外，它会解析外键定义，因为MYSQL</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png"  alt="客 户 端  巛 连 接 / 线 程 处 理  存 储 引 擎 "></p>
<p>1.1.1连接管理与安全性</p>
<p>连接管理：</p>
<p>每个客户端连接都会在服务器进程中拥有一个线程，这个连接的所有操作都只会在这个单独的线程中进行，服务器会维护一个线程池，以便灵活应对线程的增加，用少量的线程服务大量的连接</p>
<p>安全性：</p>
<p>服务器通过客户端的用户名，原始主机信息和密码来认证</p>
<p>如果使用安全套接字(SSL)连接，还可以使用X.509证书认证</p>
<p>连接成功后，服务器还会检测客户端是否拥有某个具体操作的权限</p>
<p>1.12优化与执行</p>
<p>优化器并不关心表使用的是什么存储引擎，但是存储引擎对于优化查询是有影响的，存储引擎的某种索引可能对特定的查询有优化</p>
<p>对于select语句，解析查询前，服务器会先检查缓存中是否有对应查询，避免资源浪费</p>
<p>1.2并发控制</p>
<p>当有多个查询需要在同一时刻修改数据，就会产生并发控制问题。通过上锁的方式可以解决并发对数据的影响，但是在大并发量的系统中上锁影响用户体验</p>
<p>1.2.1读写锁</p>
<p>简而言之,读锁会堵塞写，但是不会阻塞读；写锁则会把读和写都堵塞</p>
<p>1.2.2锁粒度：锁定的范围大小</p>
<p>为了提高并发性，只对会修改的数据片进行精确的锁定。锁也是会消耗资源的，不能肆无忌惮的使用锁</p>
<p>锁策略：</p>
<p>表锁：读写锁都是属于表锁，存储引擎会管理自己的锁，但是服务器会为诸如alter table之类的语句使用表锁，忽略存储引擎的锁机制</p>
<p>写锁的优先级高于读锁，一个写锁请求很有可能被插入到读锁前面执行</p>
<p>行级锁：最大程度的支持并发，但是也带来了最大的锁开销。行级锁只在存储引擎层实现，</p>
<p>1.3事务</p>
<p>事务就是一组原子性的sql查询，一个独立的工作单元，内部的sql语句要么全部执行，要么全不执行</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image002.png"  alt="1  2  3  4  5  START TRANSACTION;  SELECT balance checking WHERE customer_id 10233276;  UPDATE checking SET balance balance - 200.00 WHERE customer id 10233276;  UPDATE savings SET balance = balance + 200.00 WHERE customer¯id 10233276; "></p>
<p>ACID：</p>
<p>原子性(atomicity)：一个事务必须被视为一个不可分割的最小工作单元，要么全部成功，要么全部失败</p>
<p>一致性(consistency):数据库总是从一个一致性状态转换到另一个一致性状态。只有最初状态和结束状态对外可见，中间的过程状态对外是不可见的</p>
<p>隔离性(isolation)：一个事务所做的修改在最终提交以前，对其他事务是不可见的</p>
<p>持久性(durability)：一旦事务提交，则其所做的所有修改都会永久的保存到数据库中</p>
<p>实现了ACID的数据库对硬件的要求会增大，可以根据业务需求来选择不同的存储引擎，对于不需要事务的查询类应用，可以选择非事务型的存储引擎</p>
<p>1.3.1隔离级别;较低级别的隔离通常可以执行更高的并发，系统的开销也更低</p>
<p>事务并发问题：</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png"  alt="》 脏 读 ： 对 于 两 个 事 务 Tl ， T2 ， Tl 读 取 了 己 经 被 T2 更 新 但 还 没 有 被 提 交 的 字 段 ．  之 五 若 T2 回 滚 ， Tl 读 取 的 内 容 就 是 临 时 且 无 效 的 ．  》 不 可 重 复 读 ． 对 于 两 个 事 务 Tl ， T2 ， Tl 读 取 了 一 个 字 段 ， 然 后 T2 更 新 了 该 字 段 ．  之 后 ， Tl 再 次 读 取 同 一 个 字 段 ， 值 就 不 同 了 ．  》 幻 读 ： 对 于 两 个 事 务 Tl ， T2 ， Tl 从 一 个 表 中 读 取 了 一 个 字 段 ， 然 后 T2 在 该 表 中 插  入 了 一 些 新 的 行 ． 之 后 ， 如 果 Tl 再 次 读 取 同 一 个 表 ， 就 会 多 出 几 行 ． "></p>
<p>Read uncommitted(未提交读，其他事务可见)：</p>
<p>允许事务读取未被其他事务提交的数据，脏读，不可重复读和幻读的问题都会出现（性能不高，安全性极差，基本不使用）</p>
<p>Read committed(提交读，不可重复读):</p>
<p>只允许事务读取已经被其他事务提交的变更，满足隔离性。连续两次读取的数据可能不一样，会有不可重复读并发问题</p>
<p>Repeatable read(可重复读，mysql 的默认隔离级别):</p>
<p>确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新，但是可以插入新的行</p>
<p>Serializable(可串行化):</p>
<p>确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有的并发问题都可以避免，但性能十分低下，只有在非常需要确保数据的一致性而且可以接收没有并发的情况下才会使用</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image004.png"  alt="计算机生成了可选文字: 隔离级别 READUNCOMMITTED READCOMMITTED REPEATABLEREAD SERIALIZABLE 脏读可能性 Yes 不可重复读可能性 Yes Yes 幻读可能性 Yes Yes Yes 加锁读 NO"></p>
<p>1.3.2死锁</p>
<p>两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致的恶性循环的现象</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image005.png"  alt="START TRANSACTION;  UPDATE stockPrice SET close - 45.50 HERE stock id - 4 and date -  UPDATE stockPrice SET close 19.80 HERE stock_id • 3 and date •  &#39;2002-05-01&#39; ;  &#39;2002-05-02&#39; ;  START TRANSACTI&quot;&#39;;  UPDATE stockPrice SET high  UPDATE StockPrice SET high  • 20.12 &quot;RE stock id 3 and date &#39;2m2-05 02  47.20 &quot;RE stock _ id • 4 and date • "></p>
<p>死锁会导致非常慢的查询，数据库实现了各种死锁检测和死锁超时机制。InnoDB处理死锁的方式是将持有最少行级排他锁的事务进行回滚</p>
<p>死锁产生的原因除了真正的数据冲突以外，有些则是因为存储引擎的实现方式导致的</p>
<p>事务型的系统，程序设计时必须考虑如何处理死锁，大多数情况下只需要重新执行因死锁回滚的事务即可</p>
<p>1.3.3事务日志</p>
<p>事务日志可以提高事务的效率，事务日志持久化以后，内存中被修改的数据在后台可以慢慢的刷回到磁盘</p>
<p>事务日志采用的是追加的方式，写事务日志的操作时磁盘上的一小块固定区域，而不是随机I/O需要在磁盘的多个地方移动磁头</p>
<p>1.3.4mysql中的事务</p>
<p>mysql提供两种事务型的存储引擎：InnoDB,NDB Cluster。第三方知名的有XtraDB，PBXT</p>
<p>mysql默认采用自动提交模式，如果不显示地开始一个事务，则每个查询都被当做一个事务执行，可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式，1代表ON,O代表OFF</p>
<p>有一些命令执行之前会强制执行commit提交当前的活动事务，比如alter table</p>
<p>隐式和显示锁定</p>
<p>锁定只有在执行commit,rollback的时候才会释放，隔离级别中自动上的锁时隐式的</p>
<p>mysql支持热顶的语句进行显示锁定（最好不用，不属于sql规范）：</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image006.png"  alt="•  SELECT  SELECT  LOCK IN SHARE OE  Fm UPDATE "></p>
<p>mysql在服务器层实现了lock tables和unlock tables语句，但是这些语句和存储引擎无关，会影响性能</p>
<p>除了事务中禁用autocommit外，不能使用lock tables(避免死锁)，因为lock tables会和事务相互影响</p>
<p>1.4多版本并发控制</p>
<p>Mysql的大多数事务型存储引擎实现的都不是简单的行级锁，而是基于提升并发性能的考虑，实现了多版本并发控制MVCC</p>
<p>MVCC是行级锁的一个变种，它在很多情况下避免了加速操作，大多都实现了非阻塞的读操作，写操作只锁定必要的行</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image007.png"  alt="计算机生成了可选文字: MVCQÄ现，通过保存数据在某个时间点的快照来实现的。这意味巷一个事务无论运行多长时间， 在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味巷在同一个时刻不 同事务看到的相同表里的数据可能是不同的。"></p>
<p>典型的MVCC有乐观，悲观并发控制</p>
<p>实现原理：在每行记录的后面保存两个隐藏的列来实现的，一个是创建时间，一个是过期时间，时间都是用版本号代替的。每开始一个事务，系统版本号就会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image008.png"  alt="InnoDB 会 根 据 以 下 两 个 条 件 检 查 每 行 记 录 ：  a.InnoDB 只 查 找 版 本 早 于 当 前 事 务 版 本 的 数 据 行 （ 也 就 是 ， 行 的 系 统 版 本 号 小  于 或 等 于 事 务 的 系 统 版 本 号 ） ， 这 样 可 以 确 保 事 务 读 取 的 行 ， 要 么 是 在 事 务 开  始 前 已 经 存 在 的 ， 要 么 是 事 务 自 身 插 人 或 者 修 改 过 的 。  b. 行 的 删 除 版 本 要 么 未 定 义 ， 要 么 大 于 当 前 事 务 版 本 号 ． 这 可 以 确 保 事 务 读 取 到  的 行 ， 在 事 务 开 始 之 前 未 被 除 ·  只 有 符 合 上 述 两 个 条 件 的 记 录 ， 才 能 返 回 作 为 查 询 结 果 。  INSERT  InnoDB 为 新 插 人 的 每 一 行 保 存 当 前 系 统 版 本 号 作 为 行 版 本 号 ·  InnoDB 为 涨 除 的 每 一 行 保 存 当 前 系 统 版 本 号 作 为 行 删 除 标 识 。  InnoDB 为 插 人 一 行 新 记 录 ， 保 存 当 前 系 统 版 本 号 作 为 行 版 本 号 ， 同 时 保 存 当 前 系 统  版 本 号 到 原 来 的 行 作 为 行 删 除 标 识 。 "></p>
<p>保存这两个额外的版本号，那么大多数读操作都可以不用加锁</p>
<p>MVCC只在repeatable read 和read committed两个隔离级别下工作，其他两个级别都和mvcc不兼容</p>
<p>1.5Mysql的存储引擎</p>
<p>tableName.frm:保存表的定义</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png"  alt="user :  mysql&gt; Su TABLE STATUS LIKE  Name:  user  Engine.  • mylSM  Row_format : Dynamic  RNS :  : 59  Data length.  • 356  : 4294967295  Index_length  : 2048  Data free:  Auto_i Gent  : WLL  Create time  Check time:  Collation  Checksm  Create_opt ions :  •user&#39;  : 2002-01-24  Update_time: 2002-01-24 21:56:29  WLL  : utf8 bin  C.ent: Users and global privileges  i in set (高性能MySQL.assets/clip_image009.png) "></p>
<p>1.5.1InnoDB存储引擎</p>
<p>被设计用来处理大量短期事务，短期事务大部分是正常提交的，很少会被回滚，InnoDB的性能和自动崩溃恢复特性使得其在非事务型存储的需求中也很流行</p>
<p>InnoDB采用MVCC来支持高并发，通过间隙锁策略防止幻读的出现，间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻读行的插入</p>
<p>InnoDB表是基于聚簇索引建立的，InnoDB的索引结构和其他存储引擎有很大的区别，聚簇索引对主键查询有很高的性能，不过它的二级索引（非主键索引）中必须包含主键列。主键列很大的话，其他的索引也会很大，所以如果表上的索引较多的话，主键应当尽可能的小。</p>
<p>1.5.2MyISAM存储引擎</p>
<p>MyISAM不支持事务和行级锁，崩溃后无法安全恢复</p>
<p>MyISAM将表存储在数据文件.MYD和索引文件.MYI中</p>
<p>MyISAM压缩表是只读的，要想写入必须先解压，压缩表能够减少磁盘I/O,提高性能</p>
<p>1.5.5选择合适的引擎</p>
<p>除非需要使用到某些InnoDB不具备的特性，并且没有其他办法可以替代，否则都应该优先选择InnoDB引擎</p>
<p>除非万不得已，不要混合使用多种存储引擎，会带来一些列的复杂问题</p>
<p>1.5.6转换表的引擎</p>
<p>方法一：Alter Table</p>
<p>执行时间长，mysql会及那个原表复制到一张新表中，复制期间大量占用资源且原表会加上读锁，转换后会丢失原存储引擎的所有特性</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image010.png"  alt="img"></p>
<p>方法二：导入与导出</p>
<p>使用mysqldump工具将数据导出到文件，然后修改文件中的Create table的存储引擎选项</p>
<p>注意表名也需要修改且注意mysqldump会自动加上Drop Table，避免数据丢失</p>
<p>方法三：创建与查询</p>
<p>创建一个新表，再做查询插入</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image011.png"  alt="img"></p>
<p>1.8总结</p>
<p>mysql拥有分层架构，上层是服务器层的服务和查询执行引擎，下层则是存储引擎</p>
<p>理解MYSQL在存储引擎和服务层之间处理查询时如何通过API来回交互，就能抓住MYSQL的核心</p>
<p>2.2基准测试的策略</p>
<p>基准测试是针对系统设计的一种压力测试，sysbench是一款优秀的基准测试工具</p>
<p>策略一：集成式，针对整个系统的整体测试</p>
<p>Jmeter,Http_load,Ab:测试HTTP服务器每秒最多可以处理多少请求</p>
<p>策略二: 单组件式，单独测试mysql</p>
<p>Sysbench:多线程压测工具，可以根据数据库服务器性能的各种因素来评估系统性能</p>
<p>策略三：mysql的Benchmark()函数</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png"  alt="mysql&gt; SET unput &#39;hello ørld&#39;;  mysql&gt; SELECT BENCHNRX(高性能MySQL.assets/clip_image012.png);  I BENO-AARK(10000cn, I  01  1 in set (2.78 sec)  nysql&gt; SELECT BENONRX(IÄOO,  I BENCNRK(touoo, SHAI(unput)) I  1 in set (3.50 sec) "></p>
<p>这个函数只涉及服务器执行表达式的时间，而不会涉及分析和优化的开销</p>
<p>表达式必须包含用户定义的变量，否则多次执行同样的表达式会因为系统缓存命中而影响结果</p>
<p>2.2.1测试何种指标</p>
<p>吞吐量：单位时间内的事务处理数，常见的测试单位是每秒事务数（TPS）</p>
<p>响应时间或者延迟：任务所需的整体时间</p>
<p>并发性：单位时间内有多少同时发生的并发请求</p>
<p>可扩展性：并发请求增加的过程中，吞吐量能否也线性的增长</p>
<p>2.3基准测试常见错误</p>
<p>常见错误：</p>
<p>1.使用错误的数据分布</p>
<p>2.使用不真实的分布参数，比如假定所有用户的个人信息都会被平均的读取</p>
<p>3.多用户场景，只做单用户的测试</p>
<p>4.与真实用户行为不匹配</p>
<p>5.反复执行同一个查询，这会导致缓存命中概率提高</p>
<p>6.没有检查错误，基准测试完成后，一定要检查一下错误日志</p>
<p>7.忽略了系统预热的过程，系统刚重启，缓存是空的，这时测试是不准的</p>
<p>8.使用默认的服务器配置</p>
<p>9.测试时间太短，基准测试需要持续一定的时间</p>
<p>10.基于mysql的默认配置的测试没有什么意义，因为默认配置是基于消耗很少内存的极小应用的</p>
<p>11.尽可能的使测试过程自动化，包括装载数据，系统预热，执行测试，记录结果等</p>
<p>3.1性能优化简介：围绕响应时间来探讨</p>
<p>响应时间度量性能，在一定的工作负载下尽可能地降低响应时间</p>
<p>无法策测量就无法优化，第一步应该弄清楚时间花在什么地方，如果测量到系统中完整且正确的数据，性能问题一般都能暴露出来</p>
<p>由此可知不合适的测量会导致分析出错：</p>
<p>1.在错误的时间启动和停止测量</p>
<p>2.测量的是聚合后的信息，而不是目标活动本身</p>
<p>慢查询日志：捕获比较慢的查询</p>
<p>方法一：show status</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image013.png"  alt="计算机生成了可选文字: mysql&gt;FLUSHSTATUS; mysql&gt;SELECT率sakila.nicerbut51艹rfilmlist; [queryresultsomitted] mysql&gt;SHSTATUSHEREVariable_nameLIKE&#39;Handler&#39; 佩VariablenameLIKE&#39;CreatedX&#39; 《0 Variablename Created_tmp_disktables |Created_tmp_files Createdtmp_tables Handlercommit 《Handlerdelete Handlerdiscover Handler_prepare Handlerreadfirst Handlerreadkey Handlerreadnext Handlerread_prev Handlerreadrnd Handlerreadrndnext Handlerrollback Handler_savepoint Handler_savepointrollback Handlerupdate Handlerwrite 《Value| 《7483 6462 《5462 《6478 6459"></p>
<p>剖析结果：</p>
<p>1.该查询使用了三个临时表，其中两个是磁盘临时表</p>
<p>2.该属性代表未使用索引的读操作，数字过大很有可能是多表关联的join操作产生的临时表没有索引导致的</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image014.png"  alt="img"></p>
<p>3.show status操作本身就会创建临时表</p>
<p>4.explain的结果是通过估算得到的，而show status是通过实际情况计数得出的，且后者详细一些</p>
<p>方法二：show profile</p>
<p>了解查询的每个环节所花费的时间</p>
<p>方法三：检查慢查询日志</p>
<p>可以查看那条查询语句超时了</p>
<p>3.6总结</p>
<p>1.定义性能最有效的方法是响应时间</p>
<p>2.无法测量就无法优化，性能的优化依赖于高质量的响应时间测量</p>
<p>3.即使问题出在底层的数据库，最佳的测量开始点也是应用程序，而不是数据库</p>
<p>4.1选择优化的数据类型</p>
<p>选择正确的数据类型对于获得高性能至关重要</p>
<p>1.更小的通常更好，更小的数据类型通常更快，因为它们占用更少的硬盘，内存，cpu缓存，处理时需要的cpu周期也更少</p>
<p>2.简单就好，简单数据类型的操作通常需要更少的cpu周期，整形比字符操作代价更低</p>
<p>因为字符集和校对规则(排序规则)使字符比较比整形比较更复杂</p>
<p>存储时间用mysql内建的类型date,datetime等，不要用字符串</p>
<p>存储ip地址应该用整形数据类型</p>
<p>3.尽量避免NULL,通常情况下最好指定列未NOT NULL，除非真的需要存储NULL值</p>
<p>有NULL的列会使得索引，索引统计和值比较都更复杂</p>
<p>有NULL的列会占用更多的空间，在MYSQL里也需要特殊处理</p>
<p>当有NULL的列被索引时，每个索引记录需要一个额外的字节，在MyISAM里甚至可能导致固定大小的索引变成可变大小的索引</p>
<p>InnoDB使用单独的位bit存储NULL值，对于系数数据有很好的空间效率，但这一点不适用于MyISAM</p>
<p>4.DATETIME和TIMESAMP都可以存储相同类型的数据：时间，日期精确到秒</p>
<p>TIMESAMP只使用DATETIME一般的存储空间，并且会根据时区变化，具有自动更新能力</p>
<p>TIMESAMP允许的时间范围要小得多</p>
<p>5.INTEGER，BOOL，NUMERIC都是别名，用show create table检查，会发现MySQL报告的是基本类型</p>
<p>4.1.1整形类型</p>
<p>整数</p>
<p>Tinyint</p>
<p>Smallint</p>
<p>Mediumint</p>
<p>Int</p>
<p>bigint</p>
<p>分别使用8，16，24，32，64位存储空间，存储范围从-2^(n-1)到2^(n-1)</p>
<p>unsigned不允许使用负值，可以使正数的上限提高一倍tinyint,unsigned可以存储的范围是0-255，而tinyint得存储范围是-128-128</p>
<p>整数类型可以指定宽度，类如INT(11),这并不会限制其合法范围，只会限制显示字符的个数</p>
<p>选择的只是存储类型，mysql使用bigint作为内部整形计算的类型</p>
<p>4.1.2实数类型：带有小数部分的数字，包括浮点型double,float和decimal</p>
<p>Double,float,decimal类型都可以指定精度，mysql将数字打包到一个二进制字符串中，每4个字节存9个数字</p>
<p>DECIMAL(18,9)小数点两边将各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点用一个字节</p>
<p>DECIMAL类型最多存储65个数字</p>
<p>建议只指定数据类型，不指定精度</p>
<p>float占用4个字节，double占用8个字节和整形一样，能选择的只是存储类型，mysql使用double作为内部浮点计算的类型</p>
<p>Flaot,double不能用于精确计算，decimal可以，只是后者占用资源大，需要额外的空间和计算开销，所以尽量只在对小数进行精确计算时才使用</p>
<p>DECIMAL——例如存储财务数据，在数据量比较大时，可以考虑使用bigint代替decimal，</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image015.png"  alt="DECIMAL, 将 需 要 存 储 的 货 币 单 位 根 据 小 数 的 位 数 乘 以 相 痖 的 倍 数 即 可 ·  务 数 倨 精 确 到 万 分 之 一 分 ， 则 可 以 把 所 有 金 束 以 一 白 力 · 然 后 将 结 果 存 储 在 机 GI 耵 里 ，  这 样 可 以 同 时 避 免 浮 点 存 储 计 算 不 精 确 和 DECIt•%L 精 确 计 算 代 价 高 的 问 题 。 "></p>
<p>4.1.3字符串类型</p>
<p>Varchar和char类型</p>
<p>存储引擎存储以上两种类型的数据在内存和磁盘上的方式可能不一样</p>
<p>以上两种类型指定的长度是真的限定了数据的长度范围，定义的是字符数而不是字节数</p>
<p>varchar</p>
<p>varchar用来存储可变长字符串，比定长类型更节省空间，需要使用1或者2个额外字节记录字符串的长度，列的长度小于等于255字节时，使用一个字节表示长度，否则使用2个字节</p>
<p>字符串类型的长度设定限制的是字符长度而已，实际存储过程中，一个中文字符占两个字节，一个英文字符占一个字节</p>
<p>varchar的长度是可变的，在update时可能使行变得比原来长，这就导致需要做额外的工作</p>
<p>如果一个行占用的空间增长，并且在页内没有更多的空间可以存储</p>
<p>MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内</p>
<p>以下情况使用varchar是合适的:</p>
<p>1.字符串列的最大长度比平均长度大的多</p>
<p>2.列的更新很少，碎片不是问题</p>
<p>3.使用像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储</p>
<p>mysql在存储和检索时会保留末尾空格，InnoDB可以把过长的varchar存储为BLOB</p>
<p>Char</p>
<p>mysql会删除所有的末尾空格，char值会根据需要采用空格进行填充以方便比较</p>
<p>char适合存储很短的字符串，或者所有值都接近同一个长度，非常适合存储密码的MD5值，因为这是一个定长的值，且经常改变，产生的碎片少</p>
<p>对于非常短的列，char的存储效率优于varchar</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png"  alt="CHAR 类 型 的 这 些 行 为 可 能 有 一 点 难 以 理 解 ． 下 面 通 过 一 个 具 体 的 例 子 来 说 明 。 首 先 ， 我  们 创 建 一 张 只 有 一 个 OH(18) 字 段 的 表 并 且 往 里 面 插 人 一 些 值 ：  mysql&gt; 巛 TE 涨 £ char test( char 0 厭 （ );  ， 5q1 &gt; 1 适 E 盯 № r test(char （ 01 ） VALUES  当 检 索 这 些 值 的 时 候 · 会 发 现 st 3 末 尾 的 空 格 被 截 断 了 。  mysql&gt; L 伽 耵 C “ ， &#39; 01 ， - “ ） 阝 char_test;  0 stringl&#39;  0 stringy  《 •string3&#39;  如 果 用 v 0 （ 1 劬 字 段 存 储 相 同 的 值 ， 可 以 得 到 如 下 结 果 “ ：  mysql&gt; 仃 （ 耵 (• 骘 “ r “ ． “ 1 ， “ 勹 阝 咿 varchar-test;  《 （ CAT(&quot; 骘 varchar-col, &quot; “ 归  《 &#39;stringl&#39;  《 ． st 吨 2 "></p>
<p>数据如何存储取决于存储引擎，不同的存储引擎存储数据的方式会有差异</p>
<p>填充和截取空格的行为在不同的存储引擎都是一样的，因为这是在mysql服务器层进行处理的</p>
<p>与char,varchar类似的还有binary,varbinary，存储的是二进制字符串，二进制字符串存储的是字节码而不是字符，mysql填充binary采用的是\0（零字节）而不是空格，在检索时也不会去掉填充值。</p>
<p>慷慨是不明智的，最好的策略是只分配真正需要的空间</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image017.png"  alt="事 实 证 明 有 很 大 的 优 势 · 更 长 的 列 会 消 耗 更 多 的 内 存 ， 因 为 MySQL 通 常 会 分 配 田  定 大 小 的 内 存 块 来 保 存 内 部 值 · 咒 其 是 使 用 内 存 时 表 进 行 排 序 或 搡 作 时 会 特 别 糟  。 在 利 用 众 临 时 表 进 行 排 序 时 也 同 样 糟 。 "></p>
<p>BLOB,TEXT类型</p>
<p>mysql为存储很大的数据而设计的字符串类型，分别采用二进制和字符串的方式存储</p>
<p>Blob:tinyblob,smallblob,blob,mediumblob,longblob</p>
<p>Text:tingtext,smalltext,text,mediumtext,longtext</p>
<p>blob是smallblob的同义词，text是smalltext的同义词（没有smallblob,smalltext）</p>
<p>mysql把blob,text的值当做一个独立的对象处理，存储引擎在存储时通常会做特殊处理，当blob和text值太大时，InnoDB会使用专门的外部存储区域来进行存储，此时每个值在行内需要1-4个字节存储一个指针，然后在外部存储区域存储实际的值</p>
<p>blob与text家族唯一的区别就是存储数据的形式不同，前者没有排序规则和字符集，后者有</p>
<p>mysql不能将blob和text列全部长度的字符串进行索引，也不能使用这些索引消除排序</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image018.png"  alt="MYSQL 对 BLOB 和 TEXT 列 进 行 悱 序 与 其 他 类 型 是 不 同 的 ： 它 只 对 每 个 列 的 最 前 max  sort_tength 字 苓 而 不 是 整 个 字 符 串 做 排 序 · 如 果 只 需 要 排 序 前 面 一 小 部 分 字 符 ， 則 可  以 减 小 × SO 一 飞 e th 的 配 置 ， 或 者 使 用 SUSTRItqCOlB&#39;, Length). "></p>
<p>磁盘临时表和文件排序</p>
<p>如果查询使用了Blob,Text并且需要使用隐式临时表，将不得不适用磁盘临时表</p>
<p>使用临时表表示性能较低</p>
<p>mysql临时表分为内存临时表，磁盘临时表，前者使用memory存储引擎，后者使用MyISAM存储引擎</p>
<p>mysql会先创建内存临时表，内存临时表超过配置指定值后，mysql会将内存临时表导出到磁盘临时表</p>
<p>使用临时表的场景</p>
<p>1.ORDER BY子句和GROUP BY子句不同， 例如：ORDERY BY price GROUP BY name；</p>
<p>2.在JOIN查询中，ORDER BY或者GROUP BY使用了不是第一个表的列 例如：SELECT  from TableA, TableB ORDER BY TableA.price GROUP by TableB.name（我在测试的时候发现即使是使用第一个表的列，也会使用到临时表）</p>
<p>3.ORDER BY中使用了DISTINCT关键字 ORDERY BY DISTINCT(price)</p>
<p>4.SELECT语句中指定了SQL_SMALL_RESULT关键字 SQL_SMALL_RESULT的意思就是告诉MySQL，结果会很小，请直接使用内存临时表，不需要使用索引排序 SQL_SMALL_RESULT必须和GROUP BY、DISTINCT或DISTINCTROW一起使用 一般情况下，我们没有必要使用这个选项，让MySQL服务器选择即可。</p>
<p>5.当group by 索引的时候，当数据量较小的时候不会使用临时表，当数据量（我测试的数据量在30万左右）大的时候会使用临时表</p>
<p>6.当group by 不是索引的时候会使用临时表</p>
<p>直接使用磁盘临时表的场景</p>
<p>1.表包含TEXT或者BLOB列；</p>
<p>2.GROUP BY 或者 DISTINCT 子句中包含长度大于512字节的列</p>
<p>3.使用UNION或者UNION ALL时，SELECT子句中包含大于512字节的列；</p>
<p>临时表相关配置</p>
<p>1.tmp_table_size 指定系统创建的内存临时表最大大小；</p>
<p>2.max_heap_table_size 指定用户创建的内存表的最大大小；</p>
<p>注意：最终的系统创建的内存临时表大小是取上述两个配置值的最小值。</p>
<p>表的设计原则</p>
<p>使用临时表一般都意味着性能比较低，特别是使用磁盘临时表，性能更慢，因此我们在实际应用中应该尽量避免临时表的使用。 常见的避免临时表的方法有：</p>
<p>1.创建索引：在ORDER BY或者GROUP BY的列上创建索引；</p>
<p>2.分拆很长的列：一般情况下，TEXT、BLOB，大于512字节的字符串，基本上都是为了显示信息，而不会用于查询条件， 因此表设计的时候，应该将这些列独立到另外一张表。</p>
<p>SQL优化</p>
<p>如果表的设计已经确定，修改比较困难，那么也可以通过优化SQL语句来减少临时表的大小，以提升SQL执行效率。常见的优化SQL语句方法如下：</p>
<p>1.拆分SQL语句，临时表主要是用于排序和分组，很多业务都是要求排序后再取出详细的分页数据，这种情况下可以将排序和取出详细数据拆分成不同的SQL，以降低排序或分组时临时表的大小，提升排序和分组的效率，我们的案例就是采用这种方法。</p>
<p>2.优化业务，去掉排序分组等操作，有时候业务其实并不需要排序或分组，仅仅是为了好看或者阅读方便而进行了排序，例如数据导出、数据查询等操作，这种情况下去掉排序和分组对业务也没有多大影响。</p>
<p>如何判断使用了临时表</p>
<p>使用explain查看执行计划，Extra列看到Using temporary就意味着使用了临时表。</p>
<p>尽量避免使用Blob,Text两种数据类型，实在无法避免，那么在所用用到Blob,Text字段的地方都是用substring(column,length)</p>
<p>要确保截取的子字符串足够短，不会使临时表的大小查过max_heap_table_size或tmp_table_size,超过后内存临时表会转换为MyISAM磁盘临时表</p>
<p> 使用子字符串来查询，可以提高查询效率</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image019.png"  alt="个 1 000 万 行  个 GB 的  字 符 集 的 V （ HAR （ 10 ） 列 · 每 个 字 符 最 多 使 用 3 个 字 节 ， 最 坏 情 况 下 需 要 3 0  字 节 的 空 间 。 如 果 在 ORDER BY 中 用 到 这 个 列 ， 并 且 查 询 扫 描 整 个 表 ， 为 了 排 序 就  需 要 超 过 30GB 的 临 时 表 。 "></p>
<p>使用枚举enum代替字符串类型</p>
<p>枚举类可以把一些不重复的字符串存储成一个预定义的集合，代替常用的字符串类型，mysql存储枚举时非常紧凑，会根据列表之的数量压缩到一个或两个字节中，将每个值在列表中的位置保存为整数，并在表的.frm文件中保存“数字-字符串”映射关系的茶</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image020.png"  alt="mysql&gt; CREATE TABLE 噁 律 test(高性能MySQL.assets/clip_image020.png &#39;dog&#39;) WTMJLL  mysql&gt; INSERT INTO em-a-test(e) VALIÆS(&#39;fish&#39;)&#39; (&#39;dog )&#39; (&#39;apple&#39;);  这 三 行 数 据 实 际 存 储 为 整 数 ， 而 不 是 字 符 串 · 可 以 通 过 在 数 字 上 下 文 环 境 检 索 看 到 这 个  双 重 属 性 ：  mysql&gt; 仃 + 0 emm_test; "></p>
<p>尽量避免在枚举数据类型的列中存入数字，双重性容易出错</p>
<p>枚举类型是按照内部存储的整数而不是定义的字符串进行排序的：</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image021.png"  alt="mysql&gt; SELECT e emn_test ODER BY e;  I fish  apple  I dog "></p>
<p>使用Field()函数可以显示指定排序顺序，但是这回导致mysql无法利用索引消除排序</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image022.png"  alt="I usu 1  I ardde I  . t .atdde, &#39;a)auu a qbsKu "></p>
<p>枚举的缺点：字符串列表是固定的，添加或者删除字符串必须使用alter table,对于一些列未来可能会改变的字符串，不适合用枚举，除非能够接受只在列表末尾添加元素</p>
<p>mysql把每个枚举值保存为整数，并且必须进行查找的时候才能转换为字符串，所以枚举列有些开销，把char/varchar列于枚举列进行关联又是性能并不好</p>
<p>？？？？</p>
<p>![为 了 说 明 这 个 情 况 ， 我 们 对 一 个 应 用 中 的 一 张 表 进 行 了 基 准 瀏 试 ， 看 看 在 MySQL 中 执  行 上 面 说 的 关 联 的 速 度 如 何 。 该 表 有 一 个 很 大 的 主 键 ：  CREATE TABLE bservicecalls （  day date WT 判 L 島  account 5 ， 111nt 、 OT № 」 L 島  “ e varchar(10) WT NULL,  —thod varchar(50) MILL,  calls int NOT L 島  items int 到 L 島  ti 就 亻 1 哋 t WT 判 [ L ，  （ 0 、 t decfn1(9,5) WT WLL ，  updated datetiæ,  1 № 吖 KEY （ 妇 y 》 account, ， e “ 1 “ ， method)  这 个 表 有 Il 万 行 数 据 ， 只 有 IOMB 大 小 ， 所 以 可 以 完 全 载 人 内 存 。 service 列 包 含 了 5  个 不 同 的 直 ， 平 均 长 度 为 4 个 字 符 ， th 列 包 含 了 71 个 值 ， 平 均 长 度 为 20 个 字 符 。  我 们 复 制 一 下 这 个 表 ， 但 是 把 service 和 rethod 字 段 换 成 枚 举 类 型 ， 表 结 构 如 下 ：  CREATE TABLE 以 e e Il 凹 （  庵 mitted ·  service E 墩 習 （ ， ． al 以 ‘ mitted…) WT 判 L 島  ethod E”(…values itt 灬 .) MJLL,  庵 mitted ·  ） E <a href="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image023.png"> 以 ‘ ‘no 閌 ； </a></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image024.png"  alt="然 后 我 们 用 主 键 列 关 联 这 两 个 表 ， 下 面 是 所 使 用 的 查 询 语 句 ：  ysql&gt; SELECT 5 仳 · 蔔 （ 0 筷 （ 俱 嗝 T 俨 ）  - &gt; FRm kbservicecalls  羽 IN ebservicecalls 巧 1 （ 妇 y ， account ， “ r 以 “ ， 就 th ） ；  我 们 用 V 职 和 B 巛 分 别 测 试 了 这 个 语 句 ， 结 果 如 表 4 ． 1 所 示 ·  表 4-1: EEVARCHARJENUM&quot; 的 速度  测 试  VARCHAR 关 联 VARCHAR  VARCHAR 关 联 ENUM  ENUM 关 联 VARCHAR  ENUM 关 联 ENUM  OPS  2  从 上 面 的 结 果 可 以 看 到 ， 当 把 列 都 转 换 成 EM&quot; 以 后 ， 关 联 变 得 很 快 · 但 是 当 V CH 职 列  和 E № 膶 列 进 行 关 联 时 则 慢 很 多 · 在 本 例 中 ， 如 果 不 是 必 须 和 v 0 列 进 行 关 联 ， 那 么  转 换 这 些 列 为 就 是 个 好 主 意 。 这 是 一 个 通 用 的 设 计 实 践 ， 在 “ 查 找 表 ” 时 采 用 整 数  主 键 而 避 免 采 用 基 于 字 符 串 的 值 进 行 关 联 。 "></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image025.png"  alt="然 而 ， 转 換 列 为 枚 举 型 还 有 另 一 个 好 处 。 根 据 SH TABLE STATUS 命 令 输 出 结 果 中  Data_ length 列 的 值 ， 把 这 两 列 转 換 为 ENUM 可 以 让 表 的 大 小 缩 小 旧 。 在 某 些 情 况 下 ，  即 使 可 能 出 现 和 V 0 R 进 行 关 联 的 情 况 ， 这 也 是 值 得 的 “ · 同 样 ， 转 换 后 主 键 也  只 有 原 来 的 一 半 大 小 了 · 因 为 这 是 InnoDB 表 ， 如 果 表 上 有 其 他 索 引 ， 减 小 主 键 大 小 会  使 非 主 键 索 引 也 变 得 更 小 。 稍 后 再 解 释 这 个 问 题 。 "></p>
<p>4.1.4日期和时间类型</p>
<p>mysql能存储的最小时间粒度是秒，MariaDB支持微妙级别的时间类型</p>
<p>mysql也可以使用微妙级的粒度进行临时运算</p>
<p>DateTime:</p>
<p>保存大范围的值，从1001到9999年,精度为秒，将时间和日期封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关，使用8个字节的存储空间</p>
<p>TimeStamp：</p>
<p>保存格林尼治时间1970年1月1日午夜以来的秒数（1970.01.01 23.00.00），和unix时间戳相同，timestamp只使用4个字节的存储空间，只能表示1970年到2038年</p>
<p>mysql提供了from_unixtime()函数把unix时间戳转换为日期，并提供unix_timestamp()函数把日期转换为unix时间戳</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image026.png"  alt="mysql&gt; select FROM UUIXTIME(13a49S4S15,  I &#39;XY-Xm-Xd I  | 2012-08-14 "></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image027.png"  alt="mysql&gt; select  I &#39;2e12-ø9.øa 18:17:23&#39;) |  1346753843 | "></p>
<p>mysql会将timeStamp的值按照DateTime的格式进行格式化，但是TimeStamp的存储格式在各个版本都是存储的时间戳</p>
<p>timestamp的显示依赖于时区，不同时区的同一数值的时间戳会按照时区时差进行相应的加减，以确保时间的当地正确性</p>
<p>如果插入时没有指定第一个timestamp的值，mysql则设置这个值为当前时间</p>
<p>timestamp默认为not null，默认值为0000-00-00 00:00:00</p>
<p>通常情况下尽量使用timestamp，它比datetime占用的空间更小</p>
<p>不建议用在整形存储时间戳，不会带来任何收益</p>
<p>如果要存储比秒更小粒度的日期和时间值怎么办：</p>
<p>1.使用bigint类型存储微秒级别的时间戳</p>
<p>2.使用double存储秒之后的小数部分</p>
<p>3.使用MariaDB代替mysql</p>
<p>查看ddl语句了解timestamp当前特性</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image028.png"  alt="img"></p>
<p>4.1.5位数据类型</p>
<p>mysql有少数几种存储类型使用紧凑的位存储数据，不管底层存储格式和处理方式如何，从技术上说都是字符串类型</p>
<p>BIT:</p>
<p>可以使用bit列在一列中存储一个或者多个true/false值，bit(1)定义一个包含单个位的字段，bit(2)存储两个位，最大长度64位</p>
<p>只能存入0，1。设定为不为null后的默认值为0</p>
<p>MyISAM存储bit是打包所有的bit列，8个bit(1)列只需要一个字节的空间</p>
<p>Menory和InnoDB为每个bit列使用一个足够存储的最小整数类型来存放，最小也是一个字节，不能节省空间</p>
<p>mysql把bit当做字符串类型，而不是数字类型</p>
<p>插入true就是1，插入false就是0</p>
<p>当不和数字做操作时，值为二进制对应的十进制数据对应的ascll字符；当和数字做操作时，结果为ascll码数值，最好避免使用这种数据类型</p>
<p>00111001=57，57对应的ascll字符串是9 </p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image029.png"  alt="my sql&gt;  mysql&gt;  mysql&gt;  19  CREATE TABLE bittest(高性能MySQL.assets/clip_image029.png);  INSERT INTO bittest VALIÆS(b&#39;001i1001&#39;);  SELECT a, a o bittest;  la .01  57 1 "></p>
<p>set数据结构，最多可以定义64个字符，想要修改set,必须用alter table，代价极高</p>
<p>set在mysql内部是以一些列打包的位的结合表示的，有效的利用了存储空间</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image030.png"  alt="Time  CURRENT_UMESTAMP "></p>
<p>枚举是只能选一个</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image031.png"  alt="img"></p>
<p>一般来说，无法在set列上通过索引进行查找操作</p>
<p>mysql内部使用整数存储enum和set类型，然后在做比较操作时转换为字符串</p>
<p>在整数列上进行按位操作</p>
<p>一种代替set的方法是使用一个整数包装一系列的位，例如，可以把八个位包装到一个Tinyint,并且按位操作来使用，可以在为应用中为每个位定义名称常量来简化这个工作</p>
<p>相对于set,这种办法的好处是可以不适用alter table改变字段代表的’枚举值’，缺点是查询语句更难写</p>
<p>![mysql&gt; CREATE TABLE “ 1 （  ． &gt; r 到 巽 还 REW ， 飞 RITE’, 飞 一 蒹 L (‘) WT <a href="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image032.png">  mysql&gt; 1 巧 E 盯 TO acl(pems) VALUES （ 飞 蠊 一 》 （ DELETE’);  呵 1&gt; SELECT 《 到 aci “RE FIE IN 一 跹 T(‘ 一 № 、 r ） ；  《 （ 螦 DELETE |  如 果 使 用 整 数 来 存 储 ， 则 可 以 参 考 下 面 的 例 子 ：  呷 5q1 &gt; 莊 ： 。 1 0 ，  “ &gt; RITE  ： 。 1 〈 10  DELETE ： 能 1 2 ；  mysql&gt; CREATE TABLE 1 （  r TINYINT 激 L F 鄰 」 LTO  些 INSERT I 耵 0 1 （ r 嬲 ） V 鼽 睚 5 （ ． RE № + “ 一 茈 LE ） ；  呵 1&gt; SELECT p FRæ ad “RE r 一 ；  这 里 我 们 使 用 MySQL 变 量 来 定 义 值 ， 但 是 也 可 以 在 代 码 里 使 用 常 量 来 代 替 ． </a></p>
<p>？？？有啥用，整数和如何解析？？</p>
<p>4.1.6选择标识符</p>
<p>为标识列选择合适的数据类型非常重要</p>
<p>标识列与其他值进行比较的可能性更大</p>
<p>选择标识列的类型时，不仅需要考虑存储类型，还要考虑mysql对这种类型怎么执行计算和比较</p>
<p>在满足值得范围得需求后，应该选择最小的数据类型</p>
<p>整数类型通常是标识列最好的选择，因为它们很快并且可以使用auto_increment</p>
<p>不要使用enum,set作为标识列</p>
<p>不要使用字符串类型作为标识列，它们非常消耗空间，并且很慢</p>
<p>MyISAM默认对字符串使用压缩索引，这回导致查询慢很多，最多慢6倍</p>
<p>完全随机的字符串插入(生成索引)，查询的时候会很慢</p>
<p>java语言存入的数据类型应该和mysql数据类型相匹配 </p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image033.png"  alt="Java  VARCHA  INTEGE  TINYINT  MEDIUM  glGINT  65535  VARCHAR  CHAR  BL0B  VARCHAR  INTEGER  UNSIGNED  TINYINT  uNSIGNED  SMALLINT  UNSIGNED  MEDIUMINT  IJNSIGNED  UNSIGNED  java.Iang.Strin  java n  java na no. bytet  java n  java na no .Lonq  java  java la .lnteq  java -Integ  java. la Zoo le  java.math.gigl  Sl(高性能MySQL.assets/clip_image033.png)  4 "></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image034.png"  alt="UNSIGNED)  PK (INTEGER  gTINYINT  V SOLD  java.sql.Timest  java.sql.Timest  va. q . Tin  java.sql.Date  java.Ianq.Lonq 4  java.math.gioD  java.Iang.Doub  java.Ianq.FIoat 7 "></p>
<p>4.1.7特殊类型数据</p>
<p>Ipv4地址实际上是32位无符号整数，不是字符串，用小数点将地址分成四段的表示方法只是为了方便阅读</p>
<p>应该用无符号整数存储ip地址</p>
<p>用int存储整数数字，mysql提供inet_aton，inet_ntoa来满足ip地址和整形数字之间的转换</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image035.png"  alt="计算机生成了可选文字: selectINETATO（&#39;127．．．1&#39;); selectINETTOA（2133735d33L"></p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image036.png"  alt="&#39;ΝΕΤ ΑΤΟΝ(高性能MySQL.assets/clip_image036.png&#39;127.Ο.Ο.1&#39;)  2130706433 "></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image037.png"  alt="127.0-0.1 "></p>
<p>4.2Mysql schema 设计中的陷阱</p>
<p>太多的列：</p>
<p>mysql存储引擎api在工作时需要在服务层和存储引擎之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列</p>
<p>mysql服务层从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的</p>
<p>MyISAM的定长行结构与服务器层的行结构正好匹配，不需要转换</p>
<p>MyISAM的变长行结构和InnoDB的行结构则总是需要转换，转换的代价取决于列的数量</p>
<p>太多的关联：</p>
<p>如果希望查询执行得快速且并发性好，单个查询最好在12个表以内做关联</p>
<p>全能的枚举：</p>
<p>注意防止过度使用枚举，修改枚举值池需要alter table</p>
<p>如果不是在列表的末尾增加值也会需要用alter table</p>
<p>错误用法：</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image038.png"  alt="CREATE ΤΑΒΙΕ (  country , 2 , "></p>
<p>非此发明的NULL:</p>
<p>前文提到不建议使用null，但是null有时也会比替代方案好</p>
<p>mysql会在索引中存储null值，oracle不会</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image039.png"  alt="计算机生成了可选文字: CREATETABLE· dtDATETIMENOTWLLDEFAULT0．闐．闐：00：闐&#39;"></p>
<p>4.3范式和反范式</p>
<p>第一范式：字段原子性，关系型数据库默认已经满足</p>
<p>第二范式：消除对主键的部分依赖（使用一个与业务逻辑无关的字段作为主键，以此字段作为从表的外键）</p>
<p>第三范式：消除对主键的传递依赖</p>
<p>传递依赖：B字段依赖于A，C字段又依赖于B。比如上例中，任课老师是谁取决于是什么课，是什么课又取决于主键id。因此需要将此表拆分为两张表日程表和课程表（独立数据独立建表）： </p>
<table>
<thead>
<tr>
<th>id</th>
<th>weekday</th>
<th>course_class</th>
<th>course_id</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>周一</td>
<td>教育大楼1521</td>
<td>3546</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>course_id</th>
<th>course_name</th>
<th>course_teacher</th>
</tr>
</thead>
<tbody><tr>
<td>3546</td>
<td>Java</td>
<td>张三</td>
</tr>
</tbody></table>
<p>减少了数据的冗余（即使周一至周日每天都有Java课，也只是course_id:3546出现了7次）</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image040.png"  alt="EMPLOYEE  Jones  Smith  Brown  Green  DEPARTMENT  Accounting  Enginee ring  Accounting  Engineering  HEAD  Jones  Smith  Jones  Smith "></p>
<p>以上这个schema表的问题如下：</p>
<p>1.如果领导更换，那么部门每一个人都要更新领导数据</p>
<p>2.如果同一个部门的两个人的领导不一样，无法判断谁是正确的</p>
<p>上面相当于是把employee作为了主键，主键的依赖性存在，不满足第二范式</p>
<p>4.3.1范式的优点与缺点</p>
<p>数据表范式化设计可以提高性能，尤其是写密集的场景</p>
<p>范式化的更新操作通常比反范式化要快‘</p>
<p>当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据</p>
<p>范式化的表通常更小，可以更好的放在内存里，所以执行操作会更快</p>
<p>很少有多余的数据，意味着distinct，group by会用的更少</p>
<p> 缺点:范式化设计的schema的缺点是需要关联，相同的数据存放在不同的表里面，查询时语句需要关联，可能使一些索引策略失效</p>
<p>4.3.2反范式的优点和缺点</p>
<p>反范式的schema因为所有的数据都在一张表中，可以很好地避免关联</p>
<p>如果不需要关联表，对大部分查询最差的情况——不适用索引，全表扫描，当数据比内存大时这可能比关联要快得多，因为这样避免了随机I/O</p>
<p>全表扫描基本上都是顺序I/O</p>
<p>反范式的优点就是能够避免表关联带来的性能问题</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image041.png"  alt="单 独 的 表 也 能 使 用 更 有 效 的 索 引 策 略 · 假 设 有 一 个 网 站 ， 允 许 用 户 发 送 消 息 ， 并 且 一 些  用 户 是 付 费 用 户 。 现 在 想 查 看 付 费 用 户 最 近 的 10 条 信 息 · 如 果 是 范 式 化 的 结 构 并 且 索  引 了 发 送 日 期 字 段 published ， 这 个 查 询 也 许 看 起 来 像 这 样 ：  mysql&gt; SELECT 就 、 、 明 e text, u ， 孬  I&quot;ER JOIN “ 就 明 一 id 吨 .id  ． &gt; 莊 user.account ty 。 的 premi 《 “ 疒  ． &gt; mER BY LIXIT 10 ；  要 更 有 效 地 执 行 这 个 查 询 ， MySQL 需 要 扫 描 message 表 的 published 字 段 的 索 引 · 对  于 每 一 行 找 到 的 数 据 ， 将 需 要 到 user 表 里 检 查 这 个 用 户 是 不 是 付 费 用 户 。 如 果 只 有 一 小  部 分 用 户 是 付 费 账 户 ， 那 么 这 是 效 率 低 下 的 做 法 ·  另 一 种 可 能 的 执 行 计 划 是 从 user 表 开 始 ， 选 择 所 有 的 付 费 用 户 · 获 得 他 们 所 有 的 信 息 咩  并 且 排 序 。 但 这 可 能 更 加 糟 糕 。  主 要 问 题 是 关 联 ， 使 得 需 要 在 一 个 索 引 中 又 排 序 又 过 滤 · 如 果 采 用 反 范 式 化 组 织 数 据 ·  将 两 张 表 的 字 段 合 并 一 下 ， 并 且 噌 加 一 个 索 引 (account_type. published), 就 可 以 不  通 过 关 联 写 出 这 个 查 询 。 这 将 非 常 高 效 ：  SELECT 的 0 、 a 忠 e te 跹 t 》 也 er  ． 》 - p 曲 1 hed "></p>
<p>提升性能最好的方法是在同一张表中保存衍生的冗余数据</p>
<p>缓存表：表示存储那些可以比较简单地从schema其他表获取数据的表</p>
<p>汇总表：保存的是使用group by语句聚合数据的表</p>
<p>？？？没懂</p>
<p>4.4.1物化视图</p>
<p>物化视图实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新，更新</p>
<p>4.4.2计数器表</p>
<p>？？？</p>
<p>为了提高读查询的速度，经常会建一些额外的索引，增加冗余列，甚至是创建缓存表，汇总表</p>
<p>这些方法会增加写查询的负担，同时还可能增加了读写操作的开发难度</p>
<p>4.5加快alter table操作的速度</p>
<p>mysql执行 alter table的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表</p>
<p>这样操作非常消耗时间，数个小时甚至几天才能完成，且会中断mysql服务</p>
<p>以下两个技巧只解决alter操作过程对现行服务的影响，没有解决alter操作慢的问题</p>
<p>技巧一：</p>
<p>现在一台不提供服务的机器上执行alter table操作，然后和提供服务的主库进行切换</p>
<p>技巧二：</p>
<p>影子拷贝，用要求的表结构创建一张和源表无关的新表，拷贝数据后通过重命名和删表操作交换两个表</p>
<p>并非所有的alter 都会引起表的重建</p>
<p>1：修改列的默认值</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image042.png"  alt="计算机生成了可选文字: mysql&gt;ALTERTABLEsakila.film -&gt;ÜIFYCOLUMNrentaldurationTINYINT(高性能MySQL.assets/clip_image042.png)NOTMJLLDEFAULT5；"></p>
<p>Show status显示这条语句做了1000次读，1000次写，也就说拷贝了整张表，非常慢</p>
<p>2：列的默认值实际存放在表的.frm文件中，理论上可以直接修改文件而不改动表本身。然而mysql还没采用这种优化方法，所有的modify column操作都会导致表重建</p>
<p>3.通过alter column操作来改变列的默认值，这个语句会直接修改.frm文件而不涉及表数据，这个操作是非常快的</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image043.png"  alt="计算机生成了可选文字: mysql&gt;ALTERTABLEsakila.film -&gt;舡COLINrentaldurationSETDEFAULT5；"></p>
<p>Alter table允许alter column,modify column,change column语句修改列，这三种操作是不一样的</p>
<p>4.5.1只修改.frm文件</p>
<p>下面的这些操作有可能不需要重建表：</p>
<p>1.移除（不是增加）一个列的auto_increment</p>
<p>2.增加，移除，更改enum,set常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字符串</p>
<p>创建一个新的.frm文件，用它替换掉已经存在的那张表的.frm文件：</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image044.png"  alt="计算机生成了可选文字: ．创建一张有相同结构的空表，并进行所需要的修改（例如增加E常量)- 执行FLUSHTABLESREADLO。这将会关闭所有正在使用的表，并且禁止任 2． 何表被打开。 交换.frm文件 3， 执行UNLOCKTABLES来释放第2步的读锁。 4．"></p>
<p>![下 面 以 给 sakila .mm 表 的 rating 列 增 加 一 个 常 量 为 例 来 说 明 · 当 前 列 看 起 来 如 下 ：  mysql&gt; COURS 5 以 na · 刊 ] 0 LIKE •rating’;  lField 0 e  | Null 丨 《 Default 玳 “ |  1 rating 》 en (‘G’ ％ ‘ 疒 13’ R’ ． 17D | YES |  假 设 我 们 需 要 为 那 些 对 电 影 更 加 谨 慎 的 父 母 们 增 加 一 个 PG-14 的 电 影 分 级 ：  mysql&gt; （ 耵 E T 眭 5 il fi LIKE 5 过 · 龜 № ；  mysql&gt; ALTER TABLE sakila.film new  ． 》 OIFY （ L rating <a href="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image045.png"> 崩 (‘G’ 、 · ． g’ ， 生 R’ ． 17 、  0 F T  mysql&gt; FLIJ9i T”LES 颛 渊 RW L 佤  · 峪 14D  注 意 ． 我 们 是 在 常 量 列 表 的 末 尾 增 加 一 个 新 的 值 。 如 果 把 新 增 的 值 放 在 中 间 ， 例 如  PG-13 之 后 ， 则 会 导 致 已 经 存 在 的 数 据 的 含 义 被 改 变 : 已 经 存 在 的 R 值 将 变 成 PG ． | 4 ，  而 已 经 存 在 的 N017 将 成 为 等 等 。  接 下 来 用 操 作 系 统 的 命 令 交 换 .frm 文 件 ：  /var/lib/mysql/sakila” “ film.frr film_t•p.fm  /var/lib/mysql/sakilat “ 薈 il ， neu.fr•  /var/lib/mysql/sakila “ 1 。 3 呷 “  再 回 到 MySQL 命 令 行 ， 现 在 可 以 解 锁 表 并 且 看 到 变 更 后 的 效 果 了 ： </a></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image046.png"  alt="mysql&gt; NOCK TABLES;  mysql&gt; 5 》 COLAS sakila.filn LIKE •rating•\G  Field: rating  Type: en 圃 (&#39;G&#39; 耗@疒 ． 13&#39; ， &#39; R 、 &#39; ． 17• 疒 ． 14D  最 后 需 要 做 的 是 删 除 为 完 成 这 个 操 作 而 创 建 的 辅 助 表 ：  mysql&gt; T 期 sakila.filn n ； "></p>
<p>4.5.2快速创建MyISAM索引</p>
<p>高效的载入数据有一个技巧：先禁用索引，载入数据，然后重新启用索引</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image047.png"  alt="nysql&gt; ALTER TABLE test.load_data DISABLE KEYS;  - load the data  nysql&gt; ALTER TABLE test.load_data ENABLE KEYS; "></p>
<p>数据完全载入以后，可以通过排序来后加索引了，可以使得索引树的碎片更少，更紧凑</p>
<p>因为disable keys只对非唯一索引有效，所以这个办法对唯一索引无效</p>
<p>MyISAM会在内存中构造唯一索引，并且为载入的每一行检查唯一性。一旦索引的大小超过有效内存大小，载入操作就会变得越来越慢</p>
<p>快速创建InnoDB索引</p>
<p>先删除所有的非唯一索引，然后增加新的列，最后重新创建删除掉的索引</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image048.png"  alt="下 面 是 操 作 步 驟 ：  l. 用 需 要 的 表 结 构 创 建 一 张 表 ， 但 是 不 包 括 索 引 。 "></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image049.png"  alt="载 人 数 据 到 表 中 以 构 建 ． MYD 文 件 。  2 ·  ． 按 照 需 要 的 结 构 创 建 另 外 一 张 空 表 ， 这 次 要 包 含 索 引 。 这 会 创 建 需 要 的 frm 和 .MYI  文 件 ·  获 取 读 锁 并 馴 新 表 ·  4 ·  ． 重 命 名 第 二 张 表 的 m 和 MY, / 文 件 ， 让 MySQL 认 为 是 第 一 张 表 的 文 件 。  释 放 读 锁 。  6 ．  使 用 REPAIR T LE 来 重 建 表 的 索 引 。 该 操 作 会 通 过 排 序 来 构 建 所 有 索 引 ， 包 括 唯 一  7 ．  索 引 · "></p>
<p>4.6总结</p>
<p>注意可变长字符串，在临时表和排序时可能导致悲观的按最大长度分配内存</p>
<p>尽量使用整数定义表示列</p>
<p>避免使用mysql已经遗弃的特性，例如指定浮点数和精度，或者整数的显示宽度</p>
<p>避免使用bit</p>
<p>5.1索引基础</p>
<p>索引（key）是存储引擎用于快速找到记录的一种数据结构</p>
<p>当表中的数据量越来越大时，索引对性能的影响越发重要</p>
<p>索引优化是对查询性能优化的最有效的手段，索引能够轻易的将查询性能提高几个数量级</p>
<p>创建一个真正的“最优”索引经常需要重写查询</p>
<p>索引是在存储引擎层而不是服务器层实现的</p>
<p>索引使用原理：</p>
<p>先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行</p>
<p>5.1.1索引的类型</p>
<p>数据结构</p>
<p>二叉查找树：</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image050.png"  alt="img"></p>
<p>平衡二叉树（AVL Tree）：通过一次或者两次的左右旋转来保持左右子树高度差不能大于1的平衡</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image051.png"  alt="img"></p>
<p>LL,RR旋转一次，LR,RL旋转两次</p>
<p>平衡多路查找树（B-tree）：</p>
<p>页是存储引擎管理磁盘的最小单位，每个页包含了多个磁盘块。也就是说存储引擎每次会从磁盘中读取多个磁盘块</p>
<p>缺点：</p>
<p>1.将数据和key值存储在一起，会导致每次读取的页内含有的范围信息减少，增加I/O次数</p>
<p>2.将数据和key值存储在一起，会导致一个磁盘块内存储的键值对减少，增加树的高度，进而提高I/O次数</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image052.png"  alt="计算机生成了可选文字: d刁 指针 骸据 即表中记的主键 17p235p3 存储子节地止信息 即表记录中除主外的数据"></p>
<p>B+Tree：对B-Tree进行了优化</p>
<p>1.非叶子节点只存储键值信息</p>
<p>2.数据记录都存储在叶子节点中</p>
<p>3.所有叶子节点之间都有一个链指针</p>
<p>叶子节点之间相互链接使得所有的叶子节点构成了一个链表，方便遍历</p>
<p>B+Tree的高度一般在2-4层，innodb在设计时将根节点常驻内存，进而减少了I/o次数</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image053.png"  alt="计算机生成了可选文字: 假，即云中记录的芏键 指計，存储子节卢地址俪· 数。即表记录中除生譬夕卜的数据"></p>
<p>哈希索引：基于哈希表实现，只有精确匹配索引所有列的查询才有效</p>
<p>空间数据索引R-Tree：</p>
<p>全文索引</p>
<p>5.2索引的优点</p>
<p>1.大大减少服务器需要扫描的数据量</p>
<p>2.帮助服务器避免排序和临时表</p>
<p>3.可以将随机I/O变成顺序I/O</p>
<p>优秀的索引具有的特点：</p>
<p>1.索引将相关的记录放到一起</p>
<p>2.索引中的数据顺序和查找中的排序顺序一致</p>
<p>3.索引的列包含了查询中需要的全部列</p>
<p>5.3.1独立的列</p>
<p>如果查询中的列不是独立的，mysql就不会使用索引。索引列不能是表达式的一部分</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image054.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image055.png"  alt="img"></p>
<p>5.3.2前缀索引和索引选择性</p>
<p>索引选择性：不重复的索引值和总记录跳数的比值，反应索引列中数据的重复性</p>
<p>问：如何避免很长的字符列建立的索引大且慢？</p>
<p>答：索引字符列开始的部分字符，但是必须小心选择前缀字符的长度，避免降低索引选择性</p>
<p>保持索引选择性的方法：</p>
<p>方法一：比较使用 </p>
<p>查看截取字符串的重复次数，增加截取长度，知道重复次数与全长接近</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image056.png"  alt="计算机生成了可选文字: mysql&gt;SELECTCOUNT(高性能MySQL.assets/clip_image056.png)cnt，city ．&gt;陬sakila.city_demoBYcityORDERcntDESCLINIT10；"></p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image057.png"  alt="计算机生成了可选文字: mysql&gt;SELECTCWNT(高性能MySQL.assets/clip_image057.png)处cnt,LEFT(city,3）处pref -&gt;sakila.city_demo0卯BYprefORDERBYcntLINIT10；"></p>
<p>方法二：比较选择性</p>
<p>二者趋近的时候，截取的字符串长度就差不多了</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image058.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image059.png"  alt="img"></p>
<p>两种方法合在一起使用能够更为精准的找出最合适的截取长度</p>
<p>5.3.3多列索引</p>
<p>常见错误：每个列创建一个索引，按照错误的顺序创建索引</p>
<p>表film_actor在film_id，actor_id上各有一个单列索引</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image060.png"  alt="计算机生成了可选文字: mysql&gt;SELECTf ，actorid -&gt;EREactor谰=1filmid=1；"></p>
<p>两个索引对于这个sql都不是最好的选择，复合索引才是最优解</p>
<p>当只有单列索引时，下图所示查询就会被mysql索引合并做联合操作，效率可能还不如全表扫描</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image061.png"  alt="mysql&gt; EXPLAIN SELECT fib_id, actor_id sakila.film_actor  -Y ERE actor_id 1 OR id  id:  select_type: SIPLE  table: film actor  type: index erge  possible_keys  : PRIMRY,idx fk film id  key: PRIMARY, idx-fk-film-id  key Len:  -ref  : WLL  29  Extra :  using ere "></p>
<p>如果在explain中看到所有合并，就应该检查查询和表结构了，看看当前索引是否最优</p>
<p>可以通过参数optimizer_switch关闭所有合并功能，也可以使用ingore index让优化器忽略掉某些索引</p>
<p>5.3.4选择合适的索引列顺序</p>
<p>在一个多列索引当中，索引列的顺序意味着首先按照最左列进行排序，其次按顺序第二列，第三列，也正是如此，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的order by,group by,distinct等子句的查询需求</p>
<p>索引选择性：不重复的索引值和总记录跳数的比值，反应索引列中数据的重复性</p>
<p>如何选择列有一个经验法则：将选择性最高的列放到索引最前列</p>
<p>当不需要考虑排序和分组时，将选择性最高的列放在前面通常是最好的。这个时候索引的作用只是用于优化where 条件的查找</p>
<p>（用选择性高的原因是详细表驱动次详细表，排查次数最少，效率最高）</p>
<p>实际情况下，索引的选择需要根据运行频率最高的查询 来调整索引列的顺序:</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image062.png"  alt="计算机生成了可选文字: SELECTpaymentWHEREstaffid“2customerid。5鉺；"></p>
<p>分析步骤一：查看各个where条件分支对应的数据基数有多大</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image063.png"  alt="mysql&gt; SELECT 2), 584)  stN(高性能MySQL.assets/clip_image063.png): 7992  • 584): 30 "></p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image064.png"  alt="nysql&gt; SELECT COUNT(DISTINCT AS  &gt; COtNT(DISTIKT AS  &gt; cm.NT(高性能MySQL.assets/clip_image064.png)  0.0m1  0.0373  cm.NT(•): 16049 "></p>
<p>阶段建议：小列驱动大列，索引选择性大的customer_id在前</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image065.png"  alt="img"></p>
<p>注意：上述方法是依赖于具体值进行的分析，可能对其他条件的查询不公平，服务器整体性能可能更糟</p>
<p>5.3.5聚簇索引</p>
<p>InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按照每张表的主键构造一颗B+Tree,同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据页</p>
<p>并不是一种单独的索引类型，而是一种数据存储方式</p>
<p>一般建表会用一个自增主键做聚簇索引，如果没有主键，InnoDB会选择一个唯一的非空索引代替，如果还没有msql会隐式定义一个主键，但是这个主键的不能频繁更新</p>
<p>InnoDB只聚集在同一个页面的记录，包含相邻键值的页面可能相距甚远？？？</p>
<p>聚簇索引的优点：</p>
<p>1.正常的非聚集索引（辅助索引）的优点都有</p>
<p>2.数据访问比辅助索引更快，聚簇索引将索引和数据保存在同一B+Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快</p>
<p>3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值？</p>
<p>缺点:<br> 1.插入速度严重依赖于插入顺序，如果按照主键顺序插入是最理想的，但如果不是会很慢，加载完成后最好使用optimize table命令重新组织一下表</p>
<p>2.更新聚簇索引的代价很高，因为要移动一整行的数据</p>
<p>3.插入新行或者主键被更新导致行移动时，可能面临页分裂的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，页分裂会导致表占用更多的磁盘空间</p>
<p>4.可能会导致全表扫描变慢，尤其是行比较稀疏，页分裂导致数据库存储不连续的时候</p>
<p>5.二级索引（非聚集索引）可能要比想象中的要大，因为二级索引的叶子节点包含了引用行的主键列</p>
<p>6.二级索引访问需要两次索引查找，而不是一次</p>
<p>二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值</p>
<p>存储引擎根据二级索引找到目标行的主键值后，按照这个主键值去聚簇索引中找到目标行，做了重复的工作</p>
<p>自适应哈希索引能够减少InnoDB这样重复的工作</p>
<p>InnoDB和MyISAM的数据分布对比</p>
<p>聚簇索引（主键索引）和非聚簇索引（二级索引）的数据分布存在区别</p>
<p>书中这个地方没看懂</p>
<p>5.3.6覆盖索引</p>
<p>覆盖索引：一个索引包含所有需要查询的字段的值，查询只需要扫描索引而无需回表</p>
<p>在索引中满足查询的成本一般比查询行要小得多</p>
<p>优点：</p>
<p>1.索引条目远小于数据行大侠，mysql可以极大的减少数据访问量。因为这种情况下响应时间大部分花在数据拷贝上，所有对缓存的负载特别重要</p>
<p>2.索引比数据小，更容易全部放入内存中。MyISAM能压缩索引，更大化的发挥覆盖所有的优势</p>
<p>3.因为索引在单页中是按照列值顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多</p>
<p>4.MyISAM在内存中只缓存索引，数据依赖于操作系统来缓存，会导致严重的性能问题，覆盖索引能够解决</p>
<p>5.二级索引面临两次查询的性能问题，如果用覆盖索引能够避免这个问题</p>
<p>如果索引不能覆盖所有的查找列，那么就需要不断地回表随机I/O,效率低于顺序全表扫描</p>
<p>如果索引覆盖了where条件中的字段，但不是整个查询涉及的字段，mysql5.5以前的版本还是会回表获取数据行</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image066.png"  alt="mysql&gt; EXPLAIN SELECT • FRI products ERE actor.&#39;SEAN CAREY&#39;  title like  select_type: SIMPLE  table: products  type: ref  possible_keys  : ACTOR,IX PO  key: ACTn  key_len: 52  ref: const  Extra: using ere "></p>
<p>没有任何索引能够覆盖这个查询，因为查询从表中选择了所有的列，而没有覆盖所有列的索引</p>
<p>mysql不能再索引中执行like操作，只能做左前缀匹配的like操作</p>
<p>当前只有last_name字段有二级索引</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image067.png"  alt="mysql&gt; EXPLAIN SELECT actor_id,  sakila.actor ERE  id: 1  select_type  : SIMPLE  table: actor  type: ref  key_len; 137  last næ  possible_keys idx actor last nÄ  key; idx actor last  ref: const  Extra: using ere; using "></p>
<p>因为InnoDB的二级索引包括主键的值，所以能够对actor_id做覆盖查询</p>
<p>5.3.7使用索引扫描来做排序</p>
<p>mysql有两种方式生成有序的结果：</p>
<p>1.通过排序操作</p>
<p>2.按索引顺序扫描</p>
<p>Explain type的值为index,说明使用了索引扫描来做排序</p>
<p>只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方向（正，到序）都一样时，mysql才能使用索引来对结果做排序</p>
<p>如果查询需要关联多张表，则只有当order by 子句引用的字段全部为第一个表时，才能使用索引做排序</p>
<p>？？？</p>
<p>5.3.8压缩（前缀压缩）索引</p>
<p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中。默认只压缩字符串，但也可以通过参数设置对整数做压缩</p>
<p>5.3.9冗余和重复索引</p>
<p>冗余索引：mysql允许在相同的列上创建多个索引，但是mysql需要单独维护重复的索引，会影响性能</p>
<p>重复索引：在相同的列上按照相同的顺序创建相同类型的索引</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image068.png"  alt="CREATE TABLE test (  ID INT NOT PRIMRY KEY,  A INT NOT WLL,  B INT WLL,  LMQUE(高性能MySQL.assets/clip_image068.png),  I&#39;OEX(ID) "></p>
<p>唯一，主键都是通过索引实现的，上面的sql实际上创建了三个重复的索引</p>
<p>尽量避免冗余索引，尽量扩展已有索引而不是创建新索引</p>
<p>如果扩展已有索引会导致其变得很大，进而影响性能，那么可以考虑使用冗余索引</p>
<p>Where a=5 order by id用KEY(a)索引会很有用，但是用KEY（a,b）就无法进行排序了，只能做文件排序</p>
<p>可以使用工具将服务器完全用不到的索引删除掉</p>
<p>5.3.11索引和锁</p>
<p>索引可以让查询锁定更少的行（读锁是锁定写的），锁定超过需要的行会增加锁争用并减少并发性</p>
<p>如果innodb检索到数据并返回给服务器层以后，mysql服务器才执行where子句筛选，那么就无法避免额外的锁定行了</p>
<p>以下例子可以解释索引使用不好，对排他锁的过度使用情况：</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image069.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image070.png"  alt="计算机生成了可选文字: |actorid 这条查询仅仅会返回2一4之间的行，但是实际上获取了1一4之间的行的排他锁。 InnoDB会锁住第1行，这是因为MySQL为该查询选择的执行计划是索引范围扫描， mysql&gt;EXPLAINSELECTactoridsakila.actor 0HEREactorid〈5actor炻01FORm•ATE； 》id|select-type丨table吓y四，丨Extra |1|SIMPLE |actor|rangeIPRIMRY丨Usingwhere;Using1e×I 换句话说，底层存储引擎的操作是“从索引的开头开始获取满足条件acto0id&lt;5的 记录”，服务器并没有告诉InnoDB可以过滤第1行的WHERE条件。注意到EXPLAIN的 Extra列出现了&quot;Usingwhere”，这表示MySQL服务器将存储引擎返回行以后再应用 田E过滤条件。"></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image071.png"  alt="下 面 的 第 二 个 查 询 就 能 证 明 第 1 行 确 实 已 经 被 锁 定 、 尽 管 第 一 个 查 询 的 结 果 中 并 没 有 这  个 第 1 行 。 保 持 第 一 个 连 接 打 开 ， 然 后 开 启 第 二 个 连 接 并 执 行 如 下 查 询 ：  mysql&gt; SET 粼 仃 - IT 。 0 ；  mysql&gt; BEGIN•  rysql&gt; SELECT t saki1a.actor&quot;ÆRE 以 t 豇 ． d 1 FA u 狂 ；  这 个 杳 询 将 会 杵 起 ， 青 到 箪 一 个 事 务 釋 放 箪 1 行 的 锁 ． 泫 个 行 为 对 干 基 干 语 句 的 复 制 （ 辂  在 第 10 章 讨 论 ） 的 正 常 运 行 来 说 是 必 要 的 。 "></p>
<p>InnoDB在二级索引上使用共享读锁，但访问主键索引需要排他写锁，这消除了使用覆盖索引的可能性？，并且使得select for update比lock in share mode或非锁定查询要慢得多？？？</p>
<p>如果不使用索引查找，使用全表扫描，那么就会锁住所有的行，性能极差</p>
<p>5.4索引案例学习</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image072.png"  alt="〖 优 化 总 结 囗 诀 〗  全 值 匹 配 我 最 爱 ， 最 左 前 缀 要 遵 守 ；  带 头 大 哥 不 能 死 ， 中 间 兄 弟 不 能 断 ；  索 引 列 上 少 计 算 ， 范 围 之 后 全 夫 效 ；  凵 KE 百 分 写 最 右 ， 覆 盖 索 引 不 写 星 ：  不 等 空 值 还 有 。 r ， 索 引 失 效 要 少 用 ：  VAR 引 号 不 可 丢 ， SQL 高 级 也 不 难 ！ "></p>
<p> 案例：用户信息表包括，国家，地区，城市，性别，眼镜颜色等等</p>
<p>要求：既有排序要求又有查询要求</p>
<p>1.支持上面这些特征的各种组合来搜索用户</p>
<p>2.允许根据用户的最后在线时间，其他用户对该用户的打分进行排序</p>
<p>问题：</p>
<p>排序要求索引中的列必须有顺序，有顺序的索引无法满足各种组合的查询优化要求</p>
<p>解决步骤：</p>
<p>1.查看那些列拥有很多不同的取值，那些列在where子句中出现得最频繁，在有更多不同值得列上创建索引得选择性更好，可以让mysql更有效地过滤掉不需要的行</p>
<p>country，sex列的选择性通常不高，但是很多查询都会用到，所以建议创建不同组合索引的时候将（sex,country）作为前缀？？？我觉得是后缀</p>
<p>2.如果查询条件没有sex,country，那么可以通过sex in(‘m’,’f’)的方式让他来选择我们设定的索引</p>
<p>3.设计索引时，应当同时优化查询语句和索引以找到最佳的平衡</p>
<p>4.对于选择性高，使用不频繁的生僻列，有两种创建索引的办法</p>
<p>1.忽略不建立索引，让mysql多扫描一些额外的行</p>
<p>2在索引中加上生僻行，不使用的时候用in()技术忽略掉</p>
<p>5.尽可能的将需要做范围查询的列放在索引的后面，范围查询后面的索引列就不生效了</p>
<p>6.避免滥用IN()技术优化器需要将不同的情况做出组合，下图就有432=24中组合。超过一定组合，mysql就不能很好的利用索引了</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image073.png"  alt="&quot;RE eye color INC brown , • blue&#39; , &#39;hazel&#39; )  &quot;O hair_color INC&#39; black&#39; , •red&#39; , •blonde&#39; ,  K) sex "></p>
<p>5.4.2避免多个范围条件</p>
<p>explain无法区分mysql是要查询范围值，还是要查询列表值</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image074.png"  alt="&quot;range&quot; •  EXPLAIN SELECT actor id  &quot;RE actor_id &gt;  id: 1  select_type : SIPLE  table: actor  type: range  mysql&gt; EXPLAIN SELECT actor_id sakila.actor  &quot;RE actor_id IN(I, 4,  select_type:  table: actor  type: range "></p>
<p>前者是范围查询，后者是多个等值条件查询</p>
<p>范围查询，范围列后面的其他索引列无法使用；等值查询则没有这个限制</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image075.png"  alt="假 设 我 们 有 一 个 last_ontine 列 并 希 望 通 过 下 面 的 查 询 显 示 在 过 去 几 周 上 线 过 的 用 户 ：  ,&#39;hazel&#39;)  HERE eye ． （ 010r (高性能MySQL.assets/clip_image075.png)  hair （ 010r IN(•black&#39;,•red%  Ato last 一 仳 &gt; DATE 旧 0 0 ， IN 7 DAY) "></p>
<p>问题：两个范围查询如何设计合适的索引</p>
<p>在无法使用IN()的情况下</p>
<p>方法：通过逻辑解决问题</p>
<p>设计一个active列，这个字段由定时任务来维护，用户每次登录，将对应值设为1，并将过去连续七天没有登录的用户的值设为0</p>
<p>如果未来mysql实现了松散索引扫描，那么就可以在一个索引上使用多个范围索引了</p>
<p>为什么范围索引列之后的索引列无效？</p>
<p>因为使用了范围索引，所以会使用满足范围的所有制，也就是说存储引擎在这个时候会提取出满足之后条件的所有制，并遍历获取满足之后条件的值（范围操作要服务层来做，索引是存储引擎做）</p>
<p>5.4.3优化排序</p>
<p>使用文件排序对小数据集是很快的</p>
<p>随着偏移量的增加，mysql需要花费大量的时间来扫描需要丢弃的数据</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image076.png"  alt="img"></p>
<p>解决办法：</p>
<p>1.显示用户能够翻页的数量</p>
<p>2.延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行</p>
<p>![计算机生成了可选文字: mysql&gt;SELECT化0]5&gt;FROMprofiles1%ER〕OIN（ SELECT华的豇ykey（0]0profiles HERExe过’凹’ORDERBYratingLIMIT1闐，10 &gt;）xUS璇（华“key5&gt;）；](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image077.png)</p>
<p>5.5维护索引和表</p>
<p>维护表的三个目的：</p>
<p>1.找到并修复损坏的表</p>
<p>MyISAM：</p>
<p>MyISAM表损坏通常是系统崩溃到导致的</p>
<p>损坏的索引会导致查询返回错误的结果或者莫须有的主键冲突等问题，严重时会导致数据库崩溃</p>
<p>如果发生奇怪的问题，可以通过check table检查是否发生了表损坏</p>
<p>修复索引的办法：只对索引损坏有效，如果损坏的是系统区域，数据区域，那么就只能从备份中恢复</p>
<p>1.可以使用repair table命令来修复损坏的表</p>
<p>2.修改表的存储引擎为当前引擎</p>
<p>InnoDB:</p>
<p>InnoDB的设计保证它并不容易被损坏</p>
<p>如果损坏一般是因为数据库硬件问题，例如内存，磁盘，mysql外部操作了数据文件，InnoDB本身的缺陷（不太可能）</p>
<p>2.维护准确的索引信息</p>
<p>mysql的查询优化器会通过两个api来了解存储引擎的索引值的分布信息，以决定如何使用索引</p>
<p>第一个api是records_in_range(),通过向存储引擎传入两个边界值获得在这个范围大概有多少条记录</p>
<p>第二个api是info(),该接口返回各种类型的数据，包括索引的基数</p>
<p>3.减少碎片</p>
<p>B+Tree索引可能会碎片化，碎片化的索引可能会以很差或者无序的方式存储在磁盘上</p>
<p>B+Tree需要随机磁盘访问才能定位到叶子页，所以随机访问是不可避免的</p>
<p>所以，如果叶子页在物理分布上是顺序且紧密的，那么查询的性能就好</p>
<p>否则，对于范围查询，索引覆盖扫描等操作，速度很慢</p>
<p>表的数据存储也可能碎片化：</p>
<p>行碎片：数据行被存储为多个地方的多个片段中，即使查询只从索引中访问一行记录，行碎片也会导致性能下降</p>
<p>行间碎片：逻辑上顺序的页，行在磁盘上不是顺序存储的。行间碎片对全表扫描和聚簇索引扫描之类的操作有很大的影响，因为这些操作原来是能够从磁盘上顺序存储的数据中收益的</p>
<p>剩余空间碎片：</p>
<p>数据页中有大量的空余空间，这会导致服务器读取大量不需要的数据，造成浪费</p>
<p>对于MyISAM表，这三类碎片化都可能发生，但是InnoDB不会出现短小的行碎片；InnoDB会移动短小的行并重写到一个片段中</p>
<p>可以通过执行OPTIMIZE TABLE或者导出再导入的方式来重新整理数据</p>
<p>MyISAM可以通过排序算法重建索引的方式消除碎片</p>
<p>InnoDB可以通过先删除，然后再重新创建索引的方式来消除索引的碎片化</p>
<p>5.6总结</p>
<p>单行访问:服务器从存储中读取一个数据块只是为了获取其中一行</p>
<p>最好读取的块中尽可能多的包含所需的行，使得索引可以创建位置引用以提高效率？？</p>
<p>单行访问是很慢的（固态的硬盘随机I/O比机械硬盘快很多）</p>
<p>按顺序访问范围数据是很快的</p>
<p>原因1：顺序I/O不需要多次磁盘寻道，快于随机I/O(特别是机械硬盘)</p>
<p>原因2：如果服务器能够按需要的顺序读取顺序，那么就不再需要额外的排序操作，并且group by查询也无需再做排序和将行按组进行聚合计算了</p>
<p>索引覆盖查询是很快的，因为存储引擎不需要回表查询，避免了大量的单行访问</p>
<p>编写查询语句是应该尽量选择合适的索引以避免单行查找，尽可能使用数据原生顺序从而避免额外的排序顺序，并尽可能的使用索引覆盖查询</p>
<p>6.1为什么查询速度会慢</p>
<p>查询设计的基本原则，查询优化技巧，mysql优化器内部的机制是本章的主要内容</p>
<p>查询语句优化，索引优化，库表结构优化是性能优化的三架马车</p>
<p>优化查询实际上是优化：优化查询的子任务<br> 1.消除一些子任务</p>
<p>2.减少子任务的执行次数</p>
<p>3.让子任务运行的更快</p>
<p>查询的生命周期：<br> 1.从客户端，到服务器</p>
<p>2.在服务器上解析，生成执行计划，执行</p>
<p>3.返还结果给客户端</p>
<p>执行包括：存储引擎的调用，数据处理，排序，分组等</p>
<p>另外还会花费的时间：网路，cpu计算，生成统计信息和执行计划，锁等待等</p>
<p>了解查询的生命周期，清楚查询的时间消耗情况对于优化查询有很大的意义</p>
<p>6.2慢查询基础：优化数据访问</p>
<p>确认应用程序，mysql服务器是否在解析访问大量并不需要的行，列，性能低下的基本原因是访问的数据太多</p>
<p>6.2.1是否向数据库请求了不需要的数据</p>
<p>访问大量不需要的数据会给mysql服务器带来额外的负担，并增加网络开销，也会消耗应用服务器的cpu和内存资源</p>
<p>如果应用服务器和数据库(指的是存储引擎吗？)不再同一台主机上，网络开销就显得很明显了。即使是在同一台服务器上仍然会有数据传输的开销</p>
<p>典型案例：</p>
<p>1.查询不需要的记录</p>
<p>2.多表关联时返回全部列</p>
<p>3.总是取出全部列</p>
<p>取出全部列会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O,内存和cpu的消耗</p>
<p>4.重复查询相同的数据</p>
<p>用户评论的地方需要查询用户头像的url,如果用户多次评论，就会反复执行这个查询。正确的做法是将这个数据缓存起来，需要的时候从缓存取</p>
<p>6.2.2mysql是否在扫描额外的记录</p>
<p>查询过程中是否扫描了过多的数据</p>
<p>衡量查询开销的三个指标：这三个指标都会记录到慢查询日志当中</p>
<p>1.响应时间</p>
<p>响应时间=服务时间+排队时间</p>
<p>2.扫描的行数</p>
<p>较短的行访问速度快，内存中的行也比磁盘中的行的访问速度要快很多</p>
<p>理想情况的扫描行数和返回行数应该是相同的，关联查询时服务器必须扫描多行才能生成结果集中的一行</p>
<p>扫描的行数和访问类型：</p>
<p>mysql有好几种访问方式可以查询并返回一行结果，但各种访问方式扫描的行数是不一样的，在评估查询开销时需要考虑从表中找到某一行数据的成本</p>
<p>Explain 语句的type列反应了访问类型，访问类型从慢到快(扫描行数从小到大)情况如下：</p>
<p>全表扫描&lt;索引扫描&lt;范围扫描&lt;唯一索引扫描&lt;常数引用 </p>
<p>mysql能够使用如下三种方式应用where，从好到坏以此为：1，2啥区别？？</p>
<p>1.在索引中使用where条件来过滤不匹配的记录，这是在存储引擎完成的</p>
<p>2.使用索引覆盖扫描(extra:using index)来返回记录，直接从索引中过滤不需要的记录并返回命中结果，这是在mysql服务器层完成的，且无需回表查询</p>
<p>3.从数据表中返回数据，然后过滤不满足条件的记录(extra:using where),这是在服务器层完成的，mysql需要先从数据表中读出记录然后过滤</p>
<p>索引不是万能的：</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image078.png"  alt="img"></p>
<p>这个查询需要读取几千行数据只返回200行结果，没有什么索引能够让这样的查询减少需要扫描的行数</p>
<p>如果发现查询需要扫描大量的数据而只返回少数的行，那么可以如下优化：</p>
<p>1.使用覆盖索引，存储引擎无需回表</p>
<p>2.改变库表结构，如使用单独的汇总表</p>
<p>3.重写这个复杂的查询</p>
<p>6.3重构查询的方式</p>
<p>6.3.1一个复杂查询还是多个简单查询</p>
<p>按实际情况而定</p>
<p>6.3.2切分查询</p>
<p>有时候需要将一个大查询分而治之，将大查询切分成小查询，每个查询功能完全一样</p>
<p>例如：删除旧的数据</p>
<p>定期地删除大量数据时，如果用一个大的语句一次性完成的话，则可能一次锁住很多数据，占满整个事务日志，耗尽系统资源，阻塞很多小但重要的查询</p>
<p>原sql</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image079.png"  alt="img"></p>
<p>替换方案：一次删除一万行</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image080.png"  alt="a+fected • Ο  ΌΕΙΕΤΕ .essages N-lE2E created &lt; 3  ΙΙΜΙΤ ιοωο“)  } TNs_affected &gt; Ο "></p>
<p>6.3.3分解关联查询</p>
<p>很多高性能的应用都会将关联查询进行分解。可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联</p>
<p>![些 SELECT · tag  ” t 弼 ． ， t t 驾 一 ， t ． t 吨 一 1 t 明 d  ． &gt; JOIN st tag_post.post_id•post.id  可 以 分 解 成 下 面 这 些 查 询 来 代 替 ：  <a href="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image081.png"> ECT ． tag ERE tag•%sql’  mysql&gt; 仃 · 陬 t 一 戛 t t 明 一 i u34 ；  mysql&gt; SELECT · ， t “RE 、 t ． 炻 in （ 123 》 4 ， 7 ， 彈 譯 4 ） ； </a></p>
<p>优点：<br> 1.让缓存的效率更高，许多应用程序可以方便地缓存单表查询对应的结果对象</p>
<p>如果应用中已经缓存了ID为123的内容，那么第三个查询的IN()中就可以少几个ID</p>
<p>如果关联中的某个表发生了变化，那么就无法使用查询缓存了</p>
<p>2.将查询分解后，执行单个查询可以减少锁的竞争</p>
<p>3.在应用层做关联，可以更容易地对数据库进行拆分，更容易做到高性能和可扩展</p>
<p>4.查询本身效率也可能会有所提升</p>
<p>5.可以减少冗余记录的查询，可以减少网路和内存的消耗</p>
<p>6.这样做相当于在应用中实现了hash关联，而不是使用mysql的嵌套循环关联。某些场景哈希关联的效率要高得多</p>
<p>6.4查询执行的基础</p>
<p>mysql的运行流程：</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image082.png"  alt="img"></p>
<p>6.4.1mysql客户端/服务器通讯协议</p>
<p>客户端和mysql服务器之间的通讯协议是半双工的，这意味着我们无法也无需将一个消息切成小块独立来发送</p>
<p>优点：通讯简单快速</p>
<p>缺点：无法进行流量控制</p>
<p>客户端用一个单独的数据包将查询传给服务器，这也就是为什么当查询语句很长的时候，参数max_allowed_packet就特别重要了。一旦客户端发送了请求，它能做的就只有等待结果了（如果查询太大，服务器端会拒绝接受更多的数据并抛出异常）</p>
<p>查询状态：反应mysql连接当前的状态，show full processlist的command表示当前状态</p>
<p>Sleep:线程正在等待客户端发送新的请求</p>
<p>Query:正在执行查询或者正在将结果发送给客户端</p>
<p>Locked:该线程正在等待表锁</p>
<p>Analyzing and statistics:正在收集存储引擎的统计信息，并生成查询的执行计划</p>
<p>Copying to tmp table[on disk]：正在执行查询，将结果集复制到一个临时表（group by,文件排序，union操作，[正在将一个内存临时表放到磁盘上]）</p>
<p>Sorting result:对结果集进行排序</p>
<p>Sending data:线程可能在多个状态之间传送数据；生成结果集；向客户端返回数据</p>
<p>6.4.2查询缓存</p>
<p>解析一个查询语句之前，如果查询缓存是打开的，mysql会优先检查这个查询，这个检查是通过一个对大小写敏感的哈希表查找实现的</p>
<p>查询和缓存中的查询即使只有一个字节不同，也不会匹配缓存结果</p>
<p>当前查询命中缓存，返回查询结果之前mysql会检查一次用户权限，如果权限没问题，会直接返回数据给客户端</p>
<p>6.4.3查询优化处理</p>
<p>将一个sql转换为一个执行计划，mysql再按照这个执行计划和存储引擎进行交互</p>
<p>包括多个子阶段：解析sql，预处理，优化sql执行计划</p>
<p>语法解析器和预处理</p>
<p>语法解析器：</p>
<p>mysql通过关键字将sql语句解析，并生成一颗对应的解析树</p>
<p>mysql解析器使用mysql语法规则验证和解析查询，会验证如下信息：</p>
<p>是否使用错误的关键字，使用的关键字顺序是否正确，引号是否能前后正确匹配</p>
<p>预处理器：</p>
<p>1.进一步检查解析树是否合法，例如检查数据表和数据列是否存在，解析名字和别名是否有歧义</p>
<p>2.验证权限</p>
<p>查询优化器：</p>
<p>语法解析器，预处理器确认语法树是合法的，优化器将其转换为执行计划</p>
<p>一条查询可以有多个执行方式，返回相同的结果，优化器的作用就是找到最好的执行办法</p>
<p>可以通过查询当前会话的last_query_cost的值来判断该查询的成本</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image083.png"  alt="mysqb SELECT caJNT(高性能MySQL.assets/clip_image083.png) sakila.film_actor;  I count(•) I  5462 |  mysql&gt; STATL5 LIKE ;  I Variable_næ Value I  I I 59&quot;0 | "></p>
<p>mysql优化器认为大概需要做1040个数据页的随机查找才能完成上面的查询</p>
<p>last_query_cost的值是通过一系列的统计信息得来的：每个表或者索引的页面个数，索引的基数，索引和数据行的长度，索引分布情况</p>
<p>优化器在优化时不考虑任何层面的缓存，它假设读取任何数据都需要一次磁盘I/O</p>
<p>有很多原因会导致mysql优化器选择错误的执行计划：</p>
<p>1.统计信息不准确</p>
<p>2.成本估算不等同于实际执行的成本，无法做到百分之百准确</p>
<p>3.基于成本选择的最优执行方式不一定是最快的</p>
<p>4.有时候的选择不会基于成本(特殊规则)，全文搜索match()子句，会在存在全文索引的时候优先使用全文索引，无论是否有别的更改的情况</p>
<p>5.mysql不会考虑不受其控制的成本，比如执行存储过程，用户自定义函数</p>
<p>优化策略</p>
<p>静态优化(编译时优化):直接对解析树进行分析，完成优化</p>
<p>例如：静态优化可以通过简单的代数变换将where条件转换为另一种等价形式</p>
<p>静态优化不依赖于特别的数值，第一次完成后就一直有效，即优化后更换sql条件数值不会影响优化方案</p>
<p>动态优化(运行时优化)：和查询的上下文有关，也可能和很多其他因素相关，例如where条件中的取值，索引中条目对应的数据行等</p>
<p>每次查询的时候需要重新评估</p>
<p>mysql能够优化的类型：</p>
<p>1.重新定义关联表的顺序</p>
<p>数据表的关联并总是按照查询中指定的顺序进行的，决定关联的表顺序是优化器很重要的一部分</p>
<p>2.将外连接转换为内连接</p>
<p>where条件，库表结构都可能让外连接等价于一个内连接，mysql能够识别并重写查询，让其可以调整关联顺序</p>
<p>3.使用等价变换规则</p>
<p>使用一些的等价变换来简化并规范表达式，可以合并和减少一些比较，移除一些恒成立，恒不成立的条件</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image084.png"  alt="img"></p>
<p>变成</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image085.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image086.png"  alt="img"></p>
<p>变成</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image087.png"  alt="img"></p>
<p>4.优化count(),min(),max()</p>
<p>Min()是索引最左端的节点</p>
<p>Max()是索引最右端的节点</p>
<p>优化器优化时，会将表达式当做一个常数对待</p>
<p>使用explain可以看到select tables optimized away优化器已经从执行计划中移除了该表，并以常数取代之</p>
<p>没有where条件的count()也可以使用存储引擎提供的一些优化，比如myisam维护了一个变量用来存储数据表的行数</p>
<p>5.预估并转换为常熟表达式</p>
<p>当mysql检测到一个表达式可以转换为常数的时候，就会一直把该表达式作为常数进行优化处理</p>
<p>例如：</p>
<p>1.用户自定义变量在查询中没有发生变化时就可以转换为一个常数</p>
<p>2.数字表达式</p>
<p>3.一个查询，主键，唯一键查询语句，索引列上执行min()函数，mysql查询开始就可以找到这个值</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image088.png"  alt="EXPLAIN SELECT  sakila.fil•  I&quot;ER JOIN  &quot;RE filn.fil. id • 1;  select_type I table  key  I SWLE  I SWLE  I fib  I const I  ref I  ref  CMSt  CMSt  | 10 | "></p>
<p>优化过程第一步：</p>
<p>Where film.film_id=1</p>
<p>Film_id字段上有主键索引，优化器知道只会返回一行数据</p>
<p>第二步：</p>
<p>将第一步返回的film_id当做一个已知取值的列来处理，该值是明确的</p>
<p>可以通过where,using ,on来限制某列取值为常数，上图中使用了using子句，优化器便知道这是限制了film_id在整个查询过程中始终是一个常数(必须等于where子句中的那个值)</p>
<p>6.覆盖索引扫描</p>
<p>7.子查询优化</p>
<p>mysql在某些情况下可以将子查询转换为一种效率更高的形式，从而减少多个查询多次对数据进行访问</p>
<p>8.提前终止查询</p>
<p>在发现已经满足查询需求的时候，mysql能够立刻终止查询</p>
<p>例如：</p>
<p>limit子句</p>
<p>发现不成立的条件，在优化器阶段就会终止查询</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image089.png"  alt="mysql&gt;  EXPLAIN SELECT sakila.filn fil._id  I id Extra  1 11...1  I.ossible &quot;RE after cmst t±les I "></p>
<p>9.等值传播</p>
<p>如果连个列的值通过等式关联，那么mysql能够把其中一个列的where条件传递到另一个列上</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image090.png"  alt="img"></p>
<p>没必要写成这样</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image091.png"  alt="img"></p>
<p>10.列表IN()的比较</p>
<p>mysql中的IN()并不是简单的转换为多个OR条件的子句，而是将()中的数据进行排序，通过二分法查找的方式来确定列表中的值是否满足条件</p>
<p>前者时间复杂度O(n),后者O(logn)</p>
<p>数据和索引的统计信息：</p>
<p>mysql服务器层是没有存储数据的功能的，优化器所需的统计数据是由存储引擎存储的（包括索引）</p>
<p>mysql如何执行关联查询：</p>
<p>mysql认为任何一个查询都是一次关联，而不仅仅指多个表关联查询</p>
<p>Mysql的关联查询策略是嵌套循环关联(实际情况更为复杂)：</p>
<p>如果最后一个关联表中没有找到对应的匹配行，那么mysql会返回到上一层次的关联表，看看能否找到更多匹配记录</p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image092.png"  alt="img"></p>
<p>遇到右外连接时，优化器会将其改成左外连接</p>
<p>mysql会将所有的查询类型都转换成类似的执行计划</p>
<p>mysql不支持全外连接的原因可能是全外连接无法通过嵌套循环和回溯的方式完成，因为关联可能恰好从一个控制开始</p>
<p>执行计划</p>
<p>mysql不会生成查询字节码来执行查询，mysql生成查询的一颗指令树，通过存储引擎执行完成这棵树并返回结果</p>
<p>对某个查询执行explain extended后，再执行show warnings，就可以看到优化器重构出的查询</p>
<p>任何多表查询都可以使用一棵树表示：左侧深度优先的树</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/clip_image093.png"  alt="img"></p>
<p>关联查询优化器</p>
<p>决定多个表关联时的顺序</p>
<p>mysql通过预估的需要读取的数据页来选择，而不是通过读取得到的数据来选择最优的执行结果</p>
<p>合理的关联顺序会让查询进行更少的嵌套查询和回溯操作</p>
<p>可以通过straight_join关键字重写查询，让优化器按照你认为的最优的关联顺序执行</p>
<p> 关联优化器会尝试在所有的关联顺序中选择一个成本最小的来生成执行计划树，如果可能，优化器会遍历每一个表然后逐个做嵌套循环计算每一棵可能执行计划书树的成本，最后返回一个最优的执行计划</p>
<p>糟糕的是，如果有超过n个表的关联，那么需要检查n的阶乘种关联顺序，我们称之为所有可能的执行的搜索空间，搜索空间随表数的增长很快。当搜索空间非常大的时候，优化器不可能逐一评估每一种关联顺序的成本，这是优化器选择使用贪婪搜索的方式查找最优的关联顺序。实际上，当需要关联的表超过optimizer_search_depth的限制时，就会选择贪婪搜索模式，这种启发式的优化策略大多是有效的，但是偶尔也会选择一个不是最优的执行计划</p>
<p>左连接，相关子查询等查询的顺序不能更改，后面的表需要依赖于前面表的查询结果，这种依赖关系通常可以帮助优化器大大减少需要扫描的执行计划数量</p>
<p>排序优化</p>
<p>排序是一个成本很高的操作，应该尽可能避免排序或者尽可能避免对大量数据进行排序</p>
<p> 当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，MySQL讲这个过程统一称为文件排序，即使完全是内存排序不需要任何磁盘文件也是如此</p>
<p> 如果需要排序的数据量小于排序缓冲区，MySQL使用内存进行快速排序，如果内存不够排序，那么MySQL会先将数据分块，对每个独立的块使用快速排序，并将各个块进行合并，最后返回排序结果</p>
<p>MySQL有如下两种排序算法：</p>
<ul>
<li>两次传输排序(旧版本使用)</li>
</ul>
<p>读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行</p>
<p>这需要进行两次数据传输，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，会产生大量的随机I/O,所以两次数据传输的成本非常高，当使用的是MyISAM表的时候，成本可能会更高，因此MyISAM使用系统调用进行数据的读取(MyISAM非常依赖操作系统对数据的缓存)。不过这样做的优点是，在排序的时候存储尽可能少的数据，这就让排序缓冲区中可能容纳尽可能多的行数进行排序</p>
<ul>
<li>单次传输排序(新版本使用)</li>
</ul>
<p> 先读取查询所需要的所有列，然后根据给定列进行排序，最后直接返回排序结果，这个算法只需要一次顺序I/O读取所有的数据，而无须任何的随机I/O，缺点是需要返回的列非常多，会额外占用大量的空间，而这些列对排序本身是没有任何作用的，因为单条排序记录很大，所以可能会有更多的排序块需要合并</p>
<p> 当查询需要所有列的总长度不超过参数max_length_for_sort_data时，MySQL使用单次传输排序</p>
<p> MySQL在进行文件排序的时候需要使用的临时存储空间可能会比想象的要大得多，原因在于MySQL在排序时，对每一个排序记录都会分配一个足够长的定长空间来存放。这个定长空间必须足够长以容纳其中最长的字符串，例如如果是VARCHAR列则需要分配其完整长度，如果使用UTF-8字符集，那么MySQL将会为每个字符预留三个字节</p>
<p> 在关联查询的时候如果需要排序，MySQL会分两种情况来处理这样的文件排序，如果ORDER BY子句中的所有列都来自关联的第一张表，那么MySQL在关联处理第一个表的时候就进行文件排序，如果是这样，那么在MySQL的Explain结果中可以看到Extra字段会有Using filesort。除此以外的所有情况，MySQL都会先将关联的结果存放到一个临时表中，然后在所有的关联结束后，再进行文件排序，这种情况下，Extra字段可以看到Using temporary;Using filesort。如果查询中有LIMIT的话，LIMIT也会在排序之后使用，所以即使需要返回较少的数据，临时表和需要排序的数据量仍然会很大</p>
<p>MySQL5.6在这里做了很多重要的改进，当只需要返回部分排序结果的时候，例如使用改了LIMIT子句，MySQL不再对所有的结果进行排序，而是根据实际情况，选择抛弃不满足条件的结果，然后再进行排序</p>
<p>查询执行引擎</p>
<p>在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎则根据这个执行计划来完成整个查询，这里执行计划是一个数据结构，而不是像其他的关系型数据库那样会产生对应的字节码</p>
<p> 相对于查询优化阶段，查询执行阶段不是那么复杂：MySQL只是简单地根据执行计划给出的指令逐步执行</p>
<p> 在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎实现的接口来完成，这些接口也就是是handler API的接口，查询中的每一个表由一个hanlder实例表示，实际上，MySQL在优化阶段就未每一个表创建了一个hanlder实例，优化器根据这些实例的接口可以获取表的相关信息，包括表的所有列名，索引统计信息等等</p>
<p>并不是所有的操作都由handler完成，</p>
<p>存储引擎接口有着非常丰富的功能，但底层接口却只有几十个，这些接口像搭积木一样能够完成查询的大部分操作。</p>
<p>返回结果给客户端</p>
<p>查询的最后一个阶段是将查询结果返还给客户端，即便客户端不需要结果集，也会返回一些查询信息，例如查询影响到的行数</p>
<p>如果查询可以被缓存，那么myqsl在这个阶段也会将结果放到查询缓存中</p>
<p>返回结果给客户端是一个增量，逐步返回的过程。当服务器处理完最后一个关联表，开始生成第一条结果时，mysql就可以开始给客户端逐步返回结果集了。服务器端无需存储太多的结果，减少内存的消耗；也让Mysql客户端第一时间获得返回的结果</p>
<p> MySQL查询优化器的局限性</p>
<p>关联子查询</p>
<p>MySQL的子查询非常糟糕，最糟糕的一类查询是where条件中包含IN()的子查询。例如希望找到Sakila数据库中，actor_id为1的演员参演过的所有影片信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from sakila.film</span><br><span class="line">where film_id in(</span><br><span class="line">	select film_id from sakila.film_actor where actor_id &#x3D; 1)</span><br></pre></td></tr></table></figure>

<p>因为MySQL对IN()列表中的选项有专门的优化策略，一般会认为MySQL会先执行子查询返回所有包含actor_id为1的film_id,IN()列表查询速度很快，所以我们会认为上面的查询会是这样执行的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from sakila.film where film_id in(1,2,3,4)</span><br></pre></td></tr></table></figure>

<p>很不幸，MySQL不是这样做的，MySQL会将相关的外层表压到子查询中，MySQL会将查询改写成下面的样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from sakila.film</span><br><span class="line">where exists(</span><br><span class="line">	select * from sakila.film_actor where actor_id &#x3D; 1</span><br><span class="line">	and film_actor.film_id &#x3D; film.film_id)</span><br></pre></td></tr></table></figure>

<p> 这时，子查询需要根据film_id来关联外部表film,因为需要film_id字段，所以MySQL认为无法先执行这个子查询，通过explain可以发现子查询是一个相关子查询</p>
<p> 100</p>
<p>根据explain的输出可以看出，MySQL先选择对film表进行全表扫描，然后根据返回的film_id逐个执行 子查询，如果是小表性能还不会很糟糕，但是如果外层是一个很大的表，那么这个查询的性能会非常糟糕</p>
<p>可以重写这个查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select film.* from sakila.film</span><br><span class="line">	inner join sakila.film_actor using(film_id)</span><br><span class="line">	where actor_id &#x3D; 1</span><br></pre></td></tr></table></figure>

<p> 另一个优化的办法是使用group_concat()在IN()构造一个由逗号分隔的列表，有时这比上面的使用关联改写更快。因为使用IN()加子查询，性能经常会非常糟，所以通常建议使用exists()等效的改写查询来获取更好的效率，下面是另一种改写IN()加子查询的办法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from sakila.film</span><br><span class="line">where exists(</span><br><span class="line">	select * from sakila.film_actor where actor_id &#x3D; 1</span><br><span class="line">	and film_actor.film_id &#x3D; film.film_id)</span><br></pre></td></tr></table></figure>



<p>如何利用好关联子查询</p>
<p>并不是所有关联子查询的性能都会很差，正确使用的关联子查询是一种很好的写法</p>
<p> 101</p>
<p> 一般会建议使用左外连接重写该查询，以替代子查询，理论上，改写后MySQL的执行计划完全不会发生变化</p>
<p>102</p>
<p>但是存在着一些微小的区别</p>
<ul>
<li><p>表film_actor的访问类型一个是dependent subquery,而另一个是simple，这个不同是由于语句的写法不同导致的，一个是普通查询，一个是子查询，这对底层存储引擎接口来说，没有任何不同</p>
</li>
<li><p>对film表，第二个查询的Extra中没有using where,第二个查询的using子句和第一个查询的where子句实际上是一样的</p>
</li>
<li><p>在第二个表film_actor的执行计划的extra列有not exists,mysql通过使用not exists优化来避免在表film_actor索引中读取任何额外的行，这完全等效于直接编写not exists子查询，这个执行计划中也是一样，一旦匹配到一行数据，就立即停止扫描</p>
<p>理论上讲，MySQL将使用完全相同的执行计划来完成这两个查询，面对不同的情况，两种写法的效率存在一定的差距，具体效率高低要依据测试数据而定</p>
</li>
</ul>
<p>MySQL5.1.48之前，下面的写法会锁住table2中的一条记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table1 where col &#x3D; (select col from table2 wehre ..)</span><br></pre></td></tr></table></figure>



<p>UNION限制</p>
<p>有时，MySQL无法将限制条件从外层下推到内存，这使得原本能够限制部分返回结果的条件无法应用到内存查询的优化上</p>
<p>104</p>
<p>这条查询将会把actor中的200条记录和customer表中的599条记录存放在一个临时表中，然后再从临时表中取出前20条，可以通过Union的两个子查询中分别加上一个limit 20来减少临时表的数据</p>
<p>105</p>
<p> 索引合并优化</p>
<p>当where子句中包含多个复杂条件的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行</p>
<p>等值传递</p>
<p>等值传递会带来一些意想不到的额外消耗，例如有一个非常大的IN()列表，而MySQL优化器发现存在where ,on或者using的子句，将这个列表的值和另一个表的某个列相关联，那么优化器会将IN()列表都复制应用到关联的各个表中，通常，因为各个表新增了过滤条件，优化器可以更高地从存储引擎过滤记录，但是如果这个列非常大，则会导致优化和执行都会变慢</p>
<p>并行执行</p>
<p>MySQL无法利用多核特性来并行执行查询</p>
<p>松散索引扫描</p>
<p>MySQL并不支持松散索引扫描，也就无法按照不连续的方式扫描一个索引，通常，MySQL的索引扫描需要先定义一个起点和终点，即使需要的数据只是这段索引中很少数的几个，MySQL仍需扫描这段索引中的每一个条目</p>
<p>假如有如下索引(a,b)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb1 where b between 2 and 3;</span><br></pre></td></tr></table></figure>

<p> 因为索引的前导字段是列a,但是在查询中只指定了字段b,MySQL无法使用这个索引，从而只能通过全表扫描找到匹配的行</p>
<p>106</p>
<p> 可以有一个更快的办法执行上面的查询，索引的物理结构使得可以先扫描a列第一个值对应的b列的范围，然后再跳到a列第二个不同值扫描对应的b列的范围，</p>
<p>107</p>
<p>注意到，这时就无须再使用where子句过滤，因为松散索引扫描已经跳过了所有不需要的记录</p>
<p> MySQL5.0之后的版本，在某些特殊的场景下是可以使用松散索引扫描的，例如，在一个分组查询中需要找到分组的最大值和最小值</p>
<p>108</p>
<p>在explain中的extra字段显示using index for group-by,表示这里将使用松散索引扫描，不过如果MySQL能写上loose index probe会更好理解</p>
<p>最大值和最小值优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select min(actor_id) from sakila.actor where first_name &#x3D; &#39;penelope&#39;</span><br></pre></td></tr></table></figure>

<p> 因为first_name字段上并没有索引，因此MySQL将会进行一次全表扫描，如果MySQL能够进行主键扫描，当MySQL读到第一个满足条件的记录的时候，就是我们需要找的最小值了，因为主键是严格按照actor_id字段的大小的顺序排列的，但是MySQL这时只会做全表扫描，我们可以通过查看show status的全表扫描计数器来验证。一个曲线的优化办法是移除MIN(),然后使用LIMIT来将查询重写如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select actor_id from sakila.actor use index(primary)</span><br><span class="line">where first_name &#x3D; &#39;penelope&#39; limit 1;</span><br></pre></td></tr></table></figure>

<p> 这个sql并不能明确地表达本意，但是有时候为了获得更高的性能，我们不得不放弃一些原则</p>
<p>在同一个表上查询和更新</p>
<p>MySQL不允许对用一张表同时进行查询和更新，下面是一个无法运行的sql,虽然这是一个符合标准的sql语句。</p>
<p>109</p>
<p>可以通过使用生成表的形式来绕过上面的限制，因为MySQL只会把这个表当作一个临时表来处理。这执行了两个查询，一个是子查询中的select语句，另一个是多表关联update,只是关联的表是一个临时表，子查询会在update语句打开表之前就完成，所以下面的查询将会正常执行</p>
<p>110</p>
<p>查询器优化器的提示(hint)</p>
<p>如果对优化器选择的执行不满意，可以使用优化器提供的几个提示(hint)来控制最终的执行计划。通过在查询中加入相应的提示，就可以控制    该查询的执行计划</p>
<p>HIGH_PRIORITY和LOW_PRIORITY</p>
<p>这个提示告诉MySQL，当多个语句同时访问某一个表的时候，那些语句的优先级相对高些，那些语句的优先级相对低些</p>
<p>HIGH_PRIORITY用于select语句的时候，MySQL会将此SELECT语句重新调度到所有正在等待表锁以便修改数据的语句之前。实际上MySQL是将其放在表的队列的最前面，而不是按照常规顺序等待。HIGH_PRIORITY还可以用于INSERT语句，其效果只是简单地抵消了全部LOW_PRIORITY设置对该语句的影响</p>
<p>LOW_PRIORITY则正好相反，它会让该语句一直处于等待状态，只要队列中还有需要访问同一个表的语句——即使是那些比该语句还晚提交到服务器的语句。LOW_PRIORITY提示在select,insert,update和delect语句中都可以使用</p>
<p>这两个提示只对使用表锁的存储引擎有效，千万不要在InnoDB或者其他有细粒度锁机制和并发控制的引擎中使用。即使是在MyISAM中使用也要注意，因为这两个提示会导致并发插入被禁用，可能会严重降低性能</p>
<p>HIGH_PRIORITY和LOW_PRIORITY这两个提示并不会获取更多资源让查询积极工作，也不会少获取资源让查询消极工作，它们只是简单地控制了MySQL访问某个数据表的队列顺序</p>
<p>DELAYED</p>
<p>这个提示对insert和replace有效，mysql会将使用该提示的语句立即返回给客户端，并将插入的行数据放入到缓冲区，然后在表空闲时批量将数据写入，日志系统使用这样的提示非常有效，或者是其他需要写入大量数据但是客户端却不需要等待单条语句完成I/O的应用，这个用法有些限制，并不是所有的存储引擎都支持这样的做法，并且该提示会导致函数LAST_INSERT_ID()无法正常工作</p>
<p>STRAIGHT_JOIN</p>
<p>这个提示可以放置在select语句的select关键字之后，也可以放置在任何两个关联表的名字之间。第一个用法是让查询中所有的表按照在语句中出现的顺序进行关联，第二个用法则是固定其前后两个表的关联顺序</p>
<p>当mysql没能选择正确的关联顺序的时候，或者由于可能的顺序太多导致MySQL无法评估所有的关联顺序的时候，STRAIGHT_JOIN都会很有用，在后面这种情况，MySQL可能会花费大量时间在statistics状态，加上这个提示则会大大减少优化器的搜索空间</p>
<p>可以先使用explain语句来查看优化器选择的关联顺序，然后使用该提示来重写查询，再看看它的关联顺序。当你确定无论怎样的where条件，某个固定的关联顺序总是最佳的时候，使用这个提示可以大大提高优化器的效率。但是在升级MySQL版本的时候，需要重新审视下这类查询，某些新的优化特性可能会因为该提示而失效</p>
<p>SQL_SMALL_RESULT和SQL_BIG_RESULT</p>
<p>这两个提示只对select语句有效，它们告诉优化器对group by或者distinct查询如何使用临时表及排序。SQL_SMALL_RESULT告诉优化器结果集会很小，可以将结果集放在内存中的索引临时表，以避免排序操作。如果是SQL_BIG_RESULT，则告诉优化器结果集可能会非常大，建议使用磁盘临时表做排序操作</p>
<p>SQL_BUFFER_RESULT</p>
<p>这个提示告诉优化器将查询结果放入到一个临时表，然后尽可能快地释放表锁。这和前面提到的由客户端缓存结果不同。当你没法使用客户端缓存的时候，使用服务器端的缓存通常很有效。带来的好处是无须在客户端上消耗太多的内存，还可以尽可能快地释放对应的表锁。代价是服务器端将需要更多的内存</p>
<p>SQL_CACHE和SQL_NO_CACHE</p>
<p>这个提示告诉MySQL这个结果集是否应该缓存在查询缓存中</p>
<p>SQL_CALC_FOUND_ROWS</p>
<p>严格来说这并不是一个优化器提示，它不会告诉优化器任何关于执行计划的东西，它会让MySQL返回的结果集包含更多的信息。查询加上该提示MySQL会计算除去LIMIT子句后这个查询要返回的结果集的总数，而实际上只返回LIMIT要求的结果集，可以通过函数FOUND_ROW()获得这个值</p>
<p>FOR UPDATE和LOCK IN SHARE MOOD</p>
<p>这也并不是真正的优化器提示，这两个提示主要控制select语句的锁机制，但只对实现了行级锁的存储引擎有效。使用该提示会对符合查询条件的数据行加锁，对于INSERT…SELECT语句是不需要这两个提示的，因为对于MySQL5.0和更新版本会默认给这些记录加上读锁</p>
<p>唯一内置的支持这两个提示的引擎就是InnoDB，这两个提示会让某些优化无法正常使用，例如索引覆盖扫描，InnoDB不能在不访问主键的情况下排他地锁定行，因为行的版本信息保存在主键中</p>
<p>这两个提示经常被滥用，很容易造成服务器的锁争用问题</p>
<p>USE_INDEX,IGNORE INDEX和FORCE INDEX</p>
<p>这几个提示会告诉优化器使用或者不使用那些索引来查询记录，例如决定关联顺序的时候使用哪个索引。在5.0之前，这些提示并不会影响到优化器选择哪个索引进行排序和分组，在5.1之后的本本可以通过新增选项FOR ORDER BY和FOR GROUP BY来指定是否对排序和分组有效</p>
<p>FORCE INDEX和USE INDEX基本相同，FORCE INDEX会告诉优化器全表扫描的成本远远高于索引扫描，哪怕实际上该索引用处并不大。当发现优化器选择了错误的索引，或者因为某些原因要使用另一个索引时，可以使用该提示</p>
<p>optimizer_search_depth</p>
<p>这个参数控制优化器在穷举执行计划的限度，如果查询长时间处于statistics状态，那么可以考虑降低此参数</p>
<p>optimizer_prune_level</p>
<p>该参数默认是打开的，这让优化器会根据需要扫描的行数来决定是否跳过某些执行计划</p>
<p>optimizer_switch</p>
<p>这个变量包含了一些开启/关闭优化器特性的标志位</p>
<p>MySQL升级后的验证</p>
<p>使用Percona Toolkit中的pt-upgrade工具，就可以检查在新版本中运行的SQL是否与老版本一样，返回相同的结果</p>
<p>优化特定类型的查询</p>
<p>优化count()查询</p>
<p>count()有两种非常不同的作用，它可以统计某个列值的数量，也可以统计行数。在统计列值时要求列值是非空的(不统计null)，如果在count()的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数</p>
<p>count()的另一个作用是统计结果集的行数，当MySQL确认括号内的表达式值不可能为空时，实际上就是在统计行数，最常用的就是count(*)</p>
<p>关于MyISAM的神话</p>
<p>在MyISAM中，只有没有任何where条件的count(*)才会非常快，无须实际地去计算表的行数，MySQL可以利用存储引擎的特性直接获取这个值</p>
<p>如果MySQL知道某列col不可能为null值，那么MySQL内部会将count(col)表达式优化为count(*)</p>
<p>统计带where子句的结果集行数，可以统计某个列值的数量时，MyISAM的count()和其他存储引擎没有任何不同，就不再有神话般的速度了</p>
<p>简单的优化</p>
<p>使用标准库world来看看如何快速查找到所有ID大于5的城市</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select count(*) from world.city where id &gt; 5</span><br></pre></td></tr></table></figure>

<p>如果将条件反转一下，则能很大程度上减少需要扫描的行数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	( SELECT COUNT ( * ) FROM world.city ) - COUNT ( * ) </span><br><span class="line">FROM</span><br><span class="line">	world.city </span><br><span class="line">WHERE</span><br><span class="line">	id &lt;&#x3D; 5</span><br></pre></td></tr></table></figure>

<p>如何在同一个查询中统计同一个列的不同值的数量，以减少查询的语句量。例如需要通过一个查询返回各种各不同颜色的商品数量，此时不同使用OR语句,因为这样就无法区分不同颜色的商品数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT</span><br><span class="line">	( color &#x3D; &#39;blue&#39; OR color &#x3D; &#39;red&#39; ) </span><br><span class="line">FROM</span><br><span class="line">	items</span><br></pre></td></tr></table></figure>

<p>也不能在where条件中指定颜色，因为颜色的条件是互斥的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT</span><br><span class="line">	( * ) </span><br><span class="line">FROM</span><br><span class="line">	items </span><br><span class="line">WHERE</span><br><span class="line">	color &#x3D; &#39;blue&#39; </span><br><span class="line">	AND color &#x3D; &#39;red&#39;</span><br></pre></td></tr></table></figure>

<p> 下面的查询能够一定程度上解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	SUM</span><br><span class="line">	(</span><br><span class="line">	IF( color &#x3D; &#39;blue&#39;, 1, 0 )</span><br><span class="line">	) AS blue,</span><br><span class="line">	</span><br><span class="line">	SUM (</span><br><span class="line">	IF( color &#x3D; &#39;red&#39;, 1, 0 )</span><br><span class="line">	) AS red </span><br><span class="line">FROM</span><br><span class="line">	items</span><br></pre></td></tr></table></figure>

<p> 也可以使用count()而不是sum()实现同样的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	COUNT</span><br><span class="line">	(</span><br><span class="line">	IF( color &#x3D; &#39;blue&#39; OR NULL)</span><br><span class="line">	) AS blue,</span><br><span class="line">	</span><br><span class="line">	COUNT (</span><br><span class="line">	IF( color &#x3D; &#39;red&#39; OR NULL)</span><br><span class="line">	) AS red </span><br><span class="line">FROM</span><br><span class="line">	items</span><br></pre></td></tr></table></figure>



<p> 使用近似值</p>
<p> 针对某些并不需要完全精确的count值，可以使用explain出来的优化器估算的行数，这是一个近似值，执行explain并不需要真正地去执行查询，成本很低</p>
<p>更复杂的优化</p>
<p>count()需要扫描大量的行才能获得精确的结果，是很难优化的，mysql层面只能索引覆盖扫描</p>
<p>优化关联查询</p>
<p>确保ON或者USING子句中的列上有索引，在创建索引的时候就要考虑到关联的顺序。当表A和表B用c关联的时候，如果优化器的关联顺序是B,A，那么就不需要在B表的对应列上建索引。没有用到的索引只会带来额外的负担。除非有其他理由，否则只需要在关联顺序的第二个表的相应列上创建索引</p>
<p>确保任何的group by和order by中的表达式只涉及到一个表的列，这样MySQL才有可能使用索引来优化这个过程</p>
<p>升级MySQL的时候需要注意，关联语法，运算符优先级等其他可能会发生变化的地方，因为以前是普通关联的地方可能会变成笛卡尔积，不同类型的关联可能会生成不同的结果</p>
<p>优化子查询</p>
<p>关于子查询优化就是尽可能使用关联查询代替</p>
<p> 优化group by和distinct</p>
<p>MySQL都使用同样的办法优化这两种查询，优化器在内部处理的时候相互转换这两类查询，它们都可以使用索引来优化，这也是最有效的优化办法</p>
<p>当无法使用索引的时候，group by使用两种策略来完成，使用临时表或者文件排序来做分组，对于任何查询语句，这两种策略的性能都有可以提升的地方。可以通过使用提示SQL_BIG_RESULT和SQL_SMALL_RESULT来让优化器按照你希望的方式运行</p>
<p>如果需要对关联查询做分组group by，并且是按照查找表中的某个列进行分组，那么通常采用查找表的标识分组的效率会比其他列更高</p>
<p>下面的查询效率不会很好</p>
<p>111</p>
<p>按照下面的写法效率则会更高</p>
<p>112</p>
<p>使用actor.actor_id列分组的效率甚至会比使用film_actor.actor_id的效率更好</p>
<p> 这个查询利用了演员的姓名和ID直接相关的特点，因此改写后的结果不受影响，但显然不是所有的关联语句的分组查询都可以改写成在select中直接使用非分组列的形式的。设置可能在服务器上设置SQL_MODE来禁止这样的写法。如果是这样，也可以通过MIN()或者MAX()函数来绕过这种限制，select后面出现的非分组列一定是直接依赖分组列，并且在每个组内的值是唯一的</p>
<p>在分组查询的select中直接使用非分组列通常都不是什么好注意，因为这样的结果通常是不定的，当索引改变，或者优化器选择不同的优化策略时都可能导致结果不一样。建议将mysql的sql_mode设置为包含ONLY_FULL_GROUP_BY,这时MySQL会对这类查询直接返回一个错误</p>
<p> 如果没有通过order by子句显式地指定排序列，当查询使用group by子句的时候，结果集会自动按照分组的字段进行排序。如果不关注结果集的顺序，而这种默认排序又导致了需要文件排序，则可以使用order by full，让mysql不再进行文件排序，也可以在group by子句中直接使用desc或者asc关键字，使分组的结果集按需要的方向排序</p>
<p>优化group by with rollup</p>
<p>分组查询的一个变种就是要求Mysql对返回的分组结果再做一次超级聚合，可以使用with rollup子句来实现这种逻辑。可以通过explain来观察其执行，特别注意分组是否是通过文件排序或者联合表实现的，然后再去掉with rollup子句看执行计划是否相同</p>
<p>很多时候，如果可以，在应用程序中做超级聚合是更好的，虽然这需要返回给客户端更多的结果，也可以在from子句中嵌套使用子查询，或者是通过一个临时表存在中间数据，然后和临时表执行union来得到最终结果</p>
<p>最好的办法是尽可能的将with rollup功能转移到应用程序中处理</p>
<p>优化LIMIT分页</p>
<p>在系统中需要进行分页操作的时候，通常会使用limit加上偏移量的办法实现，同时加上合适的order by子句，如果有对应的索引，通常效率会不错，否则，mysql需要做大量的文件排序操作</p>
<p>一个非常常见又令人头疼的问题是，在偏移量非常大的时候，例如可能是LIMIT1000,20这样的查询，这时MySQL需要查询10020条记录然后只返回最后20条，前面10000条记录都将被抛弃，这样的代价非常高，如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据。要么优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能</p>
<p>优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列，对于偏移量很大的时候，这样做的效率会提升非常大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	film_id,</span><br><span class="line">	description </span><br><span class="line">FROM</span><br><span class="line">	sakila.film </span><br><span class="line">ORDER BY</span><br><span class="line">	title </span><br><span class="line">	limit 50,</span><br><span class="line">	5;</span><br></pre></td></tr></table></figure>

<p>如果这个表非常大，那么这个查询最好改写成下面的样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	film.film_id,</span><br><span class="line">	film.description </span><br><span class="line">FROM</span><br><span class="line">	sakila.film</span><br><span class="line">	INNER JOIN ( SELECT film_id FROM sakila.film ORDER BY title limit 50, 5 ) AS lim USING (</span><br><span class="line">	film_id)</span><br></pre></td></tr></table></figure>

<p> 延迟关联将大大提升查询效率，它让mysql扫描尽可能少的页面，获取需要访问的记录后再根据关联列回原表查询需要的所有列，这个技术也可以用于优化关联查询中的LIMIT子句</p>
<p>也可以将LIMIT查询转换为已知位置的查询，让MySQL通过范围扫描获得到对应的结果。例如，如果在一个位置列上有索引，并且预先计算出了边界值，上面的查询就可以改写为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	film.film_id,</span><br><span class="line">	film.description </span><br><span class="line">FROM</span><br><span class="line">	sakila.film </span><br><span class="line">WHERE</span><br><span class="line">	position BETWEEN 50 </span><br><span class="line">	AND 54 </span><br><span class="line">ORDER BY position</span><br></pre></td></tr></table></figure>

<p> 对数据进行排名的问题也与此类型，但往往还会同时和group by混合使用，这种情况下通常都需要预先计算并存储排名信息</p>
<p>LIMIT和OFFSET的问题，其实是OFFSET的问题，它会导致MySQL扫描大量不需要的行然后再抛弃掉，如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免OFFSET</p>
<p>例如若需要按照租借记录做翻页，那么可以根据最新一条租借记录向后追溯，这样做法可行是因为租借记录的主键是单调增长的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from sakila.rental order by rental_id DESC LIMIT 20</span><br></pre></td></tr></table></figure>

<p>假设上面的查询返回的是主键为16049到16030的租借记录，那么下一页查询就可以从16030这个这个点开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	sakila.rental </span><br><span class="line">WHERE</span><br><span class="line">	rental_id &lt; 16030 </span><br><span class="line">ORDER BY</span><br><span class="line">	rental_id DESC </span><br><span class="line">	LIMIT 20</span><br></pre></td></tr></table></figure>

<p>其他优化办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表只包含主键列和需要做排序的数据列</p>
<p>优化SQL_CALC_FOUND_ROWS</p>
<p>分页的时候，另一个常见的技巧是在LIMIT语句加上SQL_CALC_FOUND_ROWS提示(hint)，这样就可以获得去掉LIMIT以后满足条件的行数，可以用作分页的总数</p>
<p>MySQL只有在扫描了所有满足条件的行以后，才会知道行数，所以加上这个提示以后，不管是否需要，MySQL都会扫描所有满足条件的行，然后再抛弃掉不需要的行，而不是在满足LIMIT的行数后就终止扫描，所以该提示的代价可能非常高</p>
<p>一个更好的设计是将具体的页数换成下一页按钮，假设每页显示20条记录，那么我们每次查询时都是用LIMIT返回21条记录并只显示20条，如果第21条存在，那么就显示下一页按钮</p>
<p>另一种做法是先获取并缓存较多的数据，例如缓存1000条，然后每次分页都从这个缓存中获取。如果结果集少于1000，因为数据都在缓存中，所以就可以在页面上显示所有的分页连接；如果结果集大于1000，则可以在页面上设计一个额外的”找到的结果多于1000条“值类的按钮。这两种策略都比每次生成全部结果集再抛弃不需要的数据的效率要高得多</p>
<p>有时候也可以考虑使用explain的结果中的rows列的值来作为结果集总数的近似值。当需要精确结果的时候，再单独使用count(*)来满足需求，这时如果能够使用索引覆盖扫描则通常也会比SQL_CALC_FOUND_ROWS快得多</p>
<p>优化UNION查询</p>
<p>MySQL总是通过创建并填充临时表的方式来执行UNION查询，因此很多优化策略在UNION查询中都没法很好地使用，经常需要手工地将where,limit,order by等子句下推到UNION的各个子查询中，以便优化器可以充分利用这些条件进行优化，例如可以直接将这些子句冗余地写一份到各个子查询</p>
<p>除非确实需要服务器消除重复的行，否则就一定要使用UNION ALL,如果没有ALL,MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性检查，这样的代价非常高，即使有ALL关键字，MySQL仍然会使用临时表存储结果，MySQL总是将结果放入临时表，然后再读出，再返回给客户端</p>
<p>使用用户自定义变量</p>
<p>用户自定义变量是一个容易被遗忘的MySQL特性，但是如果能够用好，发挥其潜力，在某些场景可以写出非常高效的查询语句。在查询中混合使用过程化和关系化逻辑的时候，自定义变量可能会非常有用。单纯的关系查询将所有的东西都当成无序的数据集合，并且一次性操作它们。MySQL则采用了更加程序化的处理方式，MySQL的这种方式有它的弱点，但能熟练地掌握，则会发现其强大之处，而用户自定义变量也可以给这种方式带来很大的帮助</p>
<p>用户自定义变量是一个用来存储内容的临时容器，在连接MySQL的整个过程中都存在，可以使用下面的SET和SELECT语句来定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set @one      :&#x3D;1;</span><br><span class="line">set @min_actor:&#x3D;(select min(actor_id) from sakila.actor);</span><br><span class="line">set @last_week:&#x3D;CURRENT_DATE-INTERVAL 1 WEEK;</span><br></pre></td></tr></table></figure>

<p>然后可以在任何可以使用该表达式的地方使用这些自定义变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ... where col &lt;&#x3D; @last_week;</span><br></pre></td></tr></table></figure>

<p>先看看自定义变量的一些属性和限制，看看哪些场景下我们不能使用用户自定义变量</p>
<p>1.使用自定义变量的查询，无法使用查询缓存</p>
<p>2.不能在使用常量或者标识符的地方使用自定义变量，例如表名，列名和LIMIT子句中</p>
<p>3.用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信</p>
<p>4.如果使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互(代码bug或者连接池bug)</p>
<p>5.在5.0之前的版本，是大小写敏感的，所以要注意代码在不同MySQL版本间的兼容性问题</p>
<p>6.不能显示地声明自定义变量的类型，确定未定义变量的具体类型的时机在不同MySQL版本中也可能不一样。如果希望变量是整数类型，那么最好在初始化的时候就赋值为0，如果希望是浮点型则赋值为0.0，如果希望是字符串则赋值为’’,用户自定义变量的类型在赋值的时候会发生改变。MySQL的用户自定义变量是一个动态类型</p>
<p>7.MySQL优化器在某些场景下可能会将这些变量优化掉，这可能导致代码不按预想的方式运行</p>
<p>8.赋值的顺序和赋值的时间点并不是固定的，这依赖于优化器的决定</p>
<p>9.赋值符号:=的优先级非常低，赋值表达式应该使用明确的括号</p>
<p>10.使用未定义变量不会产生任何语法错误，如果没有意识到这一点，非常容易犯错</p>
<p>优化排名语句</p>
<p>使用用户自定义变量的一个重要特性是你可以在给一个变量赋值的同时使用这个变量。用户自定义变量的赋值具有”左值“特性，下面的例子展示了如何使用变量来实现一个类似行号的功能</p>
<p>113</p>
<p>编写一个查询获取演过最多电影的前10位演员，然后根据他们出演电影次数做一个排名，如果出演的电影数量一样，则排名相同，先编写一个查询，返回每个演员参演电影的数量</p>
<p>114</p>
<p>115</p>
<p>现在再把排名加上去，这里看到四名演员都参演了35部电影，所以他们的排名应该是相同的，我们使用三个变量来实现，一个用来记录当前排名，一个用来记录前一个演员的排名，还有一个用来记录当前演员参演的电影数量。只有当前演员参演的电影的数量和前一个演员不同时，排名才变化</p>
<p>116</p>
<p>排名和统计列一直都无法更新，这是什么原因？</p>
<p>通过explain可以看到将会使用临时表和文件排序，所以可能是由于变量赋值的时间和我们预料的不同</p>
<p>在使用用户自定义变量的时候，经常会遇到一些诡异的问题，使用sql语句生成排名值通常需要做两次计算，例如，需要额外计算一次出演过相同数量电影的演员有哪些，使用变量则可以一次完成</p>
<p>针对这个案例，另一个简单的方案是在子句中使用子查询生成一个中间的临时表</p>
<p>117</p>
<p>避免重复查询刚刚更新的数据</p>
<p>如果在更新行的同时又希望获得该行的信息，要怎么做才能避免重复的查询？MySQL并不像PostgreSQL那样的UPDATE RETURNING语法，可以在更新行的同时返回改行的信息。MySQL中可以使用变量来解决这个问题，例如，一个客户端希望能够更高效地更新一条记录的时间戳，同时希望查询当前记录中存放的时间戳是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update t1 set lastUpdated &#x3D; NOW() where id &#x3D; 1;</span><br><span class="line">select lastUpdated from t1 where id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>使用变量，我们可以按如下方式重写查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update t1 set lastUpdated &#x3D; NOW() where id &#x3D; 1 AND @now:&#x3D;NOW();</span><br><span class="line">select @NOW;</span><br></pre></td></tr></table></figure>

<p>看起来虽然仍然需要两个查询，需要两次网络来回，但是这里的第二个查询无须访问任何数据表，所以会快非常多</p>
<p>统计更新和插入的数量</p>
<p>当使用了INSERT ON DUPLICATE KEY UPDATE，如果想知道到底插入了多少行数据，到底有多少数据是因为冲突而改写成更新操作的</p>
<p>118</p>
<p>当每次由于冲突导致更新时对变量@x自增一次，然后通过对这个表达式乘以0来让其部影响要更新的内容，另外，MySQL的协议会返回被更改的总行数，所以不需要单独统计这个值</p>
<p>确定取值的顺序</p>
<p>使用用户自定义变量的一个最常见的问题就是没有注意到在赋值和读取变量的时候可能是在查询的不同阶段，例如，在select子句中进行赋值然后在where子句中读取变量，则可能变量取值并不是想要的那样，下面的查询看起来只返回一个结果，但事实却并非如此</p>
<p>119</p>
<p>因为where和select是在查询执行的不同阶段被执行的，如果在查询中再加入order by的话，结果可能会更不同</p>
<p>120</p>
<p>这是因为order by引入了文件排序，而where条件是在文件排序操作之前取值的，所以这条查询会返回表中的全部记录，解决这个问题的办法是让变量的赋值和取值发生在执行查询的同一阶段</p>
<p>121</p>
<p>如果在上面的查询中再加上order by，会发生什么？下面的查询中order by子句会改变变量值，那where语句执行时变量值是多少</p>
<p>122</p>
<p>这个最出人意料的变量行为的答案可以在explain语句中找到，主要看在extra列中的using where,using temporary或者using filesort</p>
<p>将赋值语句放到least()函数中，这样就可以在完全不改变排序顺序的时候完成赋值操作(上面的例子中，LEAST()函数总是返回0)，这个技巧在不希望对子句执行结果有影响却又要完成变量赋值的时候很有用。这个例子中，无须在返回值中给新增额外列，这样的函数还有GREATEST(),LENGTH(),ISNULL(),NULLIFL(),IF(),COALESCE(),可以单独使用也可以组合使用，例如，COALESCE()可以在一组参数中取第一个已经被定义的变量</p>
<p>编写偷懒的UNION</p>
<p>假设需要编写一个UNION查询，其第一个子查询作为分支条件先执行，如果找到了匹配的行，则跳过第二个分支，在某些业务场景中确实会有这样的需求，比如先在一个频繁访问的表中查找热数据，找不到再去另一个较少访问的表中查找冷数据(区分热数据和冷数据是一个很好的提高缓存命中率的办法)</p>
<p>下面的查询会在两个地方查找一个用户，一个是主用户表，一个长时间不活跃的用户表，不活跃用户表的目的是为了实现更高效的归档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id from users where id &#x3D; 123</span><br><span class="line">union all</span><br><span class="line">select id from users_archived where id &#x3D; 123;</span><br></pre></td></tr></table></figure>

<p>即使在users表中已经找到了记录，上面的查询还是会去归档表users_archived中再查找一次，可以用一个偷懒的UNION查询来抑制这样的数据返回，而且只有当第一个表中没有数据时，我们才在第二个表中查询。一旦第一个表中找到记录，我们就定义一个变量@found,通过在结果列中做一次赋值来实现，然后将赋值放在函数GREATEST中来避免返回额外的数据，为了明确结果到底来自哪个表，我们新增一个包含表名的列，最后需要在查询的末尾将变量重置为NULL，这样保证遍历时不干扰后面的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select GREATEST(@found :&#x3D; -1,id)as id,&#39;users&#39;as which_tb1</span><br><span class="line">from users where id &#x3D; 1</span><br><span class="line">union all</span><br><span class="line">	select id,&#39;users_archived&#39;</span><br><span class="line">	from users_archived where id &#x3D; 1 and @found IS NULL</span><br><span class="line">union all</span><br><span class="line">	select 1, &#39;reset&#39; from DUAL where(@found:&#x3D;NULL) is not null;</span><br></pre></td></tr></table></figure>



<p>用户自定义变量的其他好处</p>
<p>在任何类型的SQL语句中都可以对变量进行赋值，这也是用户自定义变量最大的用途，例如可以像前面使用子查询的方式改进排名语句一样来改进UPDATE语句</p>
<p>有时优化器会把变量当作一个编译时常量来对待，而不是对其进行赋值，将函数放在类似于LEAST()这样的函数中通常不可避免这样的问题。另一个办法是在查询被执行之前检查变量是否被赋值，不同的场景使用不同的办法</p>
<p>通过一些实践，可以了解所有用户自定义变量能够做的有趣的事情，例如下面这些用法</p>
<ul>
<li><p>查询运行时计算总数和平均值</p>
</li>
<li><p>模拟group语句中的函数first()和last()</p>
</li>
<li><p>对大量数据做一些数据计算</p>
</li>
<li><p>计算一个大表的MD5散列值</p>
</li>
<li><p>编写一个样本处理函数，当样本中的数值超过某个边界值的时候将其变成0</p>
</li>
<li><p>模拟读写游标</p>
</li>
<li><p>在show语句的where子句中加入变量值</p>
</li>
</ul>
<p>案例学习跳过了，看不懂？？？</p>
<h1 id="MySQL高级特性"><a href="#MySQL高级特性" class="headerlink" title="MySQL高级特性"></a>MySQL高级特性</h1><h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>分区表是一个独立的逻辑表，但是底层由多个物理子表组成。实现分区的代码实际上是对一组底层表的句柄对象的封装，对分区表的请求，都会通过句柄对象转换成对存储引擎的接口调用。所以分区对于SQL层来说是一个完全分装底层实现的黑盒子，对应用是透明的，但是从底层的文件系统来看就很容易发现，每一个分区表都有一个使用#分隔命令的表文件</p>
<p>MySQL实现分区表的方式是对底层表的封装，意味着索引也是按照分区的子表定义的，而没有全局索引</p>
<p>MySQL在创建表时使用PARTITION BY子句定义每个分区存放的数据。在执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询就无须扫描所有分区了</p>
<p>分区的一个主要目的是将数据按照一个较粗的粒度分在不同的表中，这样做可以将相关的数据存放在一起，另外，如果想一次批量删除整个分区的数据也会变得很方便</p>
<p>在下面的场景中，分区可以起到非常大的作用：</p>
<ul>
<li>表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据</li>
<li>分区表的数据更容易维护。当想批量删除大量数据可以使用清除整个分区的方式，另外，还可以对一个独立的进行优化，检查，修复等操作</li>
<li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li>
<li>可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问</li>
<li>可以备份和恢复独立的分区，这在非常大的数据集的场景下效果非常好</li>
</ul>
<p>分区表本身也有一些限制：</p>
<ul>
<li>一个表最多只能有1024个分区</li>
<li>MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式，在MySQL5.5中，某些场景中可以直接使用列来进行分区</li>
<li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li>
</ul>
<h3 id="分区的原理"><a href="#分区的原理" class="headerlink" title="分区的原理"></a>分区的原理</h3><p>分区表由多个相关的底层表实现，这些底层表也是由句柄对象表示，所以也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样(所有的底层表都必须使用相同的存储引擎)，分区表的索引只是在各个底层表上各自加上一个完全相同的索引，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分</p>
<ul>
<li>select查询，当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分区，然后再调用对应的存储引擎接口访问各个分区的数据</li>
<li>insert插入，当写入一条记录时，分区层先打开并锁住所有的底层表，然后确定哪个分区接受这条记录，再将记录写入对应底层表</li>
<li>delete删除，当删除一条记录时，分区层先打开并锁住所有的底层表，然后确定对应的分区，最后对相应底层表进行删除操作</li>
<li>update更新，当更新一条记录时，分区层先打开并锁住所有的底层表，MySQL先确定需要更新的记录在哪个分区，然后取出数据并更新，再判断更新后的数据应该放在哪个分区，最后对底层表进行写入操作，并对原数据所在的底层表进行删除操作</li>
</ul>
<h3 id="分区表的类型"><a href="#分区表的类型" class="headerlink" title="分区表的类型"></a>分区表的类型</h3><p>根据范围进行分区，每个分区存储落在某个范围的记录，分区表达式可以是列，也可以是包含列的表达式。下表就可以将每一年的销售额存放在不同的分区里</p>
<p>123</p>
<p>partition分区子句中可以使用各种函数，但有一个要求，表达式返回的值要是一个明确的整数，且不能是一个常数，这里使用函数YEAR(),也可以使用任何其他函数，如TO_DAYS()，根据时间间隔进行分区</p>
<p>分区暂时跳过，不懂？？？</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图本身是一个虚拟表，不存放任何数据，在使用SQL语句访问视图的时候，它返回的数据是MySQL从其他表中生成的，视图和表是在同一个命令空间，不能对视图创建触发器，也不能使用drop table命令删除视图</p>
<p>创建视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW oceania AS SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">	country </span><br><span class="line">WHERE</span><br><span class="line">	continent &#x3D; &#39;oceania&#39; WITH CHECK OPTION;</span><br></pre></td></tr></table></figure>

<p>实现视图最简单的方法是将select语句的结果存放到临时表中，当需要访问视图的时候，直接访问这个临时表就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select code,name from oceania where name &#x3D; &#39;australia&#39;</span><br></pre></td></tr></table></figure>

<p>下面是使用临时表来模拟视图的方法，这里临时表的名字是为演示用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create temporary table tmp_oceania_123 as</span><br><span class="line">select * from country where continent &#x3D; &#39;oceania&#39;;</span><br><span class="line"></span><br><span class="line">select code,name from tmp_oceania_123 where name &#x3D; &#39;australia&#39;</span><br></pre></td></tr></table></figure>

<p>这样做会有明显的性能问题，优化器也很难优化在这个临时表上的查询，实现视图更好的方法是，重写含有视图的查询，将视图的定义SQL直接包含进查询的SQL中，下面的例子展示的是将视图定义的SQL合并进查询SQL后的样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select code,name from country </span><br><span class="line">where continent &#x3D; &#39;oceania&#39; and name &#x3D; &#39;australia&#39;</span><br></pre></td></tr></table></figure>

<p>MySQL可以使用合并算法和临时表算法中的一种来处理视图，如果可能，会尽可能地使用合并算。MySQL甚至可以嵌套地定义视图，也就是在一个视图上再定义另一个视图。可以在explain extended之后使用show warnings来查看使用视图的查询重写后的结果</p>
<p>如果采用临时表算法实现的视图，explain中会显示为派生表</p>
<p>124</p>
<p>如果视图中包含group by,distinct，任何聚合函数，union,子查询等，只要无法在原表记录和视图记录中建立一一映射的场景中，MySQL都将使用临时表算法来实现视图</p>
<p>可以explain一条针对视图的简单查询，来判断MySQL到底使用的是那种算法</p>
<p>125</p>
<p>DERIVED说明该视图采用临时表算法实现的。如果产生的底层派生表很大，那么执行explain可能会非常慢</p>
<p>视图的实现算法是视图本身的属性，和作用在视图上的查询语句无关。可以为一个基于简单查询的视图指定使用临时表算法</p>
<h3 id="可更新视图"><a href="#可更新视图" class="headerlink" title="可更新视图"></a>可更新视图</h3><p>可更新视图是指可以通过更新这个视图来更新视图涉及的相关表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update oceania set population &#x3D; polpulation * 1.1 where name &#x3D; &#39;australia&#39;</span><br></pre></td></tr></table></figure>

<p>如果视图定义中包含了group by,unio,聚合函数，以及其他一些特殊情况，就不能被更新了。更新视图的查询也可以是一个关联语句，但是有一个限制，被更新的列必须来自同一个表。所有使用临时表算法实现的视图都无法被更新</p>
<p>check option子句，表示任何通过视图更新的行，都必须符号视图本身的where条件定义，所以不能更新视图定义列以外的列</p>
<h3 id="视图对性能的影响"><a href="#视图对性能的影响" class="headerlink" title="视图对性能的影响"></a>视图对性能的影响</h3><p>某些情况下视图也可以帮助提升性能，而且视图还可以和其他提升性能的方式叠加使用。</p>
<h3 id="视图的限制"><a href="#视图的限制" class="headerlink" title="视图的限制"></a>视图的限制</h3><p>MySQL不支持将视图结果数据存放在一个可以查看的表中，并定期从原始表中刷新数据到这个表中。MySQL也不支持在视图中创建索引，不过可以使用构建缓存表或者汇总表的办法来模拟物化视图和索引</p>
<p>MySQL并不会保存视图定义的原始SQL语句，所以无法通过执行show create view后再见到那地修改其结果的方式来重新定义视图</p>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>InnoDB是目前MySQL中唯一支持外键的内置存储引擎</p>
<p>使用外键是有成本的，比如外键通常都要求每次在修改数据时都要在另外一张表中多执行一次查找操作。虽然InnoDB强制外键使用索引，但还是无法消除这种约束检查的开销。如果外键列的选择性很低，则会导致一个非常大且选择性很低的索引，例如status列</p>
<p>在某些场景下，外键会提升一些性能，如果想确保两个相关表始终有一致的数据，那么使用外键比在应用程序中检查一致性要高得多，此外，外键在相关数据的删除和更新上，也比在应用程序中维护要更高效，不过外键维护操作是逐行进行的，所以这样的更新会比批量删除和更新要慢些</p>
<p>外键约束使得查询需要额外访问别的表，这也意味着需要额外的锁。如果向子表中写入一条记录，外键约束会让InnoDB检查对应的父表的记录，也就需要对父表对应记录进行加锁操作，来确保这条记录不会在这个事务完成之前就被删除了，这会导致额外的锁等待，甚至会导致一些死锁</p>
<p>可以使用触发器来代替外键，对于相关数据的同时更新外键更合适，但是如果外键只是用作数值约束，那么触发器后者显示地限制取值会更好</p>
<p>如果只是使用外键做约束，那么通常在应用程序里实现约束会更好</p>
<h2 id="在MySQL内部存储代码"><a href="#在MySQL内部存储代码" class="headerlink" title="在MySQL内部存储代码"></a>在MySQL内部存储代码</h2><h3 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h3><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>MySQL只在服务区端提供只读的，单向的游标，而且只能在存储过程或者更底层的客户端API中使用，因为MySQL游标中指向的对象都是存储在临时表中而不是实际查询到的数据，所以MySQL游标总是只读的，它可以逐行指向查询结果，然后让程序做进一步的处理，在一个存储过程中，可以有多个游标，也可以在循环中嵌套地使用游标</p>
<h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>通过数值比较，范围过滤等就可以完成大多数我们需要的查询了，如果你希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询了，而不是原来的精确数值比较，全文索引就是为这种场景设计的</p>
<p>全文索引有着自己独特的语法，没有索引也可以工作，如果有索引效率会更高，用于全文搜索的索引有着独特的结构，帮助这类查询找到匹配某些关键字的记录</p>
<h2 id="分布式-XA-事务"><a href="#分布式-XA-事务" class="headerlink" title="分布式(XA)事务"></a>分布式(XA)事务</h2><p>存储引擎的事务特性能够保证在存储引擎级别实现ACID，而分布式事务则让存储引擎级别的ACID可以扩展到数据库层面，甚至可以扩展到多个数据库之间</p>
<p>XA事务中需要有一个事务协调器来保证所有的事务参与者都完成了准备工作。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">李上</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/">http://yoursite.com/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">定不辱使命</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/sharding-jdbc.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/03/jvm/"><img class="prev_cover lazyload" data-src="/img/jvm.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM学习笔记</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/02/rocketmq/"><img class="next_cover lazyload" data-src="/img/rocketmq.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RocketMQ学习笔记</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 李上</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>