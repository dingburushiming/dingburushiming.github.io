<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM学习笔记 | 定不辱使命</title><meta name="description" content="JVM学习笔记"><meta name="author" content="李上"><meta name="copyright" content="李上"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM学习笔记"><meta name="twitter:description" content="JVM学习笔记"><meta name="twitter:image" content="http://yoursite.com/img/jvm.png"><meta property="og:type" content="article"><meta property="og:title" content="JVM学习笔记"><meta property="og:url" content="http://yoursite.com/2020/07/03/jvm/"><meta property="og:site_name" content="定不辱使命"><meta property="og:description" content="JVM学习笔记"><meta property="og:image" content="http://yoursite.com/img/jvm.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/07/03/jvm/"><link rel="prev" title="zookeeper学习笔记" href="http://yoursite.com/2020/07/08/zookeeper/"><link rel="next" title="《高性能MySQL》读书笔记" href="http://yoursite.com/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#类加载子系统"><span class="toc-number">1.</span> <span class="toc-text">类加载子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类的加载过程"><span class="toc-number">1.1.</span> <span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载"><span class="toc-number">1.1.1.</span> <span class="toc-text">加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#将-java文件编译成-class文件"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">将.java文件编译成.class文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载-class文件的方式"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">加载.class文件的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链接过程"><span class="toc-number">1.1.2.</span> <span class="toc-text">链接过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#验证"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#准备"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解析"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-number">1.1.3.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#init方法"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">init方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clinit方法"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">clinit方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java文件"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">.java文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class文件"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">.class文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jclasslib中的clinit"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">.jclasslib中的clinit</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器的分类"><span class="toc-number">1.2.</span> <span class="toc-text">类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引导类加载器-启动类加载器，Bootstrap"><span class="toc-number">1.2.1.</span> <span class="toc-text">引导类加载器(启动类加载器，Bootstrap)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展类加载器-Extension"><span class="toc-number">1.2.2.</span> <span class="toc-text">扩展类加载器(Extension)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用程序类加载器-系统类加载器，AppClassLoader"><span class="toc-number">1.2.3.</span> <span class="toc-text">应用程序类加载器(系统类加载器，AppClassLoader)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义类加载器"><span class="toc-number">1.2.4.</span> <span class="toc-text">自定义类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义类加载器的目的"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">自定义类加载器的目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现步骤"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">实现步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader的相关方法"><span class="toc-number">1.3.</span> <span class="toc-text">ClassLoader的相关方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双亲委派机制"><span class="toc-number">1.4.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">1.4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码"><span class="toc-number">1.4.2.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#委派机制流程图"><span class="toc-number">1.4.3.</span> <span class="toc-text">委派机制流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">1.4.4.</span> <span class="toc-text">作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#沙箱安全机制"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">沙箱安全机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">1.5.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java程序对类的使用方式分为-主动使用和被动使用"><span class="toc-number">1.5.1.</span> <span class="toc-text">Java程序对类的使用方式分为:主动使用和被动使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主动使用"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">主动使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运行时数据区-内存"><span class="toc-number">2.</span> <span class="toc-text">运行时数据区(内存)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#作用-1"><span class="toc-number">2.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个关于pc寄存器的列子"><span class="toc-number">2.2.</span> <span class="toc-text">一个关于pc寄存器的列子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见问题"><span class="toc-number">2.3.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？"><span class="toc-number">2.3.1.</span> <span class="toc-text">使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pc寄存器为什么被设置为线程私有的？"><span class="toc-number">2.3.2.</span> <span class="toc-text">pc寄存器为什么被设置为线程私有的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu时间片"><span class="toc-number">2.4.</span> <span class="toc-text">cpu时间片</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#虚拟机栈"><span class="toc-number">3.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机栈概述"><span class="toc-number">3.1.</span> <span class="toc-text">虚拟机栈概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#出现背景"><span class="toc-number">3.1.1.</span> <span class="toc-text">出现背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java虚拟机栈是什么？"><span class="toc-number">3.1.2.</span> <span class="toc-text">Java虚拟机栈是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈的特点"><span class="toc-number">3.1.3.</span> <span class="toc-text">栈的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈异常"><span class="toc-number">3.1.4.</span> <span class="toc-text">栈异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StackOverflowError"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">StackOverflowError</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutOfMemoryError"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">OutOfMemoryError</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置栈大小的方法"><span class="toc-number">3.1.5.</span> <span class="toc-text">设置栈大小的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈的存储单位"><span class="toc-number">3.2.</span> <span class="toc-text">栈的存储单位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧的内部结构"><span class="toc-number">3.2.1.</span> <span class="toc-text">栈帧的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#局部变量表-本地变量表，局部变量数组"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">局部变量表(本地变量表，局部变量数组)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字节码的内部方法"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">字节码的内部方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量槽Solt"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">变量槽Solt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量的分类"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">变量的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#按照类型分"><span class="toc-number">3.2.1.4.1.</span> <span class="toc-text">按照类型分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#按照在类中声明的位置分"><span class="toc-number">3.2.1.4.2.</span> <span class="toc-text">按照在类中声明的位置分</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量"><span class="toc-number">3.2.1.4.2.1.</span> <span class="toc-text">成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#局部变量：在使用前，必须进行显示赋值，否则，编译不通过"><span class="toc-number">3.2.1.4.2.2.</span> <span class="toc-text">局部变量：在使用前，必须进行显示赋值，否则，编译不通过</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作数栈"><span class="toc-number">3.2.1.5.</span> <span class="toc-text">操作数栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈顶缓存技术"><span class="toc-number">3.2.2.</span> <span class="toc-text">栈顶缓存技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态链接-指向运行时常量池的方法引用"><span class="toc-number">3.2.3.</span> <span class="toc-text">动态链接(指向运行时常量池的方法引用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法返回地址"><span class="toc-number">3.2.4.</span> <span class="toc-text">方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#本地方法栈"><span class="toc-number">3.2.5.</span> <span class="toc-text">本地方法栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#本地方法接口"><span class="toc-number">4.</span> <span class="toc-text">本地方法接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要使用Native-Method"><span class="toc-number">4.0.1.</span> <span class="toc-text">为什么要使用Native Method</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#与其他语言交互"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">与其他语言交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与操作系统交互"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">与操作系统交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提高执行效率"><span class="toc-number">4.0.1.3.</span> <span class="toc-text">提高执行效率</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆"><span class="toc-number">5.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TLAB"><span class="toc-number">5.1.</span> <span class="toc-text">TLAB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存结构"><span class="toc-number">5.2.</span> <span class="toc-text">内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆空间大小的设置和查看"><span class="toc-number">5.3.</span> <span class="toc-text">堆空间大小的设置和查看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOM-OutOfMemory"><span class="toc-number">5.4.</span> <span class="toc-text">OOM(OutOfMemory)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#年轻代与老年代"><span class="toc-number">5.5.</span> <span class="toc-text">年轻代与老年代</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置年轻代和老年代在堆结构中的占比"><span class="toc-number">5.5.1.</span> <span class="toc-text">配置年轻代和老年代在堆结构中的占比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置Eden区，两个Survivor的占比"><span class="toc-number">5.5.2.</span> <span class="toc-text">配置Eden区，两个Survivor的占比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置年轻代的大小"><span class="toc-number">5.5.3.</span> <span class="toc-text">配置年轻代的大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图解对象分配过程"><span class="toc-number">5.6.</span> <span class="toc-text">图解对象分配过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存分配策略"><span class="toc-number">5.6.1.</span> <span class="toc-text">内存分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YGC-Minor-GC"><span class="toc-number">5.6.2.</span> <span class="toc-text">YGC&#x2F;Minor GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Major-GC"><span class="toc-number">5.6.3.</span> <span class="toc-text">Major GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full-GC"><span class="toc-number">5.6.4.</span> <span class="toc-text">Full GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC"><span class="toc-number">5.7.</span> <span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#部分收集-不是完整收集整个Java堆的垃圾收集"><span class="toc-number">5.7.1.</span> <span class="toc-text">部分收集:不是完整收集整个Java堆的垃圾收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#整堆收集-Full-GC-收集整个Java堆和方法区的垃圾收集"><span class="toc-number">5.7.2.</span> <span class="toc-text">整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC日志分析"><span class="toc-number">5.8.</span> <span class="toc-text">GC日志分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆的参数设置"><span class="toc-number">5.9.</span> <span class="toc-text">堆的参数设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆是分配对象存储的唯一选择吗？"><span class="toc-number">5.10.</span> <span class="toc-text">堆是分配对象存储的唯一选择吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#逃逸分析"><span class="toc-number">5.10.1.</span> <span class="toc-text">逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#逃逸分析的基本行为就是分析对象动态作用域"><span class="toc-number">5.10.1.1.</span> <span class="toc-text">逃逸分析的基本行为就是分析对象动态作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#存在逃逸情况的方法"><span class="toc-number">5.10.1.1.1.</span> <span class="toc-text">存在逃逸情况的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#规避逃逸情况的方法"><span class="toc-number">5.10.1.1.2.</span> <span class="toc-text">规避逃逸情况的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码优化"><span class="toc-number">5.10.2.</span> <span class="toc-text">代码优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#栈上分配"><span class="toc-number">5.10.2.1.</span> <span class="toc-text">栈上分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步省略"><span class="toc-number">5.10.2.2.</span> <span class="toc-text">同步省略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分离对象或标量替换"><span class="toc-number">5.10.2.3.</span> <span class="toc-text">分离对象或标量替换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法区"><span class="toc-number">6.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#栈，堆，方法区的交互关系"><span class="toc-number">6.1.</span> <span class="toc-text">栈，堆，方法区的交互关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区的基本理解"><span class="toc-number">6.2.</span> <span class="toc-text">方法区的基本理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区的演进"><span class="toc-number">6.3.</span> <span class="toc-text">方法区的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设置方法区大小与OOM"><span class="toc-number">6.3.1.</span> <span class="toc-text">设置方法区大小与OOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk7及以前"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">jdk7及以前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk8及以后"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">jdk8及以后</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区的内部结构"><span class="toc-number">6.4.</span> <span class="toc-text">方法区的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类型信息"><span class="toc-number">6.4.1.</span> <span class="toc-text">类型信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#non-final的类变量"><span class="toc-number">6.4.2.</span> <span class="toc-text">non-final的类变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时常量池"><span class="toc-number">6.5.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区的使用"><span class="toc-number">6.6.</span> <span class="toc-text">方法区的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区的演进细节"><span class="toc-number">6.7.</span> <span class="toc-text">方法区的演进细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hotspot中方法区的变化"><span class="toc-number">6.7.1.</span> <span class="toc-text">Hotspot中方法区的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK6的方法区"><span class="toc-number">6.7.1.1.</span> <span class="toc-text">JDK6的方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK7的方法区"><span class="toc-number">6.7.1.2.</span> <span class="toc-text">JDK7的方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK8的方法区"><span class="toc-number">6.7.1.3.</span> <span class="toc-text">JDK8的方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么要用元空间替代永久代？"><span class="toc-number">6.7.1.4.</span> <span class="toc-text">为什么要用元空间替代永久代？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为永久代设置空间大小是很难确定的"><span class="toc-number">6.7.1.4.1.</span> <span class="toc-text">为永久代设置空间大小是很难确定的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#对永久代进行调优是很困难的"><span class="toc-number">6.7.1.4.2.</span> <span class="toc-text">对永久代进行调优是很困难的</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringTable字符串常量池为什么要调整位置？"><span class="toc-number">6.7.1.5.</span> <span class="toc-text">StringTable字符串常量池为什么要调整位置？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区的垃圾回收"><span class="toc-number">6.8.</span> <span class="toc-text">方法区的垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象的实例化内存布局与访问定位"><span class="toc-number">7.</span> <span class="toc-text">对象的实例化内存布局与访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的实例化"><span class="toc-number">7.1.</span> <span class="toc-text">对象的实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建对象的方式"><span class="toc-number">7.1.1.</span> <span class="toc-text">创建对象的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建对象的步骤"><span class="toc-number">7.1.2.</span> <span class="toc-text">创建对象的步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的内存布局"><span class="toc-number">7.2.</span> <span class="toc-text">对象的内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象头"><span class="toc-number">7.2.1.</span> <span class="toc-text">对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例数据"><span class="toc-number">7.2.2.</span> <span class="toc-text">实例数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对齐填充"><span class="toc-number">7.2.3.</span> <span class="toc-text">对齐填充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的访问定位"><span class="toc-number">7.3.</span> <span class="toc-text">对象的访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#句柄访问"><span class="toc-number">7.3.1.</span> <span class="toc-text">句柄访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#直接指针-Hotspot采用"><span class="toc-number">7.3.2.</span> <span class="toc-text">直接指针(Hotspot采用)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#直接内存-本地内存"><span class="toc-number">8.</span> <span class="toc-text">直接内存(本地内存)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#直接内存的OOM与内存大小的设置"><span class="toc-number">8.1.</span> <span class="toc-text">直接内存的OOM与内存大小的设置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#执行引擎"><span class="toc-number">9.</span> <span class="toc-text">执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">9.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java代码编译和执行过程"><span class="toc-number">9.2.</span> <span class="toc-text">Java代码编译和执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#机器码，指令，汇编语言，高级语言"><span class="toc-number">9.3.</span> <span class="toc-text">机器码，指令，汇编语言，高级语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释器-Interpreter"><span class="toc-number">9.4.</span> <span class="toc-text">解释器(Interpreter)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JIT编译器-Just-In-Time-Compiler"><span class="toc-number">9.5.</span> <span class="toc-text">JIT编译器(Just In Time Compiler)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT和解释器的对比"><span class="toc-number">9.5.1.</span> <span class="toc-text">JIT和解释器的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例"><span class="toc-number">9.5.2.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#热点代码探测决定何时JIT"><span class="toc-number">9.5.3.</span> <span class="toc-text">热点代码探测决定何时JIT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#热点代码探测方式"><span class="toc-number">9.5.3.1.</span> <span class="toc-text">热点代码探测方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#回边计数器"><span class="toc-number">9.5.3.2.</span> <span class="toc-text">回边计数器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HotSpot-VM设置程序执行方式"><span class="toc-number">9.6.</span> <span class="toc-text">HotSpot VM设置程序执行方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C1和C2编译器"><span class="toc-number">9.7.</span> <span class="toc-text">C1和C2编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOT的优缺点"><span class="toc-number">9.7.1.</span> <span class="toc-text">AOT的优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StringTable"><span class="toc-number">10.</span> <span class="toc-text">StringTable</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String的基本特性"><span class="toc-number">10.1.</span> <span class="toc-text">String的基本特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串常量池"><span class="toc-number">10.1.1.</span> <span class="toc-text">字符串常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不可变性"><span class="toc-number">10.1.2.</span> <span class="toc-text">不可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string不可变性面试题"><span class="toc-number">10.1.2.1.</span> <span class="toc-text">string不可变性面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String的内存分配"><span class="toc-number">10.2.</span> <span class="toc-text">String的内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable位置为什么要调整？"><span class="toc-number">10.2.1.</span> <span class="toc-text">StringTable位置为什么要调整？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String的基本操作"><span class="toc-number">10.3.</span> <span class="toc-text">String的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串拼接操作"><span class="toc-number">10.4.</span> <span class="toc-text">字符串拼接操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拼接操作与append操作的效率对比"><span class="toc-number">10.4.1.</span> <span class="toc-text">拼接操作与append操作的效率对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#intern-的使用"><span class="toc-number">10.5.</span> <span class="toc-text">intern()的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-s-new-String-“ab”-会创建几个对象？"><span class="toc-number">10.5.0.1.</span> <span class="toc-text">String s &#x3D; new String(“ab”)会创建几个对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-s-new-String-“a”-new-String-“b”-会创建几个对象？"><span class="toc-number">10.5.0.2.</span> <span class="toc-text">String s &#x3D; new String(“a”)+new String(“b”)会创建几个对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面试题"><span class="toc-number">10.5.0.3.</span> <span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">10.5.0.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringTable的垃圾回收"><span class="toc-number">10.6.</span> <span class="toc-text">StringTable的垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1中的String去重操作"><span class="toc-number">10.7.</span> <span class="toc-text">G1中的String去重操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-number">10.7.1.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾回收"><span class="toc-number">11.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是垃圾"><span class="toc-number">11.1.</span> <span class="toc-text">什么是垃圾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么需要GC"><span class="toc-number">11.2.</span> <span class="toc-text">为什么需要GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java垃圾回收机制"><span class="toc-number">11.3.</span> <span class="toc-text">Java垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#标记阶段：引用计数算法"><span class="toc-number">11.3.1.</span> <span class="toc-text">标记阶段：引用计数算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优点"><span class="toc-number">11.3.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#确定Java使用的不是引用计数器算法"><span class="toc-number">11.3.1.2.</span> <span class="toc-text">确定Java使用的不是引用计数器算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点"><span class="toc-number">11.3.1.3.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python使用了引用计数器，是如何解决循环引用问题的呐？"><span class="toc-number">11.3.1.4.</span> <span class="toc-text">python使用了引用计数器，是如何解决循环引用问题的呐？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记阶段：可达性分析算法-根搜索算法，追踪性垃圾收集"><span class="toc-number">11.3.2.</span> <span class="toc-text">标记阶段：可达性分析算法(根搜索算法，追踪性垃圾收集)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本思路"><span class="toc-number">11.3.2.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在Java语言当中，GC-Roots包括以下几类元素"><span class="toc-number">11.3.2.2.</span> <span class="toc-text">在Java语言当中，GC Roots包括以下几类元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的finalization机制"><span class="toc-number">11.3.2.3.</span> <span class="toc-text">对象的finalization机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从finalize-的角度来看，对象有以下三种状态："><span class="toc-number">11.3.2.4.</span> <span class="toc-text">从finalize()的角度来看，对象有以下三种状态：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码复活演示"><span class="toc-number">11.3.2.5.</span> <span class="toc-text">代码复活演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MAT与JProfiler的GC-Roots溯源"><span class="toc-number">11.3.2.6.</span> <span class="toc-text">MAT与JProfiler的GC Roots溯源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#清除阶段：标记-清除算法-Mark-Sweep"><span class="toc-number">11.3.3.</span> <span class="toc-text">清除阶段：标记-清除算法(Mark-Sweep)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#清除阶段：复制算法"><span class="toc-number">11.3.4.</span> <span class="toc-text">清除阶段：复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#清除阶段：标记-压缩-整理-算法"><span class="toc-number">11.3.5.</span> <span class="toc-text">清除阶段：标记-压缩(整理)算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-number">11.3.6.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分代收集算法"><span class="toc-number">11.3.7.</span> <span class="toc-text">分代收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#年轻代"><span class="toc-number">11.3.7.1.</span> <span class="toc-text">年轻代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#老年代"><span class="toc-number">11.3.7.2.</span> <span class="toc-text">老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS回收器"><span class="toc-number">11.3.7.3.</span> <span class="toc-text">CMS回收器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增量收集算法，分区算法"><span class="toc-number">11.3.8.</span> <span class="toc-text">增量收集算法，分区算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#增量收集算法"><span class="toc-number">11.3.8.1.</span> <span class="toc-text">增量收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分区算法"><span class="toc-number">11.3.8.2.</span> <span class="toc-text">分区算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾回收相关概念"><span class="toc-number">12.</span> <span class="toc-text">垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sysem-gc-的理解"><span class="toc-number">12.1.</span> <span class="toc-text">Sysem.gc()的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存溢出与内存泄漏"><span class="toc-number">12.2.</span> <span class="toc-text">内存溢出与内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存溢出"><span class="toc-number">12.2.1.</span> <span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄漏"><span class="toc-number">12.2.2.</span> <span class="toc-text">内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stop-The-World"><span class="toc-number">12.3.</span> <span class="toc-text">Stop The World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收的并发与并行"><span class="toc-number">12.4.</span> <span class="toc-text">垃圾回收的并发与并行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作系统"><span class="toc-number">12.4.1.</span> <span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收-1"><span class="toc-number">12.4.2.</span> <span class="toc-text">垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安全点与安全区域"><span class="toc-number">12.5.</span> <span class="toc-text">安全点与安全区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安全点"><span class="toc-number">12.5.1.</span> <span class="toc-text">安全点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来了呐？"><span class="toc-number">12.5.1.1.</span> <span class="toc-text">如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来了呐？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安全区"><span class="toc-number">12.5.2.</span> <span class="toc-text">安全区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用"><span class="toc-number">12.6.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#强引用"><span class="toc-number">12.6.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#软引用"><span class="toc-number">12.6.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#弱引用"><span class="toc-number">12.6.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚引用"><span class="toc-number">12.6.4.</span> <span class="toc-text">虚引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终结器引用"><span class="toc-number">12.6.5.</span> <span class="toc-text">终结器引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾回收器"><span class="toc-number">13.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GC分类与性能指标"><span class="toc-number">13.1.</span> <span class="toc-text">GC分类与性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC分类"><span class="toc-number">13.1.1.</span> <span class="toc-text">GC分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#按线程数分"><span class="toc-number">13.1.1.1.</span> <span class="toc-text">按线程数分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#按工作模式分"><span class="toc-number">13.1.1.2.</span> <span class="toc-text">按工作模式分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#按碎片处理方式分"><span class="toc-number">13.1.1.3.</span> <span class="toc-text">按碎片处理方式分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#按工作的内存区间分"><span class="toc-number">13.1.1.4.</span> <span class="toc-text">按工作的内存区间分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能指标"><span class="toc-number">13.1.2.</span> <span class="toc-text">性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#吞吐量"><span class="toc-number">13.1.2.0.1.</span> <span class="toc-text">吞吐量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#暂停时间"><span class="toc-number">13.1.2.0.2.</span> <span class="toc-text">暂停时间</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不同的垃圾回收器概述"><span class="toc-number">13.2.</span> <span class="toc-text">不同的垃圾回收器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集器发展史"><span class="toc-number">13.2.1.</span> <span class="toc-text">垃圾收集器发展史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收器的组合关系"><span class="toc-number">13.2.2.</span> <span class="toc-text">垃圾回收器的组合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何查看默认的垃圾收集器"><span class="toc-number">13.2.3.</span> <span class="toc-text">如何查看默认的垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Serial回收器：串行回收"><span class="toc-number">13.3.</span> <span class="toc-text">Serial回收器：串行回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ParNew回收器：并行回收"><span class="toc-number">13.4.</span> <span class="toc-text">ParNew回收器：并行回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parallel回收器：吞吐量优先"><span class="toc-number">13.5.</span> <span class="toc-text">Parallel回收器：吞吐量优先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参数设置"><span class="toc-number">13.5.1.</span> <span class="toc-text">参数设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMS回收器：低延迟"><span class="toc-number">13.6.</span> <span class="toc-text">CMS回收器：低延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#工作原理"><span class="toc-number">13.6.1.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始标记阶段-Initial-Mark"><span class="toc-number">13.6.1.1.</span> <span class="toc-text">初始标记阶段(Initial-Mark)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发标记阶段-Concurrent-Mark"><span class="toc-number">13.6.1.2.</span> <span class="toc-text">并发标记阶段(Concurrent-Mark)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重新标记阶段-Remark"><span class="toc-number">13.6.1.3.</span> <span class="toc-text">重新标记阶段(Remark)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发清除阶段-Concurrent-Sweep"><span class="toc-number">13.6.1.4.</span> <span class="toc-text">并发清除阶段(Concurrent-Sweep)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点与弊端分析"><span class="toc-number">13.6.2.</span> <span class="toc-text">特点与弊端分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么不使用压缩算法？"><span class="toc-number">13.6.2.1.</span> <span class="toc-text">为什么不使用压缩算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS的优点"><span class="toc-number">13.6.2.2.</span> <span class="toc-text">CMS的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS的缺点"><span class="toc-number">13.6.2.3.</span> <span class="toc-text">CMS的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS收集器可以设置的参数"><span class="toc-number">13.6.2.4.</span> <span class="toc-text">CMS收集器可以设置的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS小结"><span class="toc-number">13.6.2.5.</span> <span class="toc-text">CMS小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1回收器：区域化分代式"><span class="toc-number">13.7.</span> <span class="toc-text">G1回收器：区域化分代式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要发布G1"><span class="toc-number">13.7.1.</span> <span class="toc-text">为什么要发布G1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1的优势"><span class="toc-number">13.7.2.</span> <span class="toc-text">G1的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#并行与并发"><span class="toc-number">13.7.2.1.</span> <span class="toc-text">并行与并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分代收集"><span class="toc-number">13.7.2.2.</span> <span class="toc-text">分代收集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空间整合"><span class="toc-number">13.7.2.3.</span> <span class="toc-text">空间整合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可预测的停顿时间"><span class="toc-number">13.7.2.4.</span> <span class="toc-text">可预测的停顿时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1回收器的参数设置"><span class="toc-number">13.7.3.</span> <span class="toc-text">G1回收器的参数设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1回收器的适用场景"><span class="toc-number">13.7.4.</span> <span class="toc-text">G1回收器的适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#region-化整为零"><span class="toc-number">13.7.5.</span> <span class="toc-text">region:化整为零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#记忆集与写屏障"><span class="toc-number">13.7.6.</span> <span class="toc-text">记忆集与写屏障</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#记忆集-Remembered-Set"><span class="toc-number">13.7.6.1.</span> <span class="toc-text">记忆集(Remembered Set)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#存在原因"><span class="toc-number">13.7.6.1.1.</span> <span class="toc-text">存在原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解决办法"><span class="toc-number">13.7.6.1.2.</span> <span class="toc-text">解决办法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1回收器垃圾回收过程"><span class="toc-number">13.7.7.</span> <span class="toc-text">G1回收器垃圾回收过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#G1回收过程一：年轻代GC"><span class="toc-number">13.7.7.1.</span> <span class="toc-text">G1回收过程一：年轻代GC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#第一阶段，扫描根GC-Roots"><span class="toc-number">13.7.7.1.1.</span> <span class="toc-text">第一阶段，扫描根GC Roots</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第二阶段，更新RSet"><span class="toc-number">13.7.7.1.2.</span> <span class="toc-text">第二阶段，更新RSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第三阶段，处理RSet"><span class="toc-number">13.7.7.1.3.</span> <span class="toc-text">第三阶段，处理RSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第四阶段，复制对象"><span class="toc-number">13.7.7.1.4.</span> <span class="toc-text">第四阶段，复制对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第五阶段，处理引用"><span class="toc-number">13.7.7.1.5.</span> <span class="toc-text">第五阶段，处理引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1回收过程二：并发标记过程"><span class="toc-number">13.7.7.2.</span> <span class="toc-text">G1回收过程二：并发标记过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1回收过程三：混合回收"><span class="toc-number">13.7.7.3.</span> <span class="toc-text">G1回收过程三：混合回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1回收可选过程四：Full-GC"><span class="toc-number">13.7.7.4.</span> <span class="toc-text">G1回收可选过程四：Full GC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#导致G1-Full-GC的原因可能有两个"><span class="toc-number">13.7.7.4.1.</span> <span class="toc-text">导致G1 Full GC的原因可能有两个</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收器总结"><span class="toc-number">13.8.</span> <span class="toc-text">垃圾回收器总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC日志分析-1"><span class="toc-number">13.9.</span> <span class="toc-text">GC日志分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收器新发展"><span class="toc-number">13.10.</span> <span class="toc-text">垃圾回收器新发展</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/jvm.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">定不辱使命</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">JVM学习笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-03 09:45:02"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-03</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-07 16:28:13"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-07</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/004.png"  alt="jvm"></p>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件中有特定的文件标识，加载的类信息存放在方法区的内存空间</p>
<p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine执行引擎决定</p>
<p>方法区除了存放被加载类的类信息，还会包含字符串，字面量，数字常量，运行时常量池信息</p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/001.png"  alt="jvm"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><h4 id="将-java文件编译成-class文件"><a href="#将-java文件编译成-class文件" class="headerlink" title="将.java文件编译成.class文件"></a>将.java文件编译成.class文件</h4><p>1.通过一个类的全限定名获取定义此类的二进制字节流</p>
<p>2.将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</p>
<p>3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<h4 id="加载-class文件的方式"><a href="#加载-class文件的方式" class="headerlink" title="加载.class文件的方式"></a>加载.class文件的方式</h4><p>1.从本地文件中直接加载</p>
<p>2.通过网络获取，例如web applet</p>
<p>3.从zip压缩包中读取，例如jar,war包</p>
<p>4.运行时计算生成，例如动态代理技术</p>
<p>5.由其他文件生成，例如jsp应用</p>
<p>6.从专有数据库中提取.class文件</p>
<p>7.从加密文件中获取，典型的防止Class文件被反编译的保护措施</p>
<h3 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</p>
<p>主要包括四种验证：文件格式，元数据，字节码，符号引用验证</p>
<p>.class文件的开头都是cafe babe</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为类变量分配内存并且设置该类变量的默认初始值,具体赋值在初始化阶段</p>
<p>整形：0</p>
<p>浮点型：0.0</p>
<p>Char: /u0000</p>
<p>Boolean:false</p>
<p>String:null</p>
<p>final修饰的static是常量，在编译的时候就会分配数值，准备阶段会显式初始化</p>
<p>不会为实例变量(对象)分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析操作往往会在JVM实初始化之后再执行</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h4><p>init是实例对象的构造器方法，用于构造类对象</p>
<h4 id="clinit方法"><a href="#clinit方法" class="headerlink" title="clinit方法"></a>clinit方法</h4><p>clinit是类的初始化方法，在JVM第一次加载class文件时调用</p>
<p>如果没有静态代码块，静态变量则没有clinit方法</p>
<p>初始化过程就是执行类构造器方法<clinit>的过程，该方法由javac编译器自动执行</clinit></p>
<p><clinit>不需要定义，由javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</clinit></p>
<p>构造器方法中的指令按语句在源文件中出现的顺序执行</p>
<p>如果一个类有父类，JVM会保证子类的<clinit>执行前，父类的<clinit>已经执行完毕</clinit></clinit></p>
<p>虚拟机必须保证一个类的的<clinit>方法在多线程下被同步加锁</clinit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当一个线程在初始化一个类时，其他线程无法初始化该类</span><br><span class="line">public class DeadThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable r &#x3D; () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;开始&quot;);</span><br><span class="line">            DeadThread dead &#x3D; new DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 &#x3D; new Thread(r,&quot;线程1&quot;);</span><br><span class="line">        Thread t2 &#x3D; new Thread(r,&quot;线程2&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DeadThread&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        if(true)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;初始化当前类&quot;);</span><br><span class="line">            while(true)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java文件"><a href="#java文件" class="headerlink" title=".java文件"></a>.java文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ClassInit &#123;</span><br><span class="line">    private static int num &#x3D; 1;</span><br><span class="line">    static &#123;</span><br><span class="line">        num&#x3D;2;</span><br><span class="line">        number&#x3D;20;</span><br><span class="line">    &#125;</span><br><span class="line">    private static int number &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="class文件"><a href="#class文件" class="headerlink" title=".class文件"></a>.class文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ClassInit &#123;</span><br><span class="line">    private static int num &#x3D; 1;</span><br><span class="line">    private static int number;</span><br><span class="line"></span><br><span class="line">    public ClassInit() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        num &#x3D; 2;</span><br><span class="line">        number &#x3D; 20;</span><br><span class="line">        number &#x3D; 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="jclasslib中的clinit"><a href="#jclasslib中的clinit" class="headerlink" title=".jclasslib中的clinit"></a>.jclasslib中的clinit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0 iconst_1</span><br><span class="line"> 1 putstatic #3 &lt;ClassInit.num&gt;</span><br><span class="line"> 4 iconst_2</span><br><span class="line"> 5 putstatic #3 &lt;ClassInit.num&gt;</span><br><span class="line"> 8 bipush 20</span><br><span class="line">10 putstatic #5 &lt;ClassInit.number&gt;</span><br><span class="line">13 bipush 10</span><br><span class="line">15 putstatic #5 &lt;ClassInit.number&gt;</span><br><span class="line">18 return</span><br></pre></td></tr></table></figure>

<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/002.png"  alt="jvm"></p>
<p>用户自定义类默认使用系统类加载器</p>
<p>Java核心类库都是使用引导类加载器进行加载的</p>
<p>引导类加载器是无法直接获取到的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取系统类加载器</span><br><span class="line">ClassLoader systemClassLoader &#x3D; ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取其上层：扩展类加载器</span><br><span class="line">ClassLoader extClassLoader &#x3D; systemClassLoader.getParent();</span><br><span class="line">System.out.println(extClassLoader);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取其上层：获取不到引导类加载器，打印为null</span><br><span class="line">ClassLoader bootstrapClassLoader &#x3D; extClassLoader.getParent();</span><br><span class="line">System.out.println(bootstrapClassLoader);&#x2F;&#x2F;null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对于用户自定义类来说：默认使用系统类加载器进行加载</span><br><span class="line">ClassLoader classLoader &#x3D; ClassLoaderTest.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span><br><span class="line">ClassLoader classLoader1 &#x3D; String.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader1);&#x2F;&#x2F;null</span><br></pre></td></tr></table></figure>

<h3 id="引导类加载器-启动类加载器，Bootstrap"><a href="#引导类加载器-启动类加载器，Bootstrap" class="headerlink" title="引导类加载器(启动类加载器，Bootstrap)"></a>引导类加载器(启动类加载器，Bootstrap)</h3><p>使用C/C++语言实现的，嵌套在JVM内部</p>
<p> 用于加载Java的核心类(JAVA_HOME/jre/lib/rt.jar,resources.jar,sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;**********启动类加载器**************&quot;);</span><br><span class="line">&#x2F;&#x2F;获取BootstrapClassLoader能够加载的api的路径</span><br><span class="line">URL[] urLs &#x3D; sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"> for (URL element : urLs) &#123;</span><br><span class="line">      System.out.println(element.toExternalForm());</span><br><span class="line">&#125;</span><br><span class="line">---------------------------</span><br><span class="line">输出结果</span><br><span class="line">**********启动类加载器**************</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;resources.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;rt.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;sunrsasign.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;jsse.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;jce.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;charsets.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;jfr.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;classes</span><br><span class="line">file:&#x2F;D:&#x2F;idea&#x2F;idea_install&#x2F;lib&#x2F;rt&#x2F;debugger-agent-storage.jar</span><br></pre></td></tr></table></figure>

<p> 并不继承java.lang.ClassLoader,没有父加载器</p>
<p>加载扩展类和应用程序类加载器，并指定为它们的父类加载器</p>
<p>出于安全考虑，Bootstrap启动类加载器只加载包名为java,javax,sun等开头的类</p>
<h3 id="扩展类加载器-Extension"><a href="#扩展类加载器-Extension" class="headerlink" title="扩展类加载器(Extension)"></a>扩展类加载器(Extension)</h3><p> Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</p>
<p>派生于ClassLoader类</p>
<p>父类加载器为启动类加载器</p>
<p> 从java.ext,dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库，如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;***********扩展类加载器*************&quot;);</span><br><span class="line">String extDirs &#x3D; System.getProperty(&quot;java.ext.dirs&quot;);</span><br><span class="line">for (String path : extDirs.split(&quot;;&quot;)) &#123;</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line">---------------------------</span><br><span class="line">输出结果</span><br><span class="line">***********扩展类加载器*************</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_171\jre\lib\ext</span><br><span class="line">C:\WINDOWS\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure>

<h3 id="应用程序类加载器-系统类加载器，AppClassLoader"><a href="#应用程序类加载器-系统类加载器，AppClassLoader" class="headerlink" title="应用程序类加载器(系统类加载器，AppClassLoader)"></a>应用程序类加载器(系统类加载器，AppClassLoader)</h3><p>java语言编写，由sun.misc.Launcher$AppClassLoader实现</p>
<p>派生于ClassLoader类，父类加载器为扩展类加载器</p>
<p>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</p>
<p>程序中默认的类加载器，Java应用的类都是由它来完成加载</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><h4 id="自定义类加载器的目的"><a href="#自定义类加载器的目的" class="headerlink" title="自定义类加载器的目的"></a>自定义类加载器的目的</h4><ol>
<li>隔离加载类</li>
<li>修改类加载方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ol>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>继承抽象类java.lang.ClassLoader类</li>
<li>jdk1.2之前重写loadClass(),jdk1.2之后建议把自定义类加载逻辑写在findClass()方法中</li>
<li>如果没有太过于复杂的需求，可以直接继承URLClassLoader类，避免编写findClass方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] result &#x3D; getClassFromCustomPath(name);</span><br><span class="line">            if(result &#x3D;&#x3D; null)&#123;</span><br><span class="line">                throw new FileNotFoundException();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return defineClass(name,result,0,result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] getClassFromCustomPath(String name)&#123;</span><br><span class="line">        &#x2F;&#x2F;从自定义路径中加载指定类:细节略</span><br><span class="line">        &#x2F;&#x2F;如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CustomClassLoader customClassLoader &#x3D; new CustomClassLoader();</span><br><span class="line">        try &#123;</span><br><span class="line">            Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;One&quot;,true,customClassLoader);</span><br><span class="line">            Object obj &#x3D; clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClassLoader的相关方法"><a href="#ClassLoader的相关方法" class="headerlink" title="ClassLoader的相关方法"></a>ClassLoader的相关方法</h2><p> 引导类加载器是C/C++编写，其余是由Java编写，这也是一种类加载器分类方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.引导类加载器获取不到</span><br><span class="line">ClassLoader classLoader &#x3D; Class.forName(&quot;java.lang.String&quot;).getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line">&#x2F;&#x2F;2.系统类加载器</span><br><span class="line">ClassLoader classLoader1 &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">System.out.println(classLoader1);</span><br><span class="line">&#x2F;&#x2F;3.扩展类加载器</span><br><span class="line">ClassLoader classLoader2 &#x3D; ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">System.out.println(classLoader2);</span><br></pre></td></tr></table></figure>

<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</p>
<p>如果父类的加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</p>
<p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">            throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 首先检查这个classsh是否已经加载过了</span><br><span class="line">            Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                long t0 &#x3D; System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; c&#x3D;&#x3D;null表示没有加载，如果有父类的加载器则让父类加载器加载</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果父类的加载器为空 则说明递归到bootStrapClassloader了</span><br><span class="line">                        &#x2F;&#x2F;bootStrapClassloader比较特殊无法通过get获取</span><br><span class="line">                        c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;&#125;</span><br><span class="line">                if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果bootstrapClassLoader 仍然没有加载过，则递归回来，尝试自己去加载class</span><br><span class="line">                    long t1 &#x3D; System.nanoTime();</span><br><span class="line">                    c &#x3D; findClass(name);</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="委派机制流程图"><a href="#委派机制流程图" class="headerlink" title="委派机制流程图"></a>委派机制流程图</h3><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/003.png"  alt="jvm"></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>防止重复加载同一个.class,通过委托去上面问一问，加载过了就不用再加载一遍，保证数据安全。</p>
<p>保证核心.class不会被篡改。通过委托方式不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。</p>
<h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><p>将Java核心api置于沙箱中，不被外界代码所篡改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F;自定义的重名api不会被顶层启动类加载器加载</span><br><span class="line">2.&#x2F;&#x2F;自定义的包名也被允许，例如java.lang,在该表下的类运行会报SecurityException</span><br><span class="line">package java.lang;</span><br><span class="line">public class String &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;我是自定义的String类的静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;错误: 在类 java.lang.String 中找不到 main 方法</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello,String&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3.执行main方法会报错，因为启动类加载器会去调用真正的Java核心api，而String类是没有主函数的。</span><br><span class="line">报错信息：</span><br><span class="line">错误:在类java.lang.String中找不到main方法, 请将main方法定义为:</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>JVM中表示两个class对象是否为同一个类又两个必要条件：</p>
<ol>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader必须相同</li>
</ol>
<p>JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的</p>
<p>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</p>
<p>当解析一个类型到另外一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</p>
<h3 id="Java程序对类的使用方式分为-主动使用和被动使用"><a href="#Java程序对类的使用方式分为-主动使用和被动使用" class="headerlink" title="Java程序对类的使用方式分为:主动使用和被动使用"></a>Java程序对类的使用方式分为:主动使用和被动使用</h3><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射(Class.forName(“com.ls.test”))</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持</li>
</ol>
<p>除了以上七种情况，其他使用Java类的方式都被看做是对类的被动使用，都不会导致类的初始化</p>
<h1 id="运行时数据区-内存"><a href="#运行时数据区-内存" class="headerlink" title="运行时数据区(内存)"></a>运行时数据区(内存)</h1><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/005.png"  alt="jvm"></p>
<p>运行时数据区中线程独有的：程序计数器，栈，本地栈</p>
<p>运行时数据区中线程间共享的：堆，堆外内存(永久代或元空间，代码缓存)</p>
<p>对JVM的优化主要集中在堆区和方法区(堆外内存)</p>
<p>PC寄存器(Program Counter Register程序计数器)</p>
<p>pc寄存器是一个软件层面上的应用，不同于CPU寄存器</p>
<p>每一个线程都有一个pc寄存器，是线程私有的，生命周期与线程保持一致</p>
<p>是一个小到可以忽略不记且运行速度最快的内存区域</p>
<p>任何时间一个线程(当前方法)都只有一个方法在执行，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。如果执行native方法。则是未定义值(undefined)</p>
<p>程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成</p>
<p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p>
<p>pc寄存器是唯一一个Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域,也没有GC垃圾回收</p>
<p>GC( Garbage Collection ):垃圾回收机制，OOM( Out Of Memory ):内存溢出异常</p>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>pc寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/006.png"  alt="jvm"></p>
<h2 id="一个关于pc寄存器的列子"><a href="#一个关于pc寄存器的列子" class="headerlink" title="一个关于pc寄存器的列子"></a>一个关于pc寄存器的列子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 10;</span><br><span class="line">int j &#x3D; 20;</span><br><span class="line">int k &#x3D; i + j;</span><br></pre></td></tr></table></figure>

<p>通过反编译javap -verbose PCRegisterTest.class，得到结果如下</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/007.png"  alt="jvm"></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？"><a href="#使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？" class="headerlink" title="使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？"></a>使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？</h3><p>因为cpu需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始接着执行</p>
<p>JVM的字节码解释器就需要通过改变pc寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<h3 id="pc寄存器为什么被设置为线程私有的？"><a href="#pc寄存器为什么被设置为线程私有的？" class="headerlink" title="pc寄存器为什么被设置为线程私有的？"></a>pc寄存器为什么被设置为线程私有的？</h3><p>如果不是私有而是共享的，那么当多线程出现同步问题的时候，计数器的值会乱掉</p>
<h2 id="cpu时间片"><a href="#cpu时间片" class="headerlink" title="cpu时间片"></a>cpu时间片</h2><p>并行：同时执行多个线程</p>
<p>并发：一个cpu内核快速切换执行线程，实际上是串行的，但是给人的效果像是并行的</p>
<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h2><p>栈是运行时的单位，而堆是存储的单位</p>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据(菜方)</p>
<p>堆解决的是数据存储的问题，即数据怎么放，放在哪里(食材)</p>
<h3 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景"></a>出现背景</h3><p>由于跨平台性的设计，不同平台cpu架构是不同的，不能设计为基于寄存器的，Java的指令都是根据栈来设计的</p>
<p>虚拟机栈的优点是跨平台，指令集小，编译器容器实现，缺点是性能下降，实现同样的功能需要更多的指令</p>
<h3 id="Java虚拟机栈是什么？"><a href="#Java虚拟机栈是什么？" class="headerlink" title="Java虚拟机栈是什么？"></a>Java虚拟机栈是什么？</h3><p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame),对应着一次次的Java方法调用</p>
<p>虚拟机栈是线程私有的，什么周期和线程一致</p>
<p>主管Java程序的运行，它保存方法的局部变量，部分结果，并参与方法的调用和返回 </p>
<h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</p>
<p>虚拟机栈只存在OOM,不存在GC</p>
<p>JVM直接对Java栈的操作只有两个：</p>
<p>1.每个方法执行，伴随着进栈</p>
<p>2.执行结束后的出栈</p>
<h3 id="栈异常"><a href="#栈异常" class="headerlink" title="栈异常"></a>栈异常</h3><p>Java虚拟机允许Java栈的大小是动态的或者是固定不变的</p>
<h4 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h4><p>对于固定容量大小的Java虚拟机栈，如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，就会抛出StackOverflowError异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        main(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h4><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那么就会抛出一个OutOfMemoryError异常</p>
<h3 id="设置栈大小的方法"><a href="#设置栈大小的方法" class="headerlink" title="设置栈大小的方法"></a>设置栈大小的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;判断当前栈的大小</span><br><span class="line">private static int count &#x3D; 1;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过-Xss设置栈的大小，例如vm options:-Xss 256k</p>
<h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据存储在栈帧中，栈帧是栈的基本单位</p>
<p>在线程上运行的每个方法都对应一个栈帧，一个方法执行就有一个栈帧入栈，一个方法结束就有一个栈帧出栈</p>
<p>栈帧是一个内存区域，是一个数据集，维系着方法执行过程中的各种数据信息</p>
<p>如果当前方法被其他方法调用了，方法返回之际，当前栈帧会传回此方法的执行结果给调用自己的方法。接着当前栈帧就会出栈，待用当前栈帧方法的栈帧就会成为当前栈帧</p>
<p>Java方法有两种返回函数的方法，一种是正常的函数返回，使用return指令；另外一种是抛出异常。两种返回方式都会导致栈帧被弹出。出现异常不会导致JVM终止，只会将异常不断上抛，直到有方法捕获处理，如果到主函数都没有处理该异常，就会导致虚拟机异常终止。</p>
<p>进栈就会执行方法，方法结束就会出栈，先进后出，在栈顶的栈帧先执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        test test &#x3D; new test();</span><br><span class="line">        test.method1();</span><br><span class="line">        System.out.println(&quot;main()正常结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        System.out.println(&quot;method1()开始执行...&quot;);</span><br><span class="line">        method2();</span><br><span class="line">        System.out.println(&quot;method1()执行结束...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;method2()开始执行...&quot;);</span><br><span class="line">        method3();</span><br><span class="line">        System.out.println(&quot;method2()即将结束...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method3() &#123;</span><br><span class="line">        System.out.println(&quot;method3()开始执行...&quot;);</span><br><span class="line">        System.out.println(&quot;method3()即将结束...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">----------------运行结果------------------------------</span><br><span class="line">method1()开始执行...</span><br><span class="line">method2()开始执行...</span><br><span class="line">method3()开始执行...</span><br><span class="line">method3()即将结束...</span><br><span class="line">method2()即将结束...</span><br><span class="line">method1()执行结束...</span><br><span class="line">main()正常结束</span><br></pre></td></tr></table></figure>

<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/017.png"  alt="jvm"></p>
<h4 id="局部变量表-本地变量表，局部变量数组"><a href="#局部变量表-本地变量表，局部变量数组" class="headerlink" title="局部变量表(本地变量表，局部变量数组)"></a>局部变量表(本地变量表，局部变量数组)</h4><p>定义为一个数字数组(Java八种数值类型都可以用数字表示)，主要用于存储方法参数和定义在方法体内的局部变量</p>
<p>局部变量表建立在线程栈上，是线程的私有数据，不存在数据安全问题</p>
<p>局部变量表所需的容量大小是在编译期确定下来的，在方法运行期间不会改变局部变量表的大小</p>
<p>局部变量表中的变量只在当前方法调用中有效，当方法调用结束以后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<p>局部变量表存储的是堆空间中的变量的地址，在方法执行时，虚拟机使用局部变量表完成方法的传递</p>
<p>局部变量表中的变量也是重要的的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</p>
<h4 id="字节码的内部方法"><a href="#字节码的内部方法" class="headerlink" title="字节码的内部方法"></a>字节码的内部方法</h4><p>一个静态主函数方法</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/008.png"  alt="jvm"></p>
<p>该主函数对应的字节码方法</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/009.png"  alt="jvm"></p>
<p>主函数相关信息(方法名，参数返回值，修饰符信息)</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/010.png"  alt="jvm"></p>
<p>字节码解析信息</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/011.png"  alt="jvm"></p>
<p>方法参数数量，字节码长度</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/012.png"  alt="jvm"></p>
<p>LineNumberTable存储字节码和.Java文件信息的对应位置，Start PC表示变量在字节码中的位置，Line Number表示变量在.Java文件中的位置</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/013.png"  alt="jvm"></p>
<p>LocalVariableTable存储变量在字节码中的信息，Name变量名，Length是变量作用域长度，Start PC是变量作用域生效位置</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/014.png"  alt="jvm"></p>
<h4 id="变量槽Solt"><a href="#变量槽Solt" class="headerlink" title="变量槽Solt"></a>变量槽Solt</h4><p>局部变量基础的存储单元就是Solt槽</p>
<p>局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference),returnAddress类型的变量</p>
<p>在局部变量表中，32位以内的类型只占一个solt(包括returnAddress类型)，64位的类型(long,double)占用两个solt</p>
<p>byte,short,char在存储前被转换为int，boolean也被转换为int,0表示false,非0表示true</p>
<p> JVM会为局部变量表中的每一个solt都分配一个访问索引，通过这些索引即可成功访问到局部变量表中指定的局部变量值</p>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个solt上</p>
<p>如果需要访问局部变量表中一个bit的局部变量值式，只需要使用前一个索引即可</p>
<p>如果当前栈帧是由构造函数或者实例方法创建的(静态方法不在此列)，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序排列，静态方法是不允许通过this方法调用变量的，this也是一个变量，每一个非静态方法中都有this变量</p>
<p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会重复过期局部变量的槽位，从而达到节省资源的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public void test4() &#123;</span><br><span class="line">        int a &#x3D; 0;</span><br><span class="line">        &#123;</span><br><span class="line">            int b &#x3D; 0;</span><br><span class="line">            b &#x3D; a + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;变量c使用之前已经销毁的变量b占据的slot的位置</span><br><span class="line">        int c &#x3D; a + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c重用失效局部变量b的槽位</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/015.png"  alt="jvm"></p>
<h4 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h4><h5 id="按照类型分"><a href="#按照类型分" class="headerlink" title="按照类型分"></a>按照类型分</h5><p>基本数据类型，引用数据类型</p>
<h5 id="按照在类中声明的位置分"><a href="#按照在类中声明的位置分" class="headerlink" title="按照在类中声明的位置分"></a>按照在类中声明的位置分</h5><h6 id="成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量"><a href="#成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量" class="headerlink" title="成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量"></a>成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量</h6><p>类变量：静态成员变量，linking的prepare阶段，给类变量默认赋值，给类变量显示赋值即静态代码块墨汁</p>
<p>实例变量：普通成员变量，随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</p>
<h6 id="局部变量：在使用前，必须进行显示赋值，否则，编译不通过"><a href="#局部变量：在使用前，必须进行显示赋值，否则，编译不通过" class="headerlink" title="局部变量：在使用前，必须进行显示赋值，否则，编译不通过"></a>局部变量：在使用前，必须进行显示赋值，否则，编译不通过</h6><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>栈可以使用数组或者链表来实现，操作数栈是通过数组实现的</p>
<p>Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</p>
<p>操作数栈的作用是执行数据计算操作，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据</p>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/016.png"  alt="jvm"></p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</p>
<p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p>
<p>操作数栈的长度也是在编译器确定的，与局部变量表长度无关</p>
<h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作需要使用更多的入栈和出栈指令，这意味着需要更多的指令分派次数和内存读写次数</p>
<p>栈顶缓存技术可以解决这个问题，将栈顶元素全部缓存在物理cpu的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率</p>
<h3 id="动态链接-指向运行时常量池的方法引用"><a href="#动态链接-指向运行时常量池的方法引用" class="headerlink" title="动态链接(指向运行时常量池的方法引用)"></a>动态链接(指向运行时常量池的方法引用)</h3><p>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。目的是支持当前方法的代码能够实现动态链接</p>
<p>在Java源文件被编译到字节码文件中时所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/018.png"  alt="jvm"></p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>存放调用该方法的pc寄存器的值，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址，而通过异常退出的，返回地址是要通过异常表来确定</p>
<p>方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置pc寄存器的值等，让调用者方法接着执行下去</p>
<p>正常完成方法调用和异常完成的区别在于：通过异常完成方法退出的不会给他的上层调用者产生任何返回值</p>
<p>异常表存储的是某行出现异常之后，跳转到哪一行，按照那一行进行处理的数据</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/019.png"  alt="jvm"></p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</p>
<p>本地方法栈也是线程私有的</p>
<p>本地方法栈的具体做法是在Native Method Stack中登记native方法，在执行引擎执行时加载本地方法库</p>
<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有相同的权限</p>
<p>并不是所有的虚拟机都支持本地方法，在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一</p>
<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><p>本地接口的作用是融合不同语言的为Java所用，初衷是融合C/C++程序</p>
<p>标识符native可以和除abstract以外的修饰符连用</p>
<h3 id="为什么要使用Native-Method"><a href="#为什么要使用Native-Method" class="headerlink" title="为什么要使用Native Method"></a>为什么要使用Native Method</h3><h4 id="与其他语言交互"><a href="#与其他语言交互" class="headerlink" title="与其他语言交互"></a>与其他语言交互</h4><p>有时Java应用需要与Java外面的环境交互，本地方法接口可以屏蔽其他语言的复杂性</p>
<h4 id="与操作系统交互"><a href="#与操作系统交互" class="headerlink" title="与操作系统交互"></a>与操作系统交互</h4><p>操作系统底层是C/C++语言实现的，JVM部分也是C/C++语言实现的，所以使用本地接口是必然的</p>
<h4 id="提高执行效率"><a href="#提高执行效率" class="headerlink" title="提高执行效率"></a>提高执行效率</h4><p>当需要操作硬件的时候，C/C++是更好的选择，Java操作硬件考虑性能时需要使用本地接口</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>一个JVM实例只存在一个堆内存，堆可以处于物理上不连续的内存空间，但在逻辑上应该被视为连续的，即通过映射表使物理上不连续的内存空间在虚拟逻辑层面看起来是连续的，方便管理</p>
<p>几乎所有的对象实例以及数组都应当在运行时分配在堆上，虚拟机栈不存储数据只存储引用，引用指向堆中的实例对象数据</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/020.png"  alt="jvm"></p>
<p>方法结束之后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除，这样做的原因是方法结束就GC太过频繁，效率不高</p>
<p>堆是垃圾回收的重点区域，栈是不存在GC的，只有入栈出栈操作</p>
<h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><p>堆区是线程共享区，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的，为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度，所以有了TLAB的概念，为每个线程提供一个私有的区域，它包含在eden区中</p>
<p>堆中的数据除了TLAB(Thread Local Allocation Buffer)以外的区域都是线程共享的，TLAB是线程私有的，提高并发性，同时还能够提升内存分配的吞吐量</p>
<p>-XX:UserTLAB设置是否开启TLAB空间</p>
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/031.png"  alt="jvm"></p>
<p>默认的TLAB仅占eden空间的1%，可以通过-XX:TLABWasteTargetPercent设置占比</p>
<p>如果对象在TLAB空间分配内存失败，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在eden空间中分配内存</p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>现代垃圾收集器大部分都是基于分代收集理论设计</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/021.png"  alt="jvm"></p>
<p>永久代/元空间就是方法区，可以不看做堆空间的一部分</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/022.png"  alt="jvm"></p>
<p>-XX:+PrintGCDetails虚拟机指令可以在控制台打印相关的堆空间信息</p>
<h2 id="堆空间大小的设置和查看"><a href="#堆空间大小的设置和查看" class="headerlink" title="堆空间大小的设置和查看"></a>堆空间大小的设置和查看</h2><p>-X是jvm的运行参数，ms是memery start,mx是memery max</p>
<p>-Xms用于表示堆区的起始内存，等价于-XX:InitialHeapSize</p>
<p>-Xmx则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</p>
<p>一旦堆区中的内存大小超过-Xmx所指定的最大内存时，将会抛出OutOfMemoryError异常</p>
<p>默认情况下，初始内存大小：物理电脑内存/64；最大内存大小：物理电脑内存/4</p>
<p>通常会将-Xms和-Xmx两个参数配置相同的值，避免重复扩容，在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;返回Java虚拟机中的堆内存总量</span><br><span class="line">long initialMemory &#x3D; Runtime.getRuntime().totalMemory() &#x2F; 1024 &#x2F; 1024;</span><br><span class="line">&#x2F;&#x2F;返回Java虚拟机试图使用的最大堆内存量</span><br><span class="line">long maxMemory &#x3D; Runtime.getRuntime().maxMemory() &#x2F; 1024 &#x2F; 1024;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;-Xms : &quot; + initialMemory + &quot;M&quot;);</span><br><span class="line">System.out.println(&quot;-Xmx : &quot; + maxMemory + &quot;M&quot;);</span><br><span class="line">-----------------输出结果-----------------------------</span><br><span class="line">-Xms : 184M</span><br><span class="line">-Xmx : 2709M</span><br></pre></td></tr></table></figure>

<p>可以通过jps指令查看堆区使用状态，C结尾表示总量大小，U结尾表示已使用容量的大小</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/023.png"  alt="jvm"></p>
<p>在控制带打印的结果和通过jps指令打印的结果是相同的，注意堆中的年轻代s1，s2两个区域在一个线程堆中只能同时运行一个</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/024.png"  alt="jvm"></p>
<h2 id="OOM-OutOfMemory"><a href="#OOM-OutOfMemory" class="headerlink" title="OOM(OutOfMemory)"></a>OOM(OutOfMemory)</h2><p>内存溢出错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class OOMTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(20);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(new Picture(new Random().nextInt(1024 * 1024)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Picture&#123;</span><br><span class="line">    private byte[] pixels;</span><br><span class="line"></span><br><span class="line">    public Picture(int length) &#123;</span><br><span class="line">        this.pixels &#x3D; new byte[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------异常错误-----------------------------------</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.atguigu.java.Picture.&lt;init&gt;(OOMTest.java:29)</span><br><span class="line">	at com.atguigu.java.OOMTest.main(OOMTest.java:20)</span><br></pre></td></tr></table></figure>

<h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/025.png"  alt="jvm"></p>
<p>存储在JVM中的Java对象可以被分为两类</p>
<p>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常的迅速</p>
<p>一类是生命周期非常长，在某些极端情况下还能够与JVM的生命周期保持一致</p>
<h3 id="配置年轻代和老年代在堆结构中的占比"><a href="#配置年轻代和老年代在堆结构中的占比" class="headerlink" title="配置年轻代和老年代在堆结构中的占比"></a>配置年轻代和老年代在堆结构中的占比</h3><p>默认-XX:NewRatio=2,表示年轻代占1，老年代占2</p>
<p>可以修改为-XX:NewRatio=4,表示年轻代占1，老年代占4</p>
<h3 id="配置Eden区，两个Survivor的占比"><a href="#配置Eden区，两个Survivor的占比" class="headerlink" title="配置Eden区，两个Survivor的占比"></a>配置Eden区，两个Survivor的占比</h3><p>-XX:SurvivorRatio=8,设置eden,survivor的比例为8:1:1，默认占比是6:1:1</p>
<p>几乎所有的对象都是在eden区创建的，如果对象太大太多eden放不下就会用到老年代</p>
<p>绝大多数的Java对象的销毁都在新生代进行了</p>
<p>eden存活下来的对象会放到survivor区，再存活放到老年代中</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/026.png"  alt="jvm"></p>
<h3 id="配置年轻代的大小"><a href="#配置年轻代的大小" class="headerlink" title="配置年轻代的大小"></a>配置年轻代的大小</h3><p>-Xmn</p>
<p>当年轻代与老年代的比例和配置的年轻代的大小冲突时，以-Xmn为准</p>
<h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><p>虚拟机调优的主要目的就是降低GC的次数，提高性能</p>
<p>重点关注Major GC和Full GC因为这两个GC产生的暂停时间远远大于Minor GC</p>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p>对象创建优先使用eden</p>
<p>大对象直接分配到老年代，尽量避免程序中出现过多的大对象</p>
<p>长期存活的对象分配到老年代</p>
<p>动态对象年龄判断:如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一般，年龄大于或者等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄</p>
<p>空间分配担保:-XX:HandlerPromotionFailure,将Surivior区中存不下的对象放到老年代中存储</p>
<h3 id="YGC-Minor-GC"><a href="#YGC-Minor-GC" class="headerlink" title="YGC/Minor GC"></a>YGC/Minor GC</h3><p>eden区满了之后触发ygc，回收红色垃圾，绿色对象放到s0区并且添加年代计数器，此时s0作为from区，s1作为to区</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/027.png"  alt="jvm"></p>
<p>再次ygc的时候，eden存活的对象会存储到为空的s1区，s0区的存活对象也会转移s1区，此时s0就为空了，s1作为from区，s0作为to区</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/028.png"  alt="jvm"></p>
<p>往复循环，保证一个survivor区是为空的，作为to区</p>
<p>年代计数器达到阈值15之后，再gc就会将目标对象转移到老年代中</p>
<p>可以通过-XX:MaxTenuringThreshold=N来设置阈值</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/029.png"  alt="jvm"></p>
<p>survivor区复制之后有交换，谁空谁是to</p>
<p>GC频繁在年轻代收集，很少在老年代收集，几乎不在永久代/元空间收集，百分之八十的对象的生命周期在eden区就完成了，老年代空间更大，很少gc</p>
<p>eden区ygc之后一定是空的</p>
<p>eden区满的时候触发ygc，survivor区满的时候不会触发，会直接将对象放到老年代</p>
<p>当eden存储不下某个对象时，会直接将该对象创建存储在在老年代中，如果老年代也存放不下，那么会触发fgc之后再存储到老年代中</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/030.png"  alt="jvm"></p>
<h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>发生在老年代的GC,经常伴随至少一次的Minor GC(非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)，即一般在回收老年代垃圾之前会先回收年轻代的垃圾</p>
<p>如果Major GC之后还是内存不足，就会报OOM</p>
<p>Major GC的速度一般会比Minor GC慢十倍以上，STW时间更长</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>触发Full GC整堆收集执行有以下五个场景：</p>
<ol>
<li>调用System.gc()，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于来年代的可用内存</li>
<li>eden,form区向to区复制时,写入的对象大小大于to区内存，将该对象转存到老年代，且老年代的可用内存小于该对象</li>
</ol>
<p>Full GC时开发或者调优中尽量要避免的，避免线程暂停时间过长</p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>GC按照回收区域又分为两大类型：一种是部分收集(Partial GC)，一种是整堆收集(Full GC)</p>
<h3 id="部分收集-不是完整收集整个Java堆的垃圾收集"><a href="#部分收集-不是完整收集整个Java堆的垃圾收集" class="headerlink" title="部分收集:不是完整收集整个Java堆的垃圾收集"></a>部分收集:不是完整收集整个Java堆的垃圾收集</h3><p>新生代收集(Minor GC/Yong GC):只是年轻代的垃圾收集</p>
<p>老年代收集(Major GC/Old GC):只是老年代的垃圾收集</p>
<p>混合收集(Mixed GC):收集整个年轻代以及部分老年代的垃圾收集</p>
<p>目前只有CMS GC会有单独收集老年代的行为，只有G1 GC会有混合收集的行为</p>
<p> 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是eden区满，Survivor满不会引发GC，每次Minor GC会清理年轻代的内存(eden清空，Survivor转移)</p>
<p>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，回收速度也快</p>
<p>Minor GC会引发STW(stop the world),暂停其他用户的线程，等垃圾回收结束，用户线程才会恢复</p>
<h3 id="整堆收集-Full-GC-收集整个Java堆和方法区的垃圾收集"><a href="#整堆收集-Full-GC-收集整个Java堆和方法区的垃圾收集" class="headerlink" title="整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集"></a>整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集</h3><p>很多时候Major GC会和Full GC混淆使用，需要分清楚是老年代回收还是整堆回收</p>
<h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><p>-XX:+PrintGCDetails显示GC信息</p>
<h2 id="堆的参数设置"><a href="#堆的参数设置" class="headerlink" title="堆的参数设置"></a>堆的参数设置</h2><p>-XX:+PrintFlagsInitial:查看所有的参数的默认初始值</p>
<p>-XX:+PrintFlagsFinal:查看所有的参数的最终值(可能会存在修改，不再是初始值)</p>
<p>-Xms:初始堆空间内存(默认为物理内存的1/64)</p>
<p>-Xmx:最大堆空间内存(默认为物理内存的1/4)</p>
<p>-Xmn:设置新生代的大小(初始值及最大值)</p>
<p>-XX:NewRatio:配置年轻代与老年代在堆结构中的占比</p>
<p>-XX:SurvivorRatio:设置新生代eden和s0/s1空间的比例</p>
<p>-XX:MaxTenuringThreshole:设置新生代垃圾的最大年龄</p>
<p>-XX:+PrintGCDetails:输出详细的GC处理日志</p>
<p>-XX:HandlerPromotionFailure:是否设置空间分配担保</p>
<h2 id="堆是分配对象存储的唯一选择吗？"><a href="#堆是分配对象存储的唯一选择吗？" class="headerlink" title="堆是分配对象存储的唯一选择吗？"></a>堆是分配对象存储的唯一选择吗？</h2><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了</p>
<p>虚拟机中，对象是在Java堆中分配内存的，但是，有一种特殊情况，那就是如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样也就无需在堆上分配内存，也无须进行垃圾回收了，这就是最常见的堆外存储技术</p>
<p>基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH(GC invisible heap)技术实现off-heap,将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>将堆上的对象分配到栈，需要使用逃逸分析技术</p>
<p>是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</p>
<p>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要及那个这个对象分配到堆上</p>
<h4 id="逃逸分析的基本行为就是分析对象动态作用域"><a href="#逃逸分析的基本行为就是分析对象动态作用域" class="headerlink" title="逃逸分析的基本行为就是分析对象动态作用域"></a>逃逸分析的基本行为就是分析对象动态作用域</h4><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</p>
<p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生了逃逸。例如作为调用参数传递到其他地方中</p>
<p>每个线程都对应着一个栈，栈不存在同步问题；每一个栈内放的都是一个个栈帧，不存在gc，栈帧资源都是自动释放的。所以没有发生逃逸的对象就可以放在栈空间当中</p>
<h5 id="存在逃逸情况的方法"><a href="#存在逃逸情况的方法" class="headerlink" title="存在逃逸情况的方法"></a>存在逃逸情况的方法</h5><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/032.png"  alt="jvm"></p>
<h5 id="规避逃逸情况的方法"><a href="#规避逃逸情况的方法" class="headerlink" title="规避逃逸情况的方法"></a>规避逃逸情况的方法</h5><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/033.png"  alt="jvm"></p>
<p>Java7之后默认开启了逃逸分析</p>
<p>-XX:+DoEscapeAnalysis开启逃逸分析</p>
<p>-XX: +PrintEscapeAnalysis查看逃逸分析的筛选结果</p>
<p> 开发中能使用局部变量的，就不要使用在方法外定义</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>不存在逃逸的对象，JVM会将堆分配转换为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</p>
<p>运行启动项目的时间要比调式启动的时间短，下面的例子使用运行启动，调试启动时间无变化看不到效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class StackAllocation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10000000; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 查看执行时间</span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费的时间为： &quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line">        &#x2F;&#x2F; 为了方便查看堆内存中对象个数，线程sleep</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000000);</span><br><span class="line">        &#125; catch (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void alloc() &#123;</span><br><span class="line">        User user &#x3D; new User();&#x2F;&#x2F;未发生逃逸</span><br><span class="line">    &#125;</span><br><span class="line">    static class User &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-XX:-DoEscapeAnalysis关闭逃逸分析，运行结果60ms,JVM堆中维护User对象，会发生GC</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/034.png"  alt="jvm"></p>
<p>Java7以上默认是开启了逃逸分析的,运行结果4ms，JVM栈中维护User对象，不会发生GC</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/035.png"  alt="jvm"></p>
<h4 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h4><p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</p>
<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步，以此来提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除</p>
<h4 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h4><p>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象(部分或者全部)可以不存储在内存，而是存储在cpu寄存器中</p>
<p>标量是指一个无法再分解成更小的数据的数据，Java中原始数据类型就是标量</p>
<p>可以被分解的数据叫做聚合量，Java中的对象就是聚合量，因为它可以分解成其他聚合量和标量</p>
<p>经逃逸分析发现一个对象不会被外界访问，那么经过JIT优化，就会把这个对象拆解几个标量，这个过程就是标量替换，标量替换默认就是打开的</p>
<p>替换前</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/036.png"  alt="jvm"></p>
<p>替换后</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/037.png"  alt="jvm"></p>
<p>Point这个聚合量经过逃逸分析后，发现它并没有逃逸，就被替换成两个聚合量了</p>
<p>标量替换的好处就是可以大大减少堆内存的占用，因为一旦不需要创建对象了，那么就不再需要分配对内存了</p>
<p>标量替换为栈上分配提供了很好的基础</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="栈，堆，方法区的交互关系"><a href="#栈，堆，方法区的交互关系" class="headerlink" title="栈，堆，方法区的交互关系"></a>栈，堆，方法区的交互关系</h2><p>从线程共享与否的角度来看</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/038.png"  alt="jvm"></p>
<p>三者之间的交互关系</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/039.png"  alt="jvm"></p>
<h2 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h2><p>尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。所以方法区(元空间)看作是一块独立于Java堆的内存空间</p>
<p>方法区和堆一样，是各个线程共享的内存区域</p>
<p>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都是不连续的</p>
<p>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展</p>
<p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误OOM</p>
<p>关闭JVM就会释放方法区的内存</p>
<h2 id="方法区的演进"><a href="#方法区的演进" class="headerlink" title="方法区的演进"></a>方法区的演进</h2><p>jdk7以前，习惯上把方法区称为永久代。jdk8开始，使用元空间取代了永久代</p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p>
<p>永久代，元空间二者并只是名字变了，内部结构也变了</p>
<p>如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p>
<h3 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h3><p>方法区的大小不必是固定的，jvm可以根据应用的需要动态调整</p>
<h4 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h4><p>通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M</p>
<p>通过-XX:MaxPermSize来设定永久代最大可分配空间。32位机器默认是64M,64位机器默认是82M</p>
<p>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space</p>
<h4 id="jdk8及以后"><a href="#jdk8及以后" class="headerlink" title="jdk8及以后"></a>jdk8及以后</h4><p>元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替换上述原有的两个参数。windows下默认-XX:MetaspaceSize是21M,-XX:MaxMetaspaceSize的值是-1，即没有限制</p>
<p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p>
<p>-XX:MetaspaceSize:设置初始元空间大小的初始值是21，这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类(即这些类对应的类加载器不再存货)，然后这个高水位线将会被重置。新的高水位线的值取决于GC后释放了多少元空间，如果释放的空间不足，那么将在不超过XX:MetaspaceSize的前提下适当提高该值，如果释放空间过多，则适当降低该值</p>
<p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以查看到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值</p>
<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p>方法区用于存储已经被虚拟机加载的类型信息,常量,静态变量,JIT即时编译器编译后的代码缓存等</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/040.png"  alt="jvm"></p>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型(class,interface,enum,annotation),JVM必须在方法区中存储以下类型信息</p>
<ul>
<li>全名=包名.类名</li>
<li>父类的全名(interface,java.lang.Object都没有父类)</li>
<li>类的修饰符</li>
<li>直接接口的一个有序列表</li>
</ul>
<p>域Field信息</p>
<ul>
<li>JVM必须在方法区中保存域的相关信息以及域的声明顺序</li>
<li>域的相关信息包括：域名称，域类型，域修饰符</li>
</ul>
<p>方法信息</p>
<ul>
<li>声明顺序</li>
<li>方法名称</li>
<li>方法返回类型</li>
<li>方法参数的数量和类型(按顺序)</li>
<li>方法的修饰词</li>
<li>方法的字节码，操作数栈，局部变量表及大小(abstract和native方法除外)</li>
<li>异常表(abstract和native方法除外)</li>
</ul>
<h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><p>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分</p>
<p>类变量被类的所有实例共享，即使没有类实例时也可以访问</p>
<p>被声明为final的类变量的处理方法则不同，每个全局变量在编译的时候就会被分配了</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>方法区内部包含了运行时常量池，字节码文件内部也包含了常量池(先弄清楚常量池)</p>
<p>数据存储到字节码文件中会非常占用空间，可以将数据存储到常量池中，字节码文件只包含指向常量池的引用，压缩字节码文件的大小</p>
<p>带#的数据都是引用常量池中的数据，#后面的数字对于常量池中的位置</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/041.png"  alt="jvm"></p>
<p>运行时常量池是方法区的一部分</p>
<p>常量池表是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</p>
<p>运行时常量池在加载类和接口到虚拟机后，就会创建对应的运行时常量池</p>
<p>JVM为每个已加载的类型都维护一个常量池，池中的数据通过索引访问</p>
<p>运行时常量池中包含多种不同的变量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址</p>
<p>运行时常量池相对于字节码文件常量池的一个重要特征就是具备动态性</p>
<p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OOM异常</p>
<h2 id="方法区的使用"><a href="#方法区的使用" class="headerlink" title="方法区的使用"></a>方法区的使用</h2><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/042.png"  alt="jvm"></p>
<h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><p>只有HotSpot才有永久代。BEA JRockit，IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p>
<h3 id="Hotspot中方法区的变化"><a href="#Hotspot中方法区的变化" class="headerlink" title="Hotspot中方法区的变化"></a>Hotspot中方法区的变化</h3><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/043.png"  alt="jvm"></p>
<h4 id="JDK6的方法区"><a href="#JDK6的方法区" class="headerlink" title="JDK6的方法区"></a>JDK6的方法区</h4><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/044.png"  alt="jvm"></p>
<h4 id="JDK7的方法区"><a href="#JDK7的方法区" class="headerlink" title="JDK7的方法区"></a>JDK7的方法区</h4><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/045.png"  alt="jvm"></p>
<h4 id="JDK8的方法区"><a href="#JDK8的方法区" class="headerlink" title="JDK8的方法区"></a>JDK8的方法区</h4><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/046.png"  alt="jvm"></p>
<p>永久代的数据是存储在虚拟机的虚拟内存中，元空间的数据存储在本地内存当中</p>
<h4 id="为什么要用元空间替代永久代？"><a href="#为什么要用元空间替代永久代？" class="headerlink" title="为什么要用元空间替代永久代？"></a>为什么要用元空间替代永久代？</h4><p>随着Java8的到来，HotSpot VM中再也见不到永久代了，但是这个并不意味着元数据也消失了，这些数据被转移到了一个与堆不相连的本地内存区域，这个区域叫做元空间</p>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动非常有必要，原因如下：</p>
<h5 id="为永久代设置空间大小是很难确定的"><a href="#为永久代设置空间大小是很难确定的" class="headerlink" title="为永久代设置空间大小是很难确定的"></a>为永久代设置空间大小是很难确定的</h5><p>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。而元空间并不在虚拟机中，而是使用本地内存，因此默认情况下，元空间的大小仅受本地内存限制</p>
<h5 id="对永久代进行调优是很困难的"><a href="#对永久代进行调优是很困难的" class="headerlink" title="对永久代进行调优是很困难的"></a>对永久代进行调优是很困难的</h5><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类。判断一个类不再被使用了是一件比较麻烦的事情</p>
<h4 id="StringTable字符串常量池为什么要调整位置？"><a href="#StringTable字符串常量池为什么要调整位置？" class="headerlink" title="StringTable字符串常量池为什么要调整位置？"></a>StringTable字符串常量池为什么要调整位置？</h4><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足，永久代不足时才会触发。这也就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低导致永久代内存不足，放到堆里能及时回收内存</p>
<p>jdk7以后Java虚拟机选择将静态变量与类型在Java语言一端的映射Class对象存放在一起，存放在Java堆之中</p>
<h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>方法区的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这个部分区域的回收有时又确实是必要的</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</p>
<p>判断一个类不再被使用了需要同时满足以下三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi,JSP的重加载等，通常是很难达成的</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而不是和对象一样，没有引用就必然被回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-version:class以及-XX:+TraceClass-Loading,-XX:+TraceClassUnLoading查看类加载和卸载信息</p>
<p>在大量使用反射，动态代理，CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/047.png"  alt="jvm"></p>
<h1 id="对象的实例化内存布局与访问定位"><a href="#对象的实例化内存布局与访问定位" class="headerlink" title="对象的实例化内存布局与访问定位"></a>对象的实例化内存布局与访问定位</h1><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/048.png"  alt="jvm"></p>
<h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/049.png"  alt="jvm"></p>
<p>加载类元信息–&gt;为对象分配内存–&gt;处理并发问题–&gt;属性的默认初始化–&gt;设置对象头信息–&gt;属性的显式初始化赋值</p>
<ol>
<li>判断对象对应的类是否加载，链接，初始化，即判断类元信息是否存在，如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为key进行查找对应对应的class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</li>
<li>首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果内存规整，那么就指针碰撞顺序排列；如果内存不规整，虚拟机需要维护一个列表，记录那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容，这种分配方式就是空闲列表。选择哪种分配方式又Java堆是否规范决定的，而Java堆是否规范又是由所采用的垃圾收集器是否带有压缩整理功能决定</li>
<li>处理并发问题， 采用CAS失败重试，区域加锁保证更新的原子性，每个线程预先分配一块TLAB，通过-XX:+/-UserTLAB参数来设定</li>
<li>初始化分配到的空间，所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</li>
<li>设置对象的对象头，将对象的所属类(即类的元数据信息)，对象的HashCode和对象的GC信息，锁信息等数据存储在对象的对象头中，这个过程的具体设置方式取决于JVM实现</li>
<li>执行init方法进行初始化，显式赋值，代码块赋值，构造函数赋值都是在这一步完成</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/050.png"  alt="jvm"></p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>运行时元数据：哈希值，GC分代年龄，锁状态标签，线程持有的锁，偏向线程ID，偏向时间戳</p>
<p>类型指针：指向类元数据instanceKlass,确定该对象所属的类型</p>
<p>如果是数组，还需记录数组的长度</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>说明：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段)</p>
<p>规则：相同宽度的字段总是被分配在一起；父类中定义的变量会出现在子类之前；如果CompactFields参数为true(默认为true)，子类的窄变量可能插入到父类变量的空隙</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>不是必须的，也没特别含义，仅仅起到占位符的作用</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/051.png"  alt="jvm"></p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呐？</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/054.png"  alt="jvm"></p>
<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/052.png"  alt="jvm"></p>
<p>句柄访问的优点是栈空间引用地址不需要更改</p>
<h3 id="直接指针-Hotspot采用"><a href="#直接指针-Hotspot采用" class="headerlink" title="直接指针(Hotspot采用)"></a>直接指针(Hotspot采用)</h3><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/053.png"  alt="jvm"></p>
<p>直接指针的优点是节省空间速度快</p>
<h1 id="直接内存-本地内存"><a href="#直接内存-本地内存" class="headerlink" title="直接内存(本地内存)"></a>直接内存(本地内存)</h1><p>jdk8之后使方法区从永久代移动到了元空间，而元空间是使用直接内存的</p>
<p>不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域</p>
<p>直接内存是在Java堆外的，直接向系统申请的内存区间</p>
<p>直接内存来源于NIO,通过存在堆中的DirectByteBuffer操作Native内存</p>
<p>通常，访问直接内存的速度会优于Java堆，即读写性能高，所以读写频繁的场合可能会考虑使用直接内存，NIO库允许Java程序使用直接内存用于数据缓冲区</p>
<table>
<thead>
<tr>
<th>IO</th>
<th>NIO(New IO/Non-Blocking IO)</th>
</tr>
</thead>
<tbody><tr>
<td>byte[]/char[]</td>
<td>Buffer</td>
</tr>
<tr>
<td>Stream</td>
<td>Channel</td>
</tr>
</tbody></table>
<h2 id="直接内存的OOM与内存大小的设置"><a href="#直接内存的OOM与内存大小的设置" class="headerlink" title="直接内存的OOM与内存大小的设置"></a>直接内存的OOM与内存大小的设置</h2><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存</p>
<p>直接内存的缺点是分配回收成本较高，且不受JVM内存回收管理</p>
<p>直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值-Xmx参数一致</p>
<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行引擎是Java虚拟机核心的组成部分之一</p>
<p>虚拟机是一个相对于物理机的概念，物理机的执行引擎是建立在硬件上的；而虚拟机执行引擎是基于软件实现的</p>
<p>字节码不能直接运行在操作系统上，因为字节码指令并非等于本地机器指令，它内部包含的仅仅只是一些能够被JVM识别的字节码指令，字符表，以及其他辅助信息</p>
<p>执行引擎的任务就是将字节码指令编译为对应平台上的本地机器指令才可以，JVM中执行引擎充当了将高级语言翻译为机器语言的译者，执行字节码一行行的代码</p>
<h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/055.png"  alt="jvm"></p>
<p>大部分的程序代码转换成物理机的目标代码(绿色)或者虚拟机能执行的指令集(蓝色)之前，都需要经过上图中的各个步骤</p>
<h2 id="机器码，指令，汇编语言，高级语言"><a href="#机器码，指令，汇编语言，高级语言" class="headerlink" title="机器码，指令，汇编语言，高级语言"></a>机器码，指令，汇编语言，高级语言</h2><p>机器码有01构成，可以直接在cpu上运行</p>
<p>指令就是把机器码中特定的01序列，简化成对应的指令，例如mov,inc等</p>
<p>汇编语言中，用助记符代替机器指令的操作符，用地址符号代替指令</p>
<p>高级语言就是现在的C,C++,Java更加的贴近人的语言 </p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/057.png"  alt="jvm"></p>
<p>字节码是一种中间状态的二进制文件，它比机器码更抽象，需要直译器转译后才能成为机器码</p>
<p>字节码主要为了实现特定软件运行和软件环境，与硬件环境无关</p>
<p>字节码的实现方式是通过编译器和虚拟机器，编译器将源码编译成字节码</p>
<p>特定平台上的虚拟机器将字节码转译为可以直接执行的指令，字节码的典型应用为Java bytecode</p>
<p>解释器和即时编译器都是操作字节码，不过解释器是每次执行的时候去一行行的读取字节码，即时编译器是字节码编译为本地机器码，以供调用</p>
<h2 id="解释器-Interpreter"><a href="#解释器-Interpreter" class="headerlink" title="解释器(Interpreter)"></a>解释器(Interpreter)</h2><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令</p>
<p>字节码解释器在执行时通过纯软件代码模拟字节码一行行执行，效率非常低下</p>
<p>模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能</p>
<p>现在普遍使用的都是模板解释器</p>
<p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成，Interpreter实现了解释器的核心功能，code用于管理虚拟机在运行时生成的本地机器指令</p>
<p>解释器实现很简单，但是现在已经沦为低效的代名词，为了解决这个问题，JVM平台推出了一种叫做即时编译的技术</p>
<h2 id="JIT编译器-Just-In-Time-Compiler"><a href="#JIT编译器-Just-In-Time-Compiler" class="headerlink" title="JIT编译器(Just In Time Compiler)"></a>JIT编译器(Just In Time Compiler)</h2><p>虚拟机将字节码直接编译成和本地机器平台相关的机器语言</p>
<p>即时编译的目的是避免函数被解释执行，将整个函数体编译成机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升</p>
<p>HotSpot VM是市面上高性能虚拟机的代表作之一，它采用解释器与即时编译器并存的架构，在Java虚拟机运行时，解释器和编译器能够相互协作，各自取长补短，尽量去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间</p>
<p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样就可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率</p>
<p>因为执行引擎既可以编译器执行，也可以通过解释器执行，所以Java是一门半编译半解释型语言</p>
<p>Java1.0时代是使用解释器的，但是解释器效率没那么高，所以现在的JVM都是将解释执行和编译执行二者结合在一起使用</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/056.png"  alt="jvm"></p>
<h3 id="JIT和解释器的对比"><a href="#JIT和解释器的对比" class="headerlink" title="JIT和解释器的对比"></a>JIT和解释器的对比</h3><p>翻译器的优点是响应速度快，JIT的优点是性能高</p>
<p>程序启动后，解释器可以马上发挥作用，省去编译时间，立即执行；编译器想要发挥作用，要先将字节码编译成本地代码，需要一定的执行时间。但是编译为本地代码后，执行效率更高</p>
<p>尽管JRockit VM中程序的执行性能会非常高效(只使用了JIT),但程序启动时需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非关注重点，但对于那些看重启动时间的应用场景而言，或许就需要采用解释器和即时编译器并存的架构来换取一个平衡点。</p>
<p>当Java虚拟机启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间，随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率</p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的逃生门(JIT不好用，再用备用方案解释器)</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>机器在热机状态可以承受的负载要大于冷机状态，如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死</p>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多分批次，每个批次的机器至多占到整个集群的1/8。曾经有这样的故障：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动后，当前1/2发布成功的服务器全部宕机，此故障说明JIT的存在</p>
<h3 id="热点代码探测决定何时JIT"><a href="#热点代码探测决定何时JIT" class="headerlink" title="热点代码探测决定何时JIT"></a>热点代码探测决定何时JIT</h3><p>Java语言的编译器其实是一段不确定的操作过程，因为它可能是指一个前端编译器，把.java文件转变成.class文件的过程；也可能是指虚拟机的后端运行期编译器(JIT编译器)把字节码转变成机器码的过程；还可能是指使用静态提前编译器(AOT编译器)直接把.java文件编译成本地机器代码的过程</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/058.png"  alt="jvm"></p>
<h4 id="热点代码探测方式"><a href="#热点代码探测方式" class="headerlink" title="热点代码探测方式"></a>热点代码探测方式</h4><p>是否需要启动JIT编译器将代码直接编译为对于平台的本地机器指令，则需要根据代码被调用执行的频率而定。</p>
<p>一个被多次调用的方法或者是一个方法体内部循环次数较多的循环体都可以被称之为热点代码，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，简称OSR(On Stack Replacement)编译</p>
<p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测，HotSpot VM会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器和回边计数器，方法调用计数器用于统计方法的调用次数，默认阈值在client模式下是1500次，在server模式下是10000次，超过这个阈值，就会触发JIT编译；回边计数器则用于统计循环体执行的循环次数</p>
<p>方法调用器的阈值可以通过-XX:CompileThreshold来人为设定</p>
<p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加一，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/059.png"  alt="jvm"></p>
<p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，方法的调用次数仍然不足以让它提交给即时编译器，那么这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期</p>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间</p>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/060.png"  alt="jvm"></p>
<p>和方法调用计数器搭配使用</p>
<h2 id="HotSpot-VM设置程序执行方式"><a href="#HotSpot-VM设置程序执行方式" class="headerlink" title="HotSpot VM设置程序执行方式"></a>HotSpot VM设置程序执行方式</h2><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，开发人员可以根据具体的应用场景，通过命令显示地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行</p>
<p>-Xint:完全采用解释器模式执行程序</p>
<p>-Xcomp:完全采用即时编译器模式执行程序，如果即时编译出现问题，解释器会介入执行</p>
<p>-Xmixed:采用解释器和编译器混合模式共同执行程序(默认的)</p>
<h2 id="C1和C2编译器"><a href="#C1和C2编译器" class="headerlink" title="C1和C2编译器"></a>C1和C2编译器</h2><p>HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1，C2编译器</p>
<p>-client:指定Java虚拟机运行在Client模式下，并使用C1编译器，C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度</p>
<p>-server:指定Java虚拟机运行在server模式下，并使用C2编译器，C2编译器耗时较长的优化，以及激进优化，但优化的代码执行效率更高</p>
<p>64位的操作系统默认就是使用-server模式的C2编译器</p>
<p>C1优化策略：方法内联，去虚拟化，冗余消除</p>
<p>C2优化策略：标量替换，栈上分配，同步消除</p>
<p>JDK10起，HotSpot又加入了一个全新的即时编译器:Graal编译器，编译效果短短几年时间就追平了C2编译器，未来可期，开启指令是：-XX:+UnlockExperimentalVMOptions  -XX:+UseJVMCICompiler去激活，才可以使用，Graal编译器是一个和C2并列的概念</p>
<p>jdk9引入了AOT编译器(静态提前编译器，Ahead of Time Compiler)，AOT是和JIT对立的一个概念，JIT是指在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署托管到环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程</p>
<h3 id="AOT的优缺点"><a href="#AOT的优缺点" class="headerlink" title="AOT的优缺点"></a>AOT的优缺点</h3><p>优点：</p>
<ul>
<li>不必等待即时编译器的预热，减少Java应用给人带来第一次运行慢的不良体验</li>
</ul>
<p>缺点：</p>
<ul>
<li>破坏了Java一次编译，到处运行，必须为每个不同硬件编译对应的发行包</li>
<li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知</li>
</ul>
<h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><p>String不是基本数据类型而是一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;两种声明方式</span><br><span class="line">String a &#x3D; &quot;ls&quot;;</span><br><span class="line">String b &#x3D; new String(&quot;ls&quot;);</span><br></pre></td></tr></table></figure>

<p>String声明为final的，不可被继承</p>
<p>String实现了Serializable接口，表示字符串是支持序列化的；实现了Comparable接口，表示String可以比较大小</p>
<p>String在jdk8及以前内部定义了final char[] value用于存储字符串数据，jdk9改为final  byte[] value，字母用一个byte,中文用两个byte</p>
<h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><p> 通过字面量的方式(区别于new)给一个字符串赋值，此时的字符串值声明在字符串常量池中 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;abc&quot;;&#x2F;&#x2F;字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span><br><span class="line">String s2 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">System.out.println(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(s1.equals(s2));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>字符串常量池中是不会存储相同内容的字符串的，底层是通过一个StringTable+链表实现的</p>
<p>String的String Pool是一个固定大小的HashTable,默认值大小长度是1009。如果放进String Pool的String非常多，就会造成hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅度下降</p>
<p>new String都是在堆上创建字符串常量，当调用intern方法时，编译器会将字符串添加到常量池StringTable中，并返回该常量的引用</p>
<p>使用-XX:StringTableSize可设置StringTable的长度</p>
<p>在jdk6中StringTable是固定的，就是1009,所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设置没有要求</p>
<p>在jdk7中，StringTable的长度默认值是60013，1009是可设置的最小值 </p>
<p>jdk8开始，1009是StringTable可设置的最小值</p>
<h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><ul>
<li>对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</li>
<li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest1 &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        String s1 &#x3D; &quot;abc&quot;;&#x2F;&#x2F;字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span><br><span class="line">        String s2 &#x3D; &quot;abc&quot;;</span><br><span class="line">        s1 &#x3D; &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 &#x3D;&#x3D; s2);&#x2F;&#x2F;判断地址：true  --&gt; false</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);&#x2F;&#x2F;</span><br><span class="line">        System.out.println(s2);&#x2F;&#x2F;abc</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        String s1 &#x3D; &quot;abc&quot;;</span><br><span class="line">        String s2 &#x3D; &quot;abc&quot;;</span><br><span class="line">        s2 +&#x3D; &quot;def&quot;;</span><br><span class="line">        System.out.println(s2);&#x2F;&#x2F;abcdef</span><br><span class="line">        System.out.println(s1);&#x2F;&#x2F;abc</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        String s1 &#x3D; &quot;abc&quot;;</span><br><span class="line">        String s2 &#x3D; s1.replace(&#39;a&#39;, &#39;m&#39;);</span><br><span class="line">        System.out.println(s1);&#x2F;&#x2F;abc</span><br><span class="line">        System.out.println(s2);&#x2F;&#x2F;mbc</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="string不可变性面试题"><a href="#string不可变性面试题" class="headerlink" title="string不可变性面试题"></a>string不可变性面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class StringExer &#123;</span><br><span class="line">    String str &#x3D; new String(&quot;good&quot;);</span><br><span class="line">    char[] ch &#x3D; &#123;&#39;t&#39;, &#39;e&#39;, &#39;s&#39;, &#39;t&#39;&#125;;</span><br><span class="line">    public void change(String str, char ch[]) &#123;</span><br><span class="line">        str &#x3D; &quot;test ok&quot;;</span><br><span class="line">        ch[0] &#x3D; &#39;b&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StringExer ex &#x3D; new StringExer();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);&#x2F;&#x2F;good</span><br><span class="line">        System.out.println(ex.ch);&#x2F;&#x2F;best</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h2><p>在Java语言中有8中基本的数据类型和一种比较特殊的数据类型String,这些类型为了使它们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念</p>
<p>常量池就类似于一个Java系统提供的缓存，8中数据类型的常量池都是系统协调的，String类型的常量池比较特殊，它的主要使用方法有两种：</p>
<p>直接使用双引号声明出来的String对象会直接存储在常量池中，比如String info = “aa”;</p>
<p>如果不是用双引号声明的String对象，可以使用String提供的intern()方法</p>
<p>java6及以前，字符串常量池存放在永久代中。java7将字符串常量池的位置调整到Java堆中</p>
<p>所有的字符串都保存在堆中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了</p>
<h3 id="StringTable位置为什么要调整？"><a href="#StringTable位置为什么要调整？" class="headerlink" title="StringTable位置为什么要调整？"></a>StringTable位置为什么要调整？</h3><ul>
<li>permSize永久代默认比较小</li>
<li>永久代回收频率低</li>
</ul>
<h2 id="String的基本操作"><a href="#String的基本操作" class="headerlink" title="String的基本操作"></a>String的基本操作</h2><p>Java语言规范要求完全相同的字符串变量，应该包含同样的Unicode字符序列，并且必须是指向同一个String类实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;不会重复创建1</span><br><span class="line">System.out.println(&quot;1&quot;);</span><br><span class="line">System.out.println(&quot;1&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><p>常量与常量的拼接结果放在常量池，原理是编译期优化</p>
<p>常量池中不会存在相同内容的常量</p>
<p>拼接时,只要其中一个是变量，结果就在堆中。变量拼接的原理是StringBuilder调用append方法</p>
<p>如果拼接的结果调用了intern()方法，则主动将常量池中还没有的字符串对象放入池中</p>
<p>intern()方法：判断字符串常量池中是否存在目标字符串，如果存在，则返回目标字符串地址，如果不存在则在常量池中加载一份目标字符串，并返回字符串地址</p>
<h3 id="拼接操作与append操作的效率对比"><a href="#拼接操作与append操作的效率对比" class="headerlink" title="拼接操作与append操作的效率对比"></a>拼接操作与append操作的效率对比</h3><p> 通过stringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式</p>
<p>stringBuilder的append()方式自始至终只创建过一个stringBuilder对象，stringBuilder对象默认的长度是16，超过16会自动扩容。在实际开发中，如果基本确定添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器new  stringBuilder(highLevel)指定长度</p>
<p>使用string的字符串拼接方式，创建了多个stringBuilder和String对象，内存占用很大</p>
<h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h2><p>intern是native本地方法库中的方法</p>
<p>Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度</p>
<h4 id="String-s-new-String-“ab”-会创建几个对象？"><a href="#String-s-new-String-“ab”-会创建几个对象？" class="headerlink" title="String s = new String(“ab”)会创建几个对象？"></a>String s = new String(“ab”)会创建几个对象？</h4><p>2个，常量池中一个ab，堆中一个new String()</p>
<p>堆中创建了一个String对象，ab在字符串常量池中创建了一个对象，可以通过字节码指令查看</p>
<h4 id="String-s-new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#String-s-new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="String s = new String(“a”)+new String(“b”)会创建几个对象？"></a>String s = new String(“a”)+new String(“b”)会创建几个对象？</h4><p>6个，字符串相加使用的是StringBuilder的append方法，两个字符串相加只有一个StringBuilder对象，StringBuilder对象转换为String对象需要调用toString方法，还会在堆中创建一个String对象</p>
<p>StringBuilder的tostring的调用不会在字符串常量池中创建对象</p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; new String(&quot;1&quot;);</span><br><span class="line">s.intern();&#x2F;&#x2F;调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span><br><span class="line">String s2 &#x3D; &quot;1&quot;;</span><br><span class="line">System.out.println(s &#x3D;&#x3D; s2);&#x2F;&#x2F;jdk6：false   jdk7&#x2F;8：false</span><br><span class="line"></span><br><span class="line">String s3 &#x3D; new String(&quot;1&quot;) + new String(&quot;1&quot;);</span><br><span class="line">&#x2F;&#x2F;s3变量记录的地址为：new String(&quot;11&quot;)</span><br><span class="line">&#x2F;&#x2F;执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！tostring不会在字符串常量池中创建对象</span><br><span class="line">s3.intern();&#x2F;&#x2F;在字符串常量池中生成&quot;11&quot;。如何理解：</span><br><span class="line">			&#x2F;&#x2F;jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址(字符串常量池在永久代)</span><br><span class="line">			&#x2F;&#x2F;jdk7:此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址(串池在堆中)</span><br><span class="line">String s4 &#x3D; &quot;11&quot;;&#x2F;&#x2F;s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span><br><span class="line">System.out.println(s3 &#x3D;&#x3D; s4);&#x2F;&#x2F;jdk6：false  jdk7&#x2F;8：true</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>jdk6中，如果串池中有，则并不会放入，返回已有的串池中的对象的地址；如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址</p>
<p>jdk7起，如果串池中有，则并不会放入，返回已有的串池中的对象的地址；如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址(并不会返回串池的地址，返回的是对象的地址)</p>
<p>对于高频词汇使用intern()方法，可以明显降低内存的大小</p>
<h2 id="StringTable的垃圾回收"><a href="#StringTable的垃圾回收" class="headerlink" title="StringTable的垃圾回收"></a>StringTable的垃圾回收</h2><p>-XX:+PrintStringTableStatistics 打印字符串常量池中的统计信息</p>
<p>字符串常量池StringTable是存在垃圾回收的</p>
<h2 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h2><p>堆存活数据集合里面String对象占了25%</p>
<p>堆存活数据集合里面重复的String对象有13.5%</p>
<p>String对象的平均长度是45</p>
<p>堆上存在重复的String对象必然是一种内存的浪费，G1垃圾收集器可以实现自动持续对重复的String对象去重，避免浪费内存</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>A,B是重复字符串对象，那么就将A引用的对象删除，并将引用指向B的引用</p>
<p>使用一个hashtable来记录所有的被String对象使用的不重复的char数组，当去重的时候，会查这个hashtable,来看堆上是否已经存在一个一摸一样的char数组。如果存在String对象会被调整引用那个数组，释放对原来数组的引用，最终被垃圾收集器回收掉；如果查找失败，char数组会被插入到hashtable</p>
<p>UseStringDeduplication：开启String去重，默认是不开启的，需要手动开启</p>
<p>PrintStringDeduplicationStatistics：打印详细的去重统计信息</p>
<p>StringDeduplicationAgeThreshold：达到这个年龄的String对象被认为是去重的候选对象</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>垃圾收集不是Java语言的伴生产物，早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言就诞生了</p>
<h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>垃圾是指运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾</p>
<h2 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h2><p>内存溢出：不及时进行垃圾清理，垃圾对象一直保留到应用程序结束，被保留的空间无法被其他对象使用，导致空间不足的问题</p>
<p>内存泄漏：动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果</p>
<p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的大片内存分配给新的对象</p>
<h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><p>只有方法区和堆区存在垃圾回收</p>
<p>频繁收集年轻代，较少收集老年代，基本不动永久代(元空间，方法区)</p>
<h3 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h3><p>判断对象存活一般有两种方式：引用计数算法和可达性分析算法</p>
<p>引用计数器为每一个对象保存一个整形的引用计数器属性，用于记录对象被引用的情况，对象每次被引用引用计数器的值加一，引用失效则减一，当计数器值为0的时候，可进行垃圾回收</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>实现简单，垃圾对象便于辨识；判断效率高，回收没有延迟性</p>
<h4 id="确定Java使用的不是引用计数器算法"><a href="#确定Java使用的不是引用计数器算法" class="headerlink" title="确定Java使用的不是引用计数器算法"></a>确定Java使用的不是引用计数器算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class RefCountGC &#123;</span><br><span class="line">    &#x2F;&#x2F;这个成员属性唯一的作用就是占用一点内存</span><br><span class="line">    private byte[] bigSize &#x3D; new byte[5 * 1024 * 1024];&#x2F;&#x2F;5MB</span><br><span class="line">    Object reference &#x3D; null;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RefCountGC obj1 &#x3D; new RefCountGC();</span><br><span class="line">        RefCountGC obj2 &#x3D; new RefCountGC();</span><br><span class="line"></span><br><span class="line">        obj1.reference &#x3D; obj2;</span><br><span class="line">        obj2.reference &#x3D; obj1;</span><br><span class="line"></span><br><span class="line">        obj1 &#x3D; null;</span><br><span class="line">        obj2 &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;显式的执行垃圾回收行为</span><br><span class="line">        &#x2F;&#x2F;这里发生GC，obj1和obj2能否被回收？</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中存在一个循环引用，并人为的将循环引用的外部调用置为null</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/062.png"  alt="jvm"></p>
<p>如果使用的是引用计数器，那么两个RefCountGC就不会被垃圾回收，通过-XX:+PrintGCDetails指令可以查看回收细节</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>需要单独的字段存储计数器，这样的做法增加了存储空间的开销</p>
<p>每次赋值都需要更新计数器，伴随着加法和减法操作，增加了时间开销</p>
<p>引用计数器有一个严重问题，即无法处理循环引用的情况，这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/061.png"  alt="jvm"></p>
<p>循环引用内的对象可以已经不被使用了，但是由于相互引用导致引用计数器不为0，无法回收，可能会导致内存泄漏</p>
<h4 id="python使用了引用计数器，是如何解决循环引用问题的呐？"><a href="#python使用了引用计数器，是如何解决循环引用问题的呐？" class="headerlink" title="python使用了引用计数器，是如何解决循环引用问题的呐？"></a>python使用了引用计数器，是如何解决循环引用问题的呐？</h4><p>手动解除引用关系</p>
<p>使用弱引用weakref,weakref是python提供的标准库，旨在解决循环引用</p>
<h3 id="标记阶段：可达性分析算法-根搜索算法，追踪性垃圾收集"><a href="#标记阶段：可达性分析算法-根搜索算法，追踪性垃圾收集" class="headerlink" title="标记阶段：可达性分析算法(根搜索算法，追踪性垃圾收集)"></a>标记阶段：可达性分析算法(根搜索算法，追踪性垃圾收集)</h3><p>可达性分析算法可以解决循环引用问题，防止内存泄漏的发生</p>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>根集合GC Roots就是一组必须活跃的引用,是起始根</p>
<p>以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达</p>
<p>内存中存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链</p>
<p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象</p>
<p>只有能够被根对象集合直接或者间接连接的对象才是存活对象</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/063.png"  alt="jvm"></p>
<h4 id="在Java语言当中，GC-Roots包括以下几类元素"><a href="#在Java语言当中，GC-Roots包括以下几类元素" class="headerlink" title="在Java语言当中，GC Roots包括以下几类元素"></a>在Java语言当中，GC Roots包括以下几类元素</h4><ul>
<li>虚拟机栈中引用的对象，例如各个线程被调用的方法中使用到的参数，局部变量等</li>
<li>本地方法栈内JNI引用的对象</li>
<li>方法区中类静态属性引用的对象，比如Java类的引用类型静态变量</li>
<li>方法区中常量引用的对象，比如字符串常量池中的引用</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用，例如基本数据类型对象的Class对象，一些常驻的异常对象(NullPointerException,OutOfMemoryError),系统类加载器</li>
<li>反映Java虚拟机内部情况的JMXBean,JVMTI中注册的回调，本地代码缓存等</li>
<li>除了上述这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性的加入，共同构成完整GC Roots集合，比如分代收集和局部回收，如果只针对Java堆中的某一块区域进行垃圾回收，必须考虑到内存区域是虚拟自己的实现细节，不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这是就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性，总而言之，堆中的对象也可能是Root</li>
</ul>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/064.png"  alt="jvm"></p>
<p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那么它就是一个Root</p>
<p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行，这也就导致GC时必须Stop The World的一个重要原因</p>
<p>即使是号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的</p>
<h4 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h4><p>Java语言提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义逻辑处理</p>
<p>垃圾回收对象之前，总会先调用这个对象的finalize()方法</p>
<p>finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件，套接字和数据库连接等</p>
<p>永远不要主动调用某个对象的finalize()方法，调用finalize()方法可能导致对象复活，finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC,则finalize()方法将没有执行机会；一个糟糕的finalize()会严重影响GC的性能</p>
<p>如果所有的根节点都无法访问到某个对象，说明对象已经不再使用了，这个时候它们暂时处于缓刑阶段，一个无法触及的对象有可能在某一个条件下复活自己</p>
<h4 id="从finalize-的角度来看，对象有以下三种状态："><a href="#从finalize-的角度来看，对象有以下三种状态：" class="headerlink" title="从finalize()的角度来看，对象有以下三种状态："></a>从finalize()的角度来看，对象有以下三种状态：</h4><ol>
<li>可触及的：从根节点开始，可以达到这个对象</li>
<li>可复活的：对象的所有引用都被释放，但是这个对象有可能在finalize()中复活</li>
<li>不可触及的：对象的finalize()被调用，并没有复活，那么就会进行不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次</li>
</ol>
<p>只有在对象不可触及时才可以被回收</p>
<h4 id="代码复活演示"><a href="#代码复活演示" class="headerlink" title="代码复活演示"></a>代码复活演示</h4><p>finalize()方法是对象逃脱死亡的最后一次机会，且只有一次 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;此方法只能被调用一次</span><br><span class="line">@Override</span><br><span class="line">protected void finalize() throws Throwable &#123;</span><br><span class="line">   super.finalize();</span><br><span class="line">   System.out.println(&quot;调用当前类重写的finalize()方法&quot;);</span><br><span class="line">   obj &#x3D; this;&#x2F;&#x2F;当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h4><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况，MAT是基于Eclipse开发的，是一款免费的性能分析工具</p>
<p>JProfiler可以对GC Roots进行溯源，也可以查看OOM异常的原因</p>
<p>-XX:+HeapDumpOnOutOfMemoryError，当程序遇到OOM异常时，生成一个堆空间的dump文件，通过该dump文件可以查看OOM的原因和问题产生地址</p>
<h3 id="清除阶段：标记-清除算法-Mark-Sweep"><a href="#清除阶段：标记-清除算法-Mark-Sweep" class="headerlink" title="清除阶段：标记-清除算法(Mark-Sweep)"></a>清除阶段：标记-清除算法(Mark-Sweep)</h3><p>当堆中有效空间被消耗殆尽时，就会停止整个程序，然后进行两项工作，第一项时标记，第二项则是清除</p>
<p>标记：Collector从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的Header中记录为可达对象(标记的是垃圾的反面)</p>
<p>清除：Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</p>
<p>缺点：效率 不高；GC时需要停止整个应用程序；清理出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表去记录闲置空间以备调用</p>
<p>清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表中，下次由新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。即直接覆盖垃圾</p>
<h3 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收(无差别清除)</p>
<p>原理类似于s0,s1区对象的变换，survivor区的对象的特点就是朝生夕死，将复制算法用于survivor区的垃圾回收是非常理想的。老年代就不适合用复制算法了(复制算法适合于存活对象比较少的情况)</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/065.png"  alt="jvm"></p>
<p>优点：</p>
<ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现碎片问题</li>
</ul>
<p>缺点：</p>
<ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象的引用关系，不管是内存占用或者时间开销也不小</li>
<li>如果系统中的垃圾对象很少，复制算法就不太理想了。</li>
</ul>
<h3 id="清除阶段：标记-压缩-整理-算法"><a href="#清除阶段：标记-压缩-整理-算法" class="headerlink" title="清除阶段：标记-压缩(整理)算法"></a>清除阶段：标记-压缩(整理)算法</h3><p>复制算法的高效性是建立在存活对象少，垃圾对象的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象那个，所以需要采用其他算法</p>
<p>执行过程：</p>
<ol>
<li>第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有存活对象压缩到内存的一端，按顺序排放(没有复制到另外一个空间)</li>
<li>第三阶段清理边界外所有的空间</li>
</ol>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/066.png"  alt="jvm"></p>
<p>标记压缩算法相当于标记-清除算法执行完成之后，再进行一次内存碎片整理，所以也可以将它称为标记-清除-压缩算法</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>移动对象的位置，那么相应的所有引用也需要更改</p>
<table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少(会堆积碎片)</td>
<td>少(不堆积碎片)</td>
<td>存活对象的2倍大小(不堆积碎片)</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>不同对象的生命周期是不一样的，因此，不同生命周期的对象可以采用不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率</p>
<p>目前所有的GC都是采用分代收集器算法执行垃圾回收的</p>
<h4 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h4><p>区域相对老年代较小，对象生命周期短，存活率低，回收频繁</p>
<p>这种情况复制算法的回收整理速度是最快的，复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收，而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</p>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>区域较大，对象生命周期长，存活率高，回收不及年轻代频繁</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除与标记-整理的混合实现</p>
<p>Mark标记阶段的开销与存活对象的数量成正比</p>
<p>Sweep清除阶段的开销与所管理区域的大小成正比</p>
<p>Compact压缩阶段的开销与存活对象的数据成正比</p>
<h4 id="CMS回收器"><a href="#CMS回收器" class="headerlink" title="CMS回收器"></a>CMS回收器</h4><p>CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳(碎片导致的Concurrent Mode Failure时)，将采用Serial Old执行Full GC 以达到对老年代内存的整理</p>
<h3 id="增量收集算法，分区算法"><a href="#增量收集算法，分区算法" class="headerlink" title="增量收集算法，分区算法"></a>增量收集算法，分区算法</h3><h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>回收操作和程序交替执行，提高用户体验，降低延时</p>
<p>如果一次性将所有垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和程序线程交替执行，每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，知道垃圾收集完成</p>
<p>增量收集算法的基础仍然是传统的标记-清除和复制算法，增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记，清理或复制工作</p>
<p>缺点：减少了系统的停顿时间，但是因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降</p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>相同条件下，堆空间越大，一次GC时所需的时间就越长，有关GC产生的停顿就越长，为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区，而不是整个堆空间，从而减少一次GC所产生的停顿</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小空间，每一个小区间都独立使用，独立回收，这种算法的好处是可以控制一次回收多少个小区间</p>
<p>以上都是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼容</p>
<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="Sysem-gc-的理解"><a href="#Sysem-gc-的理解" class="headerlink" title="Sysem.gc()的理解"></a>Sysem.gc()的理解</h2><p>默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显示触发Full GC，同时对老年代，新生代，方法区进行回收，尝试释放被丢弃对象占用的内存</p>
<p>System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用，即不能确保立即进行垃圾回收</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;调用main方法，如果没有执行finalize()说明目前还没有进行垃圾回收</span><br><span class="line">public class SystemGCTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new SystemGCTest();</span><br><span class="line">        System.gc();&#x2F;&#x2F;提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span><br><span class="line">        &#x2F;&#x2F;与Runtime.getRuntime().gc();的作用一样。</span><br><span class="line"></span><br><span class="line">        System.runFinalization();&#x2F;&#x2F;强制调用失去引用的对象的finalize()方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(&quot;SystemGCTest 重写了finalize()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>没有空闲内存的情况：</p>
<ul>
<li>Java虚拟机的堆内存设置不够</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾器收集(存在被引用)</li>
</ul>
<p>在报内存溢出异常之前会进行一次独占式的Full GC操作，如果还是没有空闲内存，那么才会报OOM异常</p>
<p>内存溢出之前也可能不进行垃圾回收，比如说，当我么去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾回收也不能解决这个问题，所以直接抛出OOM</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收它们的情况，才能叫做内存泄漏</p>
<p>这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小</p>
<p>很多时候一些不太好的实践或疏忽会导致对象的生命周期变得很长(还有可能被调用)甚至导致OOM,也可以叫做宽泛意义上的内存泄漏。例如：</p>
<ul>
<li>局部变量声明为全局变量甚至是静态static变量，会大大延长该对象的生命周期，进而导致OOM异常</li>
<li>一个引用忘记关闭导致大量垃圾对象无法被回收</li>
</ul>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/067.png"  alt="jvm"></p>
<ol>
<li>单例模式，单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，会导致内存泄漏产生</li>
<li>一些提供clone的资源未关闭导致内存泄漏，例如数据库连接，网络连接socket,io连接必须手动close，否则是不能被回收的</li>
</ol>
<h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>GC事件发生过程中，会产生应用程序的停顿，停顿产生时整个应用程序线程都会被暂停，没有任何响应，这个停顿称为STW</p>
<p>可达性分析算法中枚举根节点会导致STW</p>
<p>所有的垃圾回收器都有STW,优秀的回收器只能减小STW的时间</p>
<h2 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>并发：是指在一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行，只是cpu把一个时间段划分成几个时间片段，然后在这几个时间区间来回切换，由于cpu处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时进行</p>
<p>并行：当系统有一个以上cpu时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行。其实决定并行的因素不是CPU的数量，而是CPU核心的数量，比如一个CPU多个核也可以并行。并行适合若交互场景</p>
<h3 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>并行：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态</p>
<p>串行：单线程执行，如果内存不够，启动JVM垃圾回收器进行垃圾回收，回收完，再启动程序线程</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/068.png"  alt="jvm"></p>
<p>并发：指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾回收线程在执行时不会停顿用户程序的运行</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/069.png"  alt="jvm"></p>
<h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始GC,只有在特定的位置才能停顿下来开始GC,这些位置称为安全点</p>
<p>安全点的选择非常重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题，大部分指令的执行时间都是非常短暂，通常会根据是否具有让程序长时间执行的特征为标准，比如：选择一些执行时间较长的指令作为安全点，如方法调用，循环跳转和异常跳转等</p>
<h4 id="如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来了呐？"><a href="#如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来了呐？" class="headerlink" title="如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来了呐？"></a>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来了呐？</h4><p>抢先式中断(目前没有虚拟机采用了)：首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点</p>
<p>主动式中断：设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起</p>
<h3 id="安全区"><a href="#安全区" class="headerlink" title="安全区"></a>安全区</h3><p>安全点机制保证了程序执行时，在不太长的时间内就遇到可进入GC的安全点，但是程序不执行的时候呐？例如线程处于sleep状态或blocked状态，这时候线程无法响应JVM的中断请求，走到安全点去中断挂起，JVM也不太可能等待线程被唤醒，对于这种情况，就需要安全区域来解决</p>
<p>安全区域是指在一段代码中，对象的引用关系不会发生大的变化，在这个区域中的任何位置开始GC都是安全的，我们也可以把安全区域看作是被扩展了的安全点</p>
<p>当线程运行到安全区的代码时，首先标记已经进入了安全区，如果这段时间发生GC，JVM会忽略标识为安全区的线程</p>
<p>当线程即将离开安全区时，会检查jvm是否已经完成GC，如果完成了，则接着运行，否则线程必须等待直到收到可以安全离开安全区的信号为止</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>我们希望能够描述这样一类对象：当内存空间还足够时，则能保存在内存总，如果内存空间在进行垃圾收集之后还是很紧张，则可以抛弃这些对象</p>
<p>jdk1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用4种，这4种引用强度依次逐渐减弱</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/070.png"  alt="jvm"></p>
<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>是指在程序代码之中普遍存在的的引用赋值，即Object object = new Object()这种引用关系，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是用来描述一些还有用，但是非比虚的对象，在系统将要发生内存溢出之前，将会把这些对象列入回收范围之内进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常</p>
<p>软引用通常用来实现内存敏感的内存，比如：高速缓存就有用到软引用，如果还有空闲空间就暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存</p>
<p>Java虚拟机会尽可能地让软引用存活时间长一点，迫不得已才清理</p>
<p>软引用的方法:必须将强引用销毁</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/071.png"  alt="jvm"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;User&gt; userSoftRef &#x3D; new SoftReference&lt;User&gt;(new User());</span><br><span class="line">&#x2F;&#x2F;获取软引用的可达对象</span><br><span class="line">userSoftRef.get()</span><br></pre></td></tr></table></figure>

<p>不一定是一定要报OOM异常才会回收软引用，只要虚拟机觉得内存紧张了，就会回收弱引用</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>被弱引用关联的对象只能生存到下一次垃圾收集之前，当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象,发现即回收</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;User&gt; userSoftRef &#x3D; new WeakReference&lt;User&gt;(new User());</span><br></pre></td></tr></table></figure>

<p>由于垃圾回收器的线程通常优先级非常低，因此，并不一定能很快地发现持有弱引用的对象，在这种情况下，弱引用对象可以存在较长的时间</p>
<p>WeakHashMap就是通过弱引用实现的，该容器中的对象不再被引用之后，就会被垃圾收集器回收</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</p>
<p>不能单独使用，也无法通过虚引用来获取被引用的对象，当试图通过虚引用的get()方法取得对象时，总是null</p>
<p>虚引用必须和引用队列一起使用，虚引用在创建时必须提供一个引用队列作为参数，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况</p>
<p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/072.png"  alt="jvm"></p>
<h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><p>无需手动编码，其内部配合引用引用队列使用，用以实现对象的finalize()方法，在GC时，终结器引用入队没有Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象</p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p>Java不同版本的新特性</p>
<p>语法层面：Lambda表达式，switch,自动装箱，自动拆箱，enum等等</p>
<p>API层面：Stream API，新的日期时间，Optional,String，集合框架</p>
<p>底层优化：JVM的优化，GC的变化，元空间，静态域，字符串常量池等</p>
<h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a>按线程数分</h4><p>可以分为串行垃圾回收(Serial)和并行垃圾回收器(Parallel)</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/073.png"  alt="jvm"></p>
<p>串行回收指的是在同一时间段只允许一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直到垃圾收集工作结束</p>
<p>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM</p>
<p>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</p>
<p>与串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用STW机制</p>
<h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><p>可以分为并发式垃圾回收和独占式垃圾回收器</p>
<p>并发式垃圾回收器与应用程序交替工作，以尽可能减少应用程序的停顿时间</p>
<p>独占式垃圾回收器(STW)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</p>
<h4 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h4><p>可以分为压缩式垃圾回收器和非压缩垃圾回收器</p>
<p>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片</p>
<p>非压缩式的垃圾回收器不进行这步操作</p>
<h4 id="按工作的内存区间分"><a href="#按工作的内存区间分" class="headerlink" title="按工作的内存区间分"></a>按工作的内存区间分</h4><p>可分为年轻代垃圾回收器和老年代垃圾回收器</p>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul>
<li>吞吐量：运行用户代码的时间占总运行时间的比例</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li>
<li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率</li>
<li>内存占用：Java堆区所占的内存大小</li>
<li>快速：一个对象从诞生到被回收所经历的时间</li>
</ul>
<h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><p>吞吐量=运行用户代码的时间/(运行用户代码时间+垃圾收集时间)，例如，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那么吞吐量就是99%</p>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
<h5 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h5><p>暂停时间是指一个时间段内应用程序线程暂停，让GC线程执行的状态，例如，GC期间100毫秒的暂停时间内没有应用程序是活动的</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/074.png"  alt="jvm"></p>
<p>GC中吞吐量和暂停时间是相悖的，只能二者选其一或者尝试找到一个二者的折中，现在的标准是在最大吞吐量优先的情况下，降低停顿时间</p>
<h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p>垃圾收集机制：Garbage Collection</p>
<p>垃圾收集器：Garbage Collector</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/075.png"  alt="jvm"></p>
<p>串行回收器：Serial,Serial Old</p>
<p>并行回收器：ParNew,Parallel Scavenge,Parallel Pld</p>
<p>并发回收器：CMS,G1</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/076.png"  alt="jvm"></p>
<h3 id="垃圾回收器的组合关系"><a href="#垃圾回收器的组合关系" class="headerlink" title="垃圾回收器的组合关系"></a>垃圾回收器的组合关系</h3><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/077.png"  alt="jvm"></p>
<p>新生代收集器：Serial,ParNew,Parallel Scavenge</p>
<p>老年代收集器：Serial Old,Parallel Old,CMS</p>
<p>整堆收集器：G1</p>
<p>在JVM是用GC的时候，需要老年代垃圾回收器和新生代垃圾回收器搭配使用</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/078.png"  alt="jvm"> </p>
<p> 红色虚线表示关系移除，绿色虚线表示关系弃用，黑线表示存在组合关系</p>
<h3 id="如何查看默认的垃圾收集器"><a href="#如何查看默认的垃圾收集器" class="headerlink" title="如何查看默认的垃圾收集器"></a>如何查看默认的垃圾收集器</h3><p>-XX:+PrintCommandLineFlags:查看命令行相关参数(包含使用的垃圾收集器)</p>
<p>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</p>
<h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><p>Serial收集器是最基本，历史最悠久的垃圾收集器，jdk1.3之前回收新生代唯一的选择</p>
<p>Serial收集器最为HotSpot中Client模式下的默认新生代垃圾收集器</p>
<p>Serial收集器采用复制算法，串行回收和STW机制的方式执行内存回收</p>
<p>除了年轻代以外，Serial收集器还提供用于执行老年代垃圾收集器的Serial Old收集器，Serial Old收集器同样也采用了串行回收和STW机制，只不过内存回收算法使用的是标记-压缩算法</p>
<p>Serial Old是运行在Client模式下默认的老年代的垃圾回收器</p>
<p>Serial Old在Server模式下主要有两个用途：与新生代的Parallel Scavenge配合使用；作为老年代CMS收集器的后备垃圾收集方案</p>
<p>在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器，即新生代用Serial GC，且老年代用Serial Old GC</p>
<p>现在的回收器已经不用串行的了，而且在限定单核cpu中才可以使用，对于交互较强的应用而言，是不能接受的，一般在Java web应用程序中是不会采用串行垃圾收集器的</p>
<h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本</p>
<p>Par是Parallel的缩写，New表示处理的是新生代</p>
<p>ParNew收集器除了采用并行回收的方式执行内存回收外，与Serial GC之间几乎没有任何区别，ParNew在年轻代中同样也是采用复制算法，STW机制</p>
<p>ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器</p>
<p>ParNew在多CPU的环境下，可以更快地完成垃圾收集，提升程序的吞吐量，但在单个CPU的环境下，ParNew收集器并不比Serial收集器更高，Serial在单CPU的环境下可以有效避免多线程交互过程中产生的一些额外开销</p>
<p>通过-XX:+UseParNewGC手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代</p>
<p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数</p>
<h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样采用复制算法，并行回收和STW机制</p>
<p>那么Parallel的作用是什么？</p>
<ul>
<li><p>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，它也被称为吞吐量优先的垃圾收集器</p>
</li>
<li><p>自适应调节策略也是Parallel Scavenge与ParNew的一个重要区别</p>
</li>
</ul>
<p>不与用户交互可以追求高吞吐量，与用户交互需要追求低延时</p>
<p>Parallel收集器在jdk1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器</p>
<p>Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和STW机制</p>
<p>在jdk8中，默认时Parallel垃圾回收器。</p>
<p>在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错</p>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p>默认jdk8是开启的，默认开启一个，另一个也会被开启</p>
<ul>
<li><p>-XX:+UseParallelGC指定年轻代使用Parallel并行收集器执行内存回收任务</p>
</li>
<li><p>-XX:+UseParallelOldGC指定老年代使用Parallel收集器</p>
</li>
</ul>
<p>-XX:+ParallelGCThreads设置年轻代并行收集器的线程数</p>
<ul>
<li><p>默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量</p>
</li>
<li><p>当CPU数量大于8个，ParallelGCThreads的值等于3+(5*CPU_Count)/8)</p>
</li>
</ul>
<p>-XX:+UseSerialGC:表明新生代使用Serial GC ，同时老年代使用Serial Old GC</p>
<p>-XX:+UseParNewGC：标明新生代使用ParNew GC</p>
<p>-XX:MaxGCPauseMillis设置垃圾收集器最大停顿时间(STW)</p>
<ul>
<li><p>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数</p>
</li>
<li><p>该参数谨慎使用</p>
</li>
</ul>
<p>-XX:GCTimeRatio 垃圾收集时间占总时间的比例( = 1/(N+1))</p>
<ul>
<li><p>用于衡量吞吐量的大小</p>
</li>
<li><p>N的取值范围(0,100)</p>
</li>
<li><p>N默认值是99，也就是垃圾回收时间不超过1%</p>
</li>
</ul>
<p>-XX:+UseAdaptiveSizePolicy设置Parallel Scavenge收集器具有自适应调节策略</p>
<ul>
<li><p>年轻代的大小，Eden和Survivor的比例，晋升老年代的对象年龄等参数都会自动调整，已达到在堆大小，吞吐量和停顿时间之间的平衡点</p>
</li>
<li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆，目标的吞吐量和停顿时间，让虚拟机自己完成调优工作</p>
</li>
<li><p>默认是开启状态</p>
</li>
</ul>
<h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>jdk1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器CMS(Concurrent-Mark-Sweep)收集器，第一次实现了让垃圾收集线程与用户线程同时工作 </p>
<p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，停顿时间越短就越适合与用户交互的程序</p>
<p>CMS的垃圾收集算法采用标记-清除算法，并且也会STW</p>
<p>CMS作为老年代收集器，无法与新生代收集器Parallel Scavenge配合工作，只能选择ParNew或者Serial收集器中的一个</p>
<p>G1出现之前，CMS使用还是非常广泛的</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/079.png"  alt="jvm"> </p>
<h4 id="初始标记阶段-Initial-Mark"><a href="#初始标记阶段-Initial-Mark" class="headerlink" title="初始标记阶段(Initial-Mark)"></a>初始标记阶段(Initial-Mark)</h4><p>程序中所有的线程都会STW,这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象，标记完成之后会恢复之前被暂停的所有应用线程。由于直接关联对象较小，所以这里的速度非常快</p>
<h4 id="并发标记阶段-Concurrent-Mark"><a href="#并发标记阶段-Concurrent-Mark" class="headerlink" title="并发标记阶段(Concurrent-Mark)"></a>并发标记阶段(Concurrent-Mark)</h4><p>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</p>
<h4 id="重新标记阶段-Remark"><a href="#重新标记阶段-Remark" class="headerlink" title="重新标记阶段(Remark)"></a>重新标记阶段(Remark)</h4><p>由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序运作而导致标记产生变动的那一部分的标记记录，这个阶段的停顿时间通常会比初始阶段标记阶段稍长一些，但也远比并发标记阶段的时间短</p>
<h4 id="并发清除阶段-Concurrent-Sweep"><a href="#并发清除阶段-Concurrent-Sweep" class="headerlink" title="并发清除阶段(Concurrent-Sweep)"></a>并发清除阶段(Concurrent-Sweep)</h4><p>此阶段清理删除标记阶段的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>
<h3 id="特点与弊端分析"><a href="#特点与弊端分析" class="headerlink" title="特点与弊端分析"></a>特点与弊端分析</h3><p>初始化标记和再次标记这两个阶段仍然需要执行STW机制暂停程序中的工作线程，不过暂停时间不会太长。目前没有垃圾收集器能够办到完全不需要STW</p>
<p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</p>
<p>由于垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎被填满了再进行收集，而是当堆内存使用率达到了某一阈值时，便开始进行回收，以确保应用程序再CMS工作工程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的空间无法满足程序需要，就会出现一次Concurrent Mode Failure失败，这时就要启动虚拟机的备用方案了，临时启动Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了</p>
<p>CMS收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞技术，而只能够选择空闲列表执行内存分配</p>
<h4 id="为什么不使用压缩算法？"><a href="#为什么不使用压缩算法？" class="headerlink" title="为什么不使用压缩算法？"></a>为什么不使用压缩算法？</h4><p>因为并发清除的时候，用压缩整理内存的话，引用就会出错。压缩算法更适合STW这种场景下使用</p>
<h4 id="CMS的优点"><a href="#CMS的优点" class="headerlink" title="CMS的优点"></a>CMS的优点</h4><p>并发收集，低延迟</p>
<h4 id="CMS的缺点"><a href="#CMS的缺点" class="headerlink" title="CMS的缺点"></a>CMS的缺点</h4><p>会产生碎片，导致并发清除后，用户线程可用的空间不足，在无法分配大对象的情况下，不得不提前触发full GC</p>
<p>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低</p>
<p>CMS收集器无法处理浮动垃圾。可能出现Concurrent Mode Failure导致另一次Full GC的产生。在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些从前未被回收的内存空间</p>
<h4 id="CMS收集器可以设置的参数"><a href="#CMS收集器可以设置的参数" class="headerlink" title="CMS收集器可以设置的参数"></a>CMS收集器可以设置的参数</h4><p>-XX:+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务</p>
<ul>
<li>开启该参数后会自动将-XX:+UseParNewGC打开。即ParNew+CMS+Serial Old的组合</li>
</ul>
<p>-XX:CMSInitiatingOccupanyFraction设置堆内存使用的阈值，一旦达到该阈值，便开始回收</p>
<p>jdk5及以前版本当老年代空间使用率达到68%时，会执行一次CMS回收，JDK6及以上版本默认值是92%</p>
<ul>
<li>如果内存正常缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善程序性能，反之，如果应用程序内存使用率增长很快，则应该减少这个阈值，以避免频繁触发老年代串行收集器，因此通过该选项便可以有效降低Full GC的执行次数</li>
</ul>
<p>-XX:+UseCMSCompactATFullection用于指定在执行完Full GC后堆内存空间进行压缩整理，以此来避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了</p>
<p>-XX:CMSFullGCsBeforeCompaction设置在执行多少次Full GC后堆内存空间进行压缩整理</p>
<p>-XX:ParallelCMSThreads设置CMS线程数量</p>
<p>CMS默认启动的线程数是(ParallelGCThreads+3)/4</p>
<p>ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕</p>
<h4 id="CMS小结"><a href="#CMS小结" class="headerlink" title="CMS小结"></a>CMS小结</h4><ul>
<li>最小化地使用内存和并行开销，用Serial GC</li>
<li>最大化应用程序的吞吐量，用Parallel GC</li>
<li>最小化GC的中断或停顿时间，用CMS GC</li>
</ul>
<p>CMS在jdk14中已经被删除了</p>
<h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><p>G1是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征</p>
<p>CMS在JDK9中被标记为废库，但在JDK8中G1还不是默认的垃圾收集器，需要使用-XX:+UseG1GC来启用</p>
<h3 id="为什么要发布G1"><a href="#为什么要发布G1" class="headerlink" title="为什么要发布G1"></a>为什么要发布G1</h3><p>随着应用程序所应对的业务越来越庞大，复杂，用户越来越多，没有GC就不能保证应用程序正常运行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化，G1(Garbage-First)垃圾回收器实在Java7 update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一</p>
<p>为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量</p>
<p>官方给G1的设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起全功能收集器的重任与期望</p>
<p>为什么名字叫做Garbage First呐？</p>
<p>因此G1是一个并行回收器，它把堆内存分割为很多不相关的区域(物理上不连续的)。使用不同的Region来表示Eden,s0,s1，老年代等</p>
<p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region</p>
<p>由于这种方式的侧重点在于回收垃圾最大量的区间(Region),所以给G1一个名字:垃圾优先(Garbage First)</p>
<h3 id="G1的优势"><a href="#G1的优势" class="headerlink" title="G1的优势"></a>G1的优势</h3><h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力</p>
<p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p>
<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>从分代上看，G1仍然属于分代型垃圾收集器，它会区分年轻代和老年代，年轻代代依然有eden区和Survivor区，但从堆结构上看，它不要求整个Eden区，年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/080.png"  alt="jvm"> </p>
<p>将堆空间分为若干个区域Region，这些区域中包含了逻辑上的年轻代和老年代</p>
<p>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，要么工作在年轻代，要么工作在老年代</p>
<h4 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h4><p>CMS:标记-清除算法，内存碎片，若干次GC后进行一次碎片整理</p>
<p>G1将内存划分为一个个的region,内存的回收是以region作为基本单位的。region之间是复制算法，但整体上实际可看做是标记-压缩算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC,尤其是当Java堆非常大的时候，G1的优势更加明显</p>
<h4 id="可预测的停顿时间"><a href="#可预测的停顿时间" class="headerlink" title="可预测的停顿时间"></a>可预测的停顿时间</h4><ul>
<li>G1除了追求低停顿以外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不多超过N毫秒</li>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制</li>
<li>G1跟踪各个region里面的垃圾堆积的价值大小(回收所获得得空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region,保证G1收集器在有限的时间内可以获取尽可能高的收集效率</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多</li>
<li>小内存应用上CMS的表现大概率优于G1，而G1在大内存应用上则发挥其优势，平衡点在6-8GB之间</li>
</ul>
<h3 id="G1回收器的参数设置"><a href="#G1回收器的参数设置" class="headerlink" title="G1回收器的参数设置"></a>G1回收器的参数设置</h3><p>-XX:+UseG1GC手动指定使用G1收集器执行内存回收任务</p>
<p>-XX:+G1HeaoRegionSize设置每个region的大小，只是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048各区域，默认是堆内存的1/2000</p>
<p>-XX:+MaxGCPauseMillis设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)，默认是200ms</p>
<p>-XX:+ParallelGCThread设置并发STW工作线程数的值，最多设置为8</p>
<p>-XX:+ConGCThreads设置并发标记的线程数，将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右</p>
<p>-XX:+InitiatingHeapOccupancyPercent设置触发并GC周期的Java堆占用率阈值，超过此值，就触发GC,默认值是45</p>
<p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ol>
<li>开启G1垃圾收集器</li>
<li>设置堆的最大内存</li>
<li>设置最大停顿时间</li>
</ol>
<p>G1中提供了三种垃圾收集模式：YongGC,Mixed GC和Full GC，在不同的情况下被触发</p>
<h3 id="G1回收器的适用场景"><a href="#G1回收器的适用场景" class="headerlink" title="G1回收器的适用场景"></a>G1回收器的适用场景</h3><p>面向服务端应用，针对具有大内存，多处理器的机器(在普通大小的堆里表现并不惊喜)</p>
<p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方法，如在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒(G1通过每次只清理一部分而不是全部的的增量式清理来保证每次GC停顿时间不会太长)</p>
<p>用来替换掉JDK1.5中的CMS收集器</p>
<p>在下面的情况下，适用G1可能比CMS好</p>
<ul>
<li><p>超过50%的Java堆被活动数据占用</p>
</li>
<li><p>对象分配频率或年代提升频率变化很大</p>
</li>
<li><p>GC停顿时间过长(长于0.5只1秒)</p>
</li>
</ul>
<p>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程</p>
<h3 id="region-化整为零"><a href="#region-化整为零" class="headerlink" title="region:化整为零"></a>region:化整为零</h3><p>可以通过-XX:G1HeapRegionSize设置Region的大小，所有的region的大小相同，且在JVM生命周期内不会被改变</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离了，它们都是一部分region(不需要连续)的集合。通过region的动态分配方式实现逻辑上的连续</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/080.png"  alt="jvm"> </p>
<p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，主要用于存储大对象，如果超过1.5个region,就放到Humongous</p>
<p>设置H的原因：堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象，如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待</p>
<h3 id="记忆集与写屏障"><a href="#记忆集与写屏障" class="headerlink" title="记忆集与写屏障"></a>记忆集与写屏障</h3><h4 id="记忆集-Remembered-Set"><a href="#记忆集-Remembered-Set" class="headerlink" title="记忆集(Remembered Set)"></a>记忆集(Remembered Set)</h4><h5 id="存在原因"><a href="#存在原因" class="headerlink" title="存在原因"></a>存在原因</h5><p>一个region不可能是孤立的，一个region中的对象可能被其他任意region中的对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确，回收新生代也不得不同时扫描老年代，会降低GC效率</p>
<p>在其他的分代收集器中，也存在这样的问题，G1尤为突出</p>
<p>有GC Roots的对象图，不需要遍历整个堆呀？？？</p>
<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>无论是G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</p>
<ul>
<li><p>每个region都有一个对应的Remembered Set</p>
</li>
<li><p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂停中断操作(写屏障)</p>
</li>
<li><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的region(其他收集器，检查老年代对象是否引用了新生代对象)</p>
</li>
<li><p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在region对于的Remembered Set中</p>
</li>
<li><p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Ser,就可以保证不进行全局扫描，也不会有遗漏</p>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/082.png"  alt="jvm"> </p>
<h3 id="G1回收器垃圾回收过程"><a href="#G1回收器垃圾回收过程" class="headerlink" title="G1回收器垃圾回收过程"></a>G1回收器垃圾回收过程</h3><p>G1的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li><p>年轻代GC(Young GC),当年轻代的Eden区用尽时开始年轻代回收过程</p>
</li>
<li><p>老年代并发标记过程(Concurrent Marking)，当堆内存使用达到一定值(默认45%),开始老年代并发标记过程，标记完成之后立即开始混合回收过程</p>
</li>
<li><p>混合回收(Mixed GC)，G1 GC从老年代移动存活对象到空闲区间，这些空闲区间也就成为了老年代的与部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的region就可以了，同时，这个老年代region是和年轻代一起被回收的</p>
</li>
<li><p>如果需要，单线程，独占式，高强度的Full GC还是接着存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/081.png"  alt="jvm"> </p>
</li>
</ul>
<p>举例：一个web服务器，Java进程最大堆内存为4G,每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%,会开始老年代并发标记过程，标记完成后开始四到五次的混合回收</p>
<h4 id="G1回收过程一：年轻代GC"><a href="#G1回收过程一：年轻代GC" class="headerlink" title="G1回收过程一：年轻代GC"></a>G1回收过程一：年轻代GC</h4><p>Yong GC是出现在每一个环节当中的，因为发生的的频率很高</p>
<p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden区空间耗尽时，G1会启动一次年轻代垃圾回收过程</p>
<p>只有Eden满了才会触发GC,Survivor是顺带一起进行GC的，Survivor本身不会</p>
<p>年轻代垃圾回收只会回收Eden区和Survivor区</p>
<p>YGC时，首先G1停止应用程序的执行STW,G1创建回收集，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段</p>
<p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/083.png"  alt="jvm"> </p>
<h5 id="第一阶段，扫描根GC-Roots"><a href="#第一阶段，扫描根GC-Roots" class="headerlink" title="第一阶段，扫描根GC Roots"></a>第一阶段，扫描根GC Roots</h5><p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口</p>
<h5 id="第二阶段，更新RSet"><a href="#第二阶段，更新RSet" class="headerlink" title="第二阶段，更新RSet"></a>第二阶段，更新RSet</h5><p>处理dirty card queue中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代堆所在的内存分段中对象的引用</p>
<h5 id="第三阶段，处理RSet"><a href="#第三阶段，处理RSet" class="headerlink" title="第三阶段，处理RSet"></a>第三阶段，处理RSet</h5><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象</p>
<h5 id="第四阶段，复制对象"><a href="#第四阶段，复制对象" class="headerlink" title="第四阶段，复制对象"></a>第四阶段，复制对象</h5><p>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达到阈值，年龄会加一，达到阈值会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间</p>
<h5 id="第五阶段，处理引用"><a href="#第五阶段，处理引用" class="headerlink" title="第五阶段，处理引用"></a>第五阶段，处理引用</h5><p>处理Soft,Weak,Phantom,Final,JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片</p>
<h4 id="G1回收过程二：并发标记过程"><a href="#G1回收过程二：并发标记过程" class="headerlink" title="G1回收过程二：并发标记过程"></a>G1回收过程二：并发标记过程</h4><ol>
<li>初始化标记：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC</li>
<li>根区域扫描：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在yong GC之前完成</li>
<li>并发标记：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被yong gc中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域存活对象的比例)</li>
<li>再次标记：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法snapshot-at-the-beginning(STAB)</li>
<li>独占清理：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域，为下阶段做铺垫，是STW的。这个阶段并不会实际上去做垃圾的收集</li>
<li>并发清理阶段：识别并清理完全空闲的区域</li>
</ol>
<h4 id="G1回收过程三：混合回收"><a href="#G1回收过程三：混合回收" class="headerlink" title="G1回收过程三：混合回收"></a>G1回收过程三：混合回收</h4><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/084.png"  alt="jvm"> </p>
<p> 当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即MixedGC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择那些那些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC</p>
<p>并发标记结束以后，老年代中百分百为垃圾回收的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次被回收</p>
<p>混和回收的回收集包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。</p>
<p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高，越会被先回收。并且有一个阈值会决定内存分段是否被回收。-XX:G1MixedGCLiveThreshldPercent,默认为65%,意思是垃圾占内存分段比较要到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间</p>
<p>混合回收并不一定要进行8次，有一个阈值-XX:G1HeapWastePercent,默认值为10%,意思是允许整个堆内存中有10%的内存被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%,则不再进行混合回收，因为GC会花费很多的时间但是回收到的内存却很少</p>
<h4 id="G1回收可选过程四：Full-GC"><a href="#G1回收可选过程四：Full-GC" class="headerlink" title="G1回收可选过程四：Full GC"></a>G1回收可选过程四：Full GC</h4><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行，使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会非常长</p>
<p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC吗？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc,这种情况可以通过增大内存解决</p>
<h5 id="导致G1-Full-GC的原因可能有两个"><a href="#导致G1-Full-GC的原因可能有两个" class="headerlink" title="导致G1 Full GC的原因可能有两个"></a>导致G1 Full GC的原因可能有两个</h5><ul>
<li><p>Evacuation的时候没有足够的to-space来存放晋升的对象</p>
</li>
<li><p>并发处理过程完成之前空间耗尽</p>
</li>
</ul>
<h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/085.png"  alt="jvm"> </p>
<p>GC发展阶段：Serial(串行)—&gt;Parallel(并行)—&gt;CMS(并发)—&gt;G1—&gt;ZGC</p>
<h2 id="GC日志分析-1"><a href="#GC日志分析-1" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><p><img src="/" class="lazyload" data-src="/2020/07/03/jvm/086.png"  alt="jvm"> </p>
<h2 id="垃圾回收器新发展"><a href="#垃圾回收器新发展" class="headerlink" title="垃圾回收器新发展"></a>垃圾回收器新发展</h2><p>Shenandoah和ZGC都是主打低停顿时间</p>
<p>二者的目标都是在尽可能对吞吐量影响不大的情况下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</p>
<p>ZGC是一款基于region内存布局的，暂时不设分代的，使用了读屏障，染色指针和内存多重映射等技术来实现可并发的标记-压缩算法，ZGC的工作过程可以分为：并发标记-并发预备重分配-并发重分配-并发重映射等</p>
<p>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的，所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的</p>
<p>ZGC的吞吐量略优于G1，略低于paraller,但是停顿时间非常好，远远优于G1和paraller</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">李上</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/07/03/jvm/">http://yoursite.com/2020/07/03/jvm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">定不辱使命</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/08/zookeeper/"><img class="prev_cover lazyload" data-src="/img/zookeeper.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">zookeeper学习笔记</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/03/%E9%AB%98%E6%80%A7%E8%83%BDMySQL/"><img class="next_cover lazyload" data-src="/img/highmysql.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《高性能MySQL》读书笔记</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 李上</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>