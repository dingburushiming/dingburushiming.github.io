<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JUC(java.util.concurrent)学习笔记 | 定不辱使命</title><meta name="description" content="JUC(java.util.concurrent)学习笔记"><meta name="keywords" content="JUC,乐观锁,悲观锁,CAS,线程,死锁,线程同步,volatile,原子性,单例模式,读写锁,线程控制,线程通讯"><meta name="author" content="李上"><meta name="copyright" content="李上"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JUC(java.util.concurrent)学习笔记"><meta name="twitter:description" content="JUC(java.util.concurrent)学习笔记"><meta name="twitter:image" content="http://yoursite.com/img/juc.png"><meta property="og:type" content="article"><meta property="og:title" content="JUC(java.util.concurrent)学习笔记"><meta property="og:url" content="http://yoursite.com/2020/04/28/juc/"><meta property="og:site_name" content="定不辱使命"><meta property="og:description" content="JUC(java.util.concurrent)学习笔记"><meta property="og:image" content="http://yoursite.com/img/juc.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/04/28/juc/"><link rel="prev" title="《Java核心卷一》读书笔记" href="http://yoursite.com/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><link rel="next" title="Spring MVC学习笔记" href="http://yoursite.com/2020/04/28/springmvc/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发常识"><span class="toc-number">1.</span> <span class="toc-text">并发常识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并发与并行的区别"><span class="toc-number">1.1.</span> <span class="toc-text">并发与并行的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序，进程，线程之间的关系"><span class="toc-number">1.2.</span> <span class="toc-text">程序，进程，线程之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建线程的三种方式"><span class="toc-number">2.</span> <span class="toc-text">创建线程的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一种创建线程的方法"><span class="toc-number">2.1.</span> <span class="toc-text">第一种创建线程的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二种创建线程的方法（实现Runnable接口，重写run方法）"><span class="toc-number">2.2.</span> <span class="toc-text">第二种创建线程的方法（实现Runnable接口，重写run方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三种创建线程的方法（实现Callable接口，重写call方法）"><span class="toc-number">2.3.</span> <span class="toc-text">第三种创建线程的方法（实现Callable接口，重写call方法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三种创建线程方法的优劣"><span class="toc-number">3.</span> <span class="toc-text">三种创建线程方法的优劣</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程中常用的方法"><span class="toc-number">4.</span> <span class="toc-text">多线程中常用的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#join方法"><span class="toc-number">4.1.</span> <span class="toc-text">join方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep方法"><span class="toc-number">4.2.</span> <span class="toc-text">sleep方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yield线程让步方法"><span class="toc-number">4.3.</span> <span class="toc-text">yield线程让步方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步问题"><span class="toc-number">5.</span> <span class="toc-text">线程同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步方法一：添加synchronized代码块"><span class="toc-number">5.1.</span> <span class="toc-text">线程同步方法一：添加synchronized代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步方法二-添加synchronized方法"><span class="toc-number">5.2.</span> <span class="toc-text">线程同步方法二:添加synchronized方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步方法三-JUC包中的lock接口来进行上锁"><span class="toc-number">5.3.</span> <span class="toc-text">线程同步方法三:JUC包中的lock接口来进行上锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步方法四-使用局部变量实现线程同步"><span class="toc-number">5.4.</span> <span class="toc-text">线程同步方法四:使用局部变量实现线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步机制总结"><span class="toc-number">5.5.</span> <span class="toc-text">同步机制总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁顺序死锁"><span class="toc-number">6.</span> <span class="toc-text">锁顺序死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁原因一"><span class="toc-number">6.1.</span> <span class="toc-text">死锁原因一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决锁顺序死锁的方法：规范加锁顺序"><span class="toc-number">6.2.</span> <span class="toc-text">解决锁顺序死锁的方法：规范加锁顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁原因二"><span class="toc-number">6.3.</span> <span class="toc-text">死锁原因二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决办法"><span class="toc-number">6.4.</span> <span class="toc-text">解决办法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定时锁：死锁超时自动结束"><span class="toc-number">6.5.</span> <span class="toc-text">定时锁：死锁超时自动结束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile关键字和内存可见性"><span class="toc-number">7.</span> <span class="toc-text">volatile关键字和内存可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存可见性"><span class="toc-number">7.1.</span> <span class="toc-text">内存可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatitle"><span class="toc-number">7.1.1.</span> <span class="toc-text">volatitle</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized：（高开销）"><span class="toc-number">7.2.</span> <span class="toc-text">synchronized：（高开销）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子性"><span class="toc-number">7.3.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#悲观锁"><span class="toc-number">7.4.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#乐观锁"><span class="toc-number">7.5.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cas-compare-and-swap-典型的乐观锁算法-C语言实现的操作系统底层算法，效率高"><span class="toc-number">7.6.</span> <span class="toc-text">Cas(compare and swap):典型的乐观锁算法(C语言实现的操作系统底层算法，效率高)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile-cas算法解决了线程同步的问题（乐观）"><span class="toc-number">7.7.</span> <span class="toc-text">Volatile+cas算法解决了线程同步的问题（乐观）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全的集合对象"><span class="toc-number">8.</span> <span class="toc-text">线程安全的集合对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程不安全的集合对象"><span class="toc-number">9.</span> <span class="toc-text">线程不安全的集合对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将不安全的集合对象转换为安全的集合对象的方法"><span class="toc-number">10.</span> <span class="toc-text">将不安全的集合对象转换为安全的集合对象的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-使用Collection-synchronizedXXX-方法来转换"><span class="toc-number">10.1.</span> <span class="toc-text">1.使用Collection.synchronizedXXX()方法来转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-使用JUC中的同步容器类来代替不安全的集合对象"><span class="toc-number">10.2.</span> <span class="toc-text">2.使用JUC中的同步容器类来代替不安全的集合对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#countDownLatch"><span class="toc-number">11.</span> <span class="toc-text">countDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore"><span class="toc-number">12.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">13.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程之间数据的交换"><span class="toc-number">14.</span> <span class="toc-text">线程之间数据的交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全的单例模式"><span class="toc-number">15.</span> <span class="toc-text">线程安全的单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#饿汉模式"><span class="toc-number">15.1.</span> <span class="toc-text">饿汉模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒汉模式"><span class="toc-number">15.2.</span> <span class="toc-text">懒汉模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态内部类的单例"><span class="toc-number">15.3.</span> <span class="toc-text">静态内部类的单例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举单例"><span class="toc-number">15.4.</span> <span class="toc-text">枚举单例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名内部类"><span class="toc-number">15.5.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生产者与消费者问题（等待与唤醒机制）"><span class="toc-number">16.</span> <span class="toc-text">生产者与消费者问题（等待与唤醒机制）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-声明一个object类，通过object-wait-object-notify-等待唤醒线程，wait会让线程释放锁"><span class="toc-number">16.1.</span> <span class="toc-text">1.声明一个object类，通过object.wait(),object.notify()等待唤醒线程，wait会让线程释放锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-通过JUC中的lock-condition两个类来等待唤醒线程"><span class="toc-number">16.2.</span> <span class="toc-text">2.通过JUC中的lock,condition两个类来等待唤醒线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程控制的方法"><span class="toc-number">17.</span> <span class="toc-text">线程控制的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程通讯：按顺序打印ABCABCABC……"><span class="toc-number">18.</span> <span class="toc-text">线程通讯：按顺序打印ABCABCABC……</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读写锁ReadWriteLock：提供readLock-writeLock两种锁，一个是读锁，一个是写锁"><span class="toc-number">19.</span> <span class="toc-text">读写锁ReadWriteLock：提供readLock,writeLock两种锁，一个是读锁，一个是写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#朵多线程中的函数式lambda编程"><span class="toc-number">20.</span> <span class="toc-text">朵多线程中的函数式lambda编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无参lambda"><span class="toc-number">20.1.</span> <span class="toc-text">无参lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有参lambda"><span class="toc-number">20.2.</span> <span class="toc-text">有参lambda</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/juc.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">定不辱使命</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">JUC(java.util.concurrent)学习笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-28 22:22:51"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-07 09:54:08"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-07</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="并发常识"><a href="#并发常识" class="headerlink" title="并发常识"></a>并发常识</h2><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><p>并行：在同一时刻，多条指令在多个处理器上同时进行</p>
<p>并发：一个时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得宏观上具有多个线程同时执行的效果，在没有引入线程前，进程的并发调度，需要操作系统调度算法运行，效率很低。线程没有算法调度这一步，效率更高</p>
<h3 id="程序，进程，线程之间的关系"><a href="#程序，进程，线程之间的关系" class="headerlink" title="程序，进程，线程之间的关系"></a>程序，进程，线程之间的关系</h3><p>1.进程和程序的关系犹如演出和剧本的关系</p>
<p>2.进程从操作系统获取内存空间，所有的线程共享着这一内存空间（每个线程都会有自己私有的内存地址范围，其他线程不能访问）</p>
<p>3.由于线程之间共享内存空间，所以通过共享进程级全局变量就可以实现线程之间的通讯</p>
<h2 id="创建线程的三种方式"><a href="#创建线程的三种方式" class="headerlink" title="创建线程的三种方式"></a>创建线程的三种方式</h2><h3 id="第一种创建线程的方法"><a href="#第一种创建线程的方法" class="headerlink" title="第一种创建线程的方法"></a>第一种创建线程的方法</h3><p>主函数也是JVM的线程，所有的线程都是在抢JVM的运行地址的权限（直接继承Thread类，重写run方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class FirstThread &#123;</span><br><span class="line">  public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">​    for(int i &#x3D;0;i &lt; 10;i++)&#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">​      if(i &#x3D;&#x3D; 1)&#123;</span><br><span class="line">​        new MyThread().start();</span><br><span class="line">​        new MyThread().start();</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">​     for(int i &#x3D;0;i &lt; 10;i++)&#123;</span><br><span class="line">​       System.out.println(this.getName() + i);  &#x2F;&#x2F;只有继承了Thread的类中才可以直接使用this代表线程，实现接口Runnable的不可以，主函数也不可以</span><br><span class="line">​     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第二种创建线程的方法（实现Runnable接口，重写run方法）"><a href="#第二种创建线程的方法（实现Runnable接口，重写run方法）" class="headerlink" title="第二种创建线程的方法（实现Runnable接口，重写run方法）"></a>第二种创建线程的方法（实现Runnable接口，重写run方法）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableThread &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    MyThread myThread &#x3D; new MyThread();     &#x2F;&#x2F;多个线程共用同一个MyThread对象</span><br><span class="line">​    for(int i &#x3D;0;i &lt; 10;i++)&#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">​      if(i &#x3D;&#x3D; 1)&#123;</span><br><span class="line">​        new Thread(myThread,&quot;thread1&quot;).start();</span><br><span class="line">​        new Thread(myThread,&quot;thread2&quot;).start();</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    for(int i &#x3D;0;i &lt; 10;i++)&#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第三种创建线程的方法（实现Callable接口，重写call方法）"><a href="#第三种创建线程的方法（实现Callable接口，重写call方法）" class="headerlink" title="第三种创建线程的方法（实现Callable接口，重写call方法）"></a>第三种创建线程的方法（实现Callable接口，重写call方法）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CallableThread &#123;</span><br><span class="line">  public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">​    ThirdThread thirdThread &#x3D; new ThirdThread();</span><br><span class="line">​    FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(thirdThread);</span><br><span class="line">​    for(int i &#x3D;0;i &lt; 10;i++)&#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">​      if(i &#x3D;&#x3D; 1)&#123;</span><br><span class="line">​        new Thread(futureTask,&quot;子线程1&quot;).start();  &#x2F;&#x2F;一个线程只能对应一个FutureTask对象，不能共享使用</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    System.out.println(futureTask.get());  &#x2F;&#x2F;获取ThirdThread的返回值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThirdThread implements Callable&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public Object call() throws Exception &#123;</span><br><span class="line">​    int i &#x3D; 1;</span><br><span class="line">​    for(;i &lt; 10;i++)&#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">​    &#125;</span><br><span class="line">​    return i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三种创建线程方法的优劣"><a href="#三种创建线程方法的优劣" class="headerlink" title="三种创建线程方法的优劣"></a>三种创建线程方法的优劣</h2><p>1.Runnable接口创建线程可以共用一个target对象，非常适合多个相同线程共同处理同一个资源的情况</p>
<p>2.继承Thread类创建线程可以直接用this指代当前线程，其余两种接口创建线程的方法都必须使用Thread.currentThread()来获取当前线程</p>
<p>3.多数情况下优先考虑Runnable接口创建线程</p>
<p>4.两类方法创建线程对象时，继承Thread想要声明线程名，需要定义构造函数，实现接口Runnable则可以直接声明</p>
<h2 id="多线程中常用的方法"><a href="#多线程中常用的方法" class="headerlink" title="多线程中常用的方法"></a>多线程中常用的方法</h2><h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>让父线程等待子线程结束了才接着执行，由并发执行变成串行执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName());</span><br><span class="line">​        Thread t1 &#x3D; new MyThread1();</span><br><span class="line">​        t1.start();</span><br><span class="line">​        t1.join(10);</span><br><span class="line">​      System.out.println(&quot;主线程执行结束&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>1.join(n)是可以加参数的，参数的意义是父线程等待子线程运行n毫秒后，父子两个线程由串行重新变成并发执行，抢夺cpu资源，n=0或者不写代表等待无限时间</p>
<p>2.join方法必须在start方法之后使用</p>
<p>后台线程：如果前台线程结束了，后台线程强制结束；后台线程结束了，前台线程仍然可以接着执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class FirstThread &#123;</span><br><span class="line">  public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">​      Thread t1 &#x3D; new qiantai(&quot;前台&quot;);</span><br><span class="line">​      t1.start();</span><br><span class="line">​      Thread t2 &#x3D; new houtai(&quot;后台&quot;);</span><br><span class="line">​      t2.setDaemon(true);       &#x2F;&#x2F;将线程t2设置为后台线程</span><br><span class="line">​      t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class qiantai extends Thread&#123;</span><br><span class="line">  qiantai(String name)&#123;</span><br><span class="line">​    super(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">​     for(int i &#x3D;0;i &lt; 100;i++)&#123;</span><br><span class="line">​       try &#123;</span><br><span class="line">​         Thread.sleep(5);</span><br><span class="line">​       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">​         e.printStackTrace();</span><br><span class="line">​       &#125;</span><br><span class="line">​       System.out.println(this.getName() +&quot;  &quot;+ i);</span><br><span class="line">​     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class houtai extends Thread&#123;</span><br><span class="line">  houtai(String name)&#123;</span><br><span class="line">​    super(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    for(int i &#x3D;0;i &lt; 100;i++)&#123;</span><br><span class="line">​      try &#123;</span><br><span class="line">​        Thread.sleep(10);</span><br><span class="line">​      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">​        e.printStackTrace();</span><br><span class="line">​      &#125;</span><br><span class="line">​      System.out.println(this.getName() +&quot;  &quot;+ i);</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><p>1.sleep是静态方法，使用方式为 Thread.sleep(),一般情况下放在线程的run方法中</p>
<p>2.sleep只能让当前线程沉睡，t.sleeep()沉睡的不是t线程，而是该语句当前所处的线程</p>
<p>3.使用方式还有：</p>
<p>TimeUnit.SECONDS.sleep()  </p>
<p>TimeUnit.MINUTES.sleep()</p>
<p>TimeUnit.HOURS.sleep() </p>
<p>TimeUnit.DAYS.sleep()</p>
<p>线程优先级：1-10数字越大优先级越高</p>
<p>thread.setPriority()设置优先级</p>
<p>thread.getPriority()获取优先级</p>
<h3 id="yield线程让步方法"><a href="#yield线程让步方法" class="headerlink" title="yield线程让步方法"></a>yield线程让步方法</h3><p>使用yield方法的线程释放cpu资源，进入就绪状态（不阻塞），和别的线程一同抢夺cpu资源</p>
<h2 id="线程同步问题"><a href="#线程同步问题" class="headerlink" title="线程同步问题"></a>线程同步问题</h2><p>同时满足以下两个情况时，会产生线程安全问题</p>
<p>1.多个线程在操作共享数据（加锁）</p>
<p>2.操作共享数据的代码有多条（原子性，cass算法+volatile）</p>
<p>当一个线程在执行操作共享数据的多行代码时，其他线程参与了运算，就会导致线程安全问题的产生</p>
<p>解决线程安全问题的方法：线程同步</p>
<h3 id="线程同步方法一：添加synchronized代码块"><a href="#线程同步方法一：添加synchronized代码块" class="headerlink" title="线程同步方法一：添加synchronized代码块"></a>线程同步方法一：添加synchronized代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableThread &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    MyThread mt &#x3D; new MyThread();</span><br><span class="line">​    Thread t1 &#x3D; new Thread(mt,&quot;线程1&quot;);</span><br><span class="line">​    t1.start();</span><br><span class="line">​    Thread t2 &#x3D; new Thread(mt,&quot;线程2&quot;);</span><br><span class="line">​    t2.start();</span><br><span class="line">​    Thread t3 &#x3D; new Thread(mt,&quot;线程3&quot;);</span><br><span class="line">​    t3.start();</span><br><span class="line">​    Thread t4 &#x3D; new Thread(mt,&quot;线程4&quot;);</span><br><span class="line">​    t4.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">  private int ticket &#x3D; 100;</span><br><span class="line">  Object object &#x3D; new Object();</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    while(true)&#123;</span><br><span class="line">​      synchronized (object)&#123;</span><br><span class="line">​        if(ticket &gt; 0)&#123;</span><br><span class="line">​          System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+ticket+&quot;号票&quot;);</span><br><span class="line">​          ticket--;</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程同步方法二-添加synchronized方法"><a href="#线程同步方法二-添加synchronized方法" class="headerlink" title="线程同步方法二:添加synchronized方法"></a>线程同步方法二:添加synchronized方法</h3><p>1.该方法也可以使用static修饰符 但是前者的锁对象是类对象实例，后者的锁对象是函数所在类</p>
<p>2.sleep会让线程沉睡，但是不会释放锁对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableThread &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    MyThread mt &#x3D; new MyThread();     &#x2F;&#x2F;mt是锁对象</span><br><span class="line">​    Thread t1 &#x3D; new Thread(mt,&quot;线程1&quot;);</span><br><span class="line">​    t1.start();</span><br><span class="line">​    Thread t2 &#x3D; new Thread(mt,&quot;线程2&quot;);</span><br><span class="line">​    t2.start();</span><br><span class="line">​    Thread t3 &#x3D; new Thread(mt,&quot;线程3&quot;);</span><br><span class="line">​    t3.start();</span><br><span class="line">​    Thread t4 &#x3D; new Thread(mt,&quot;线程4&quot;);</span><br><span class="line">​    t4.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;     &#x2F;&#x2F;如果使用静态修饰符static ，则MyThread是锁对象</span><br><span class="line">  private int ticket &#x3D; 100;</span><br><span class="line">  private Object object &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    while(true)&#123;</span><br><span class="line">​        this.sell();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void sell()&#123;</span><br><span class="line">​    if(ticket &gt; 0)&#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+ticket+&quot;号票&quot;);</span><br><span class="line">​      ticket--;</span><br><span class="line">​    &#125;else&#123;</span><br><span class="line">​      System.exit(0);</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程同步方法三-JUC包中的lock接口来进行上锁"><a href="#线程同步方法三-JUC包中的lock接口来进行上锁" class="headerlink" title="线程同步方法三:JUC包中的lock接口来进行上锁"></a>线程同步方法三:JUC包中的lock接口来进行上锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">  private int ticket &#x3D; 100;</span><br><span class="line">  Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    while(true)&#123;</span><br><span class="line">​      lock.lock();</span><br><span class="line">​      try&#123;</span><br><span class="line">​        if(ticket &gt; 0)&#123;</span><br><span class="line">​          System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+ticket+&quot;号票&quot;);</span><br><span class="line">​          ticket--;</span><br><span class="line">​        &#125;else&#123;</span><br><span class="line">​          System.exit(0);</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;catch (Exception e)&#123;</span><br><span class="line">​      &#125;finally &#123;</span><br><span class="line">​        lock.unlock();</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程同步方法四-使用局部变量实现线程同步"><a href="#线程同步方法四-使用局部变量实现线程同步" class="headerlink" title="线程同步方法四:使用局部变量实现线程同步"></a>线程同步方法四:使用局部变量实现线程同步</h3><p>这种方法本质上和前三种存在区别，前三种是共同售卖1同一份资源（多个线程卖100张票），指一种是所有线程售卖相同的不共享的资源（每个线程都卖100张票）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">  ThreadLocal&lt;Integer&gt; ticket &#x3D; new ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">  </span><br><span class="line">​    @Override</span><br><span class="line">​    protected Integer initialValue() &#123;</span><br><span class="line">​      return 10;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    while(true)&#123;</span><br><span class="line">​      if(ticket.get() &gt; 0)&#123;</span><br><span class="line">​        System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+ticket.get()+&quot;号票&quot;);</span><br><span class="line">​        ticket.set(ticket.get()-1);</span><br><span class="line">​      &#125;else&#123;</span><br><span class="line">​        break;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="同步机制总结"><a href="#同步机制总结" class="headerlink" title="同步机制总结"></a>同步机制总结</h3><p>1.多线程的同步，本质上是被线程加上了一层锁，得到锁的线程就执行，没有得到的就等待</p>
<p>2.以下情况JVM会释放锁</p>
<p>同步代码块执行结束，线程中遇到了break,return,线程中出现了erroe,exception，线程中调用了wait()方法</p>
<p>3.以下情况JVM不会释放锁</p>
<p>程序中调用sleep(),yield()方法,其他线程调用了该线程的suspend()方法</p>
<p>死锁：当A需要B的资源，B需要A的资源，且二者都不释放对方需要的那个资源。</p>
<p>锁顺序死锁：当两个线程所需锁冲突时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class SiSuo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    ThreadDemo td &#x3D; new ThreadDemo();</span><br><span class="line">​    new Thread(td,&quot;线程一&quot;).start();</span><br><span class="line">​    new Thread(td,&quot;线程二&quot;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreadDemo implements Runnable &#123;</span><br><span class="line">  Object suo1 &#x3D; new Object();</span><br><span class="line">  Object suo2 &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    m1();</span><br><span class="line">​    m2();</span><br><span class="line">  &#125;</span><br><span class="line">  void m1()&#123;</span><br><span class="line">​    synchronized (suo1)&#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName()+&quot;拿到了锁1,还想拿到锁2&quot;);</span><br><span class="line">​      synchronized (suo2)&#123;</span><br><span class="line">​        System.out.println(Thread.currentThread().getName()+&quot;拿到了锁1,拿到锁2&quot;);</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void m2()&#123;</span><br><span class="line">​    synchronized (suo2)&#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName()+&quot;拿到了锁2,还想拿到锁1&quot;);</span><br><span class="line">​      synchronized (suo1)&#123;</span><br><span class="line">​        System.out.println(Thread.currentThread().getName()+&quot;拿到了锁2,拿到锁1&quot;);</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="锁顺序死锁"><a href="#锁顺序死锁" class="headerlink" title="锁顺序死锁"></a>锁顺序死锁</h2><h3 id="死锁原因一"><a href="#死锁原因一" class="headerlink" title="死锁原因一"></a>死锁原因一</h3><p>当线程一要从a向b转账拿到a锁想要b锁，线程二要从b向a转账拿到b锁想要a锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class ZhuanZhang &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    Transfer ts &#x3D; new Transfer();</span><br><span class="line">​    new Thread(ts,&quot;线程一&quot;).start();</span><br><span class="line">​    new Thread(ts,&quot;线程二&quot;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Transfer implements Runnable&#123;</span><br><span class="line">  Account a &#x3D; new Account(&quot;a&quot;,1000);</span><br><span class="line">  Account b &#x3D; new Account(&quot;b&quot;,1000);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    transferMoney(a,b,100);</span><br><span class="line">​    transferMoney(b,a,100);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void transferMoney(Account fromAccount, Account toAccount,double money)&#123;</span><br><span class="line">​    synchronized (fromAccount)&#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName()+&quot;拿到转出账户锁&quot;+fromAccount.getName());</span><br><span class="line">​      synchronized (toAccount)&#123;</span><br><span class="line">​        System.out.println(Thread.currentThread().getName()+&quot;拿到转入账户锁&quot;+toAccount.getName());</span><br><span class="line">​        if(money &lt; fromAccount.getMoney())&#123;</span><br><span class="line">​          fromAccount.setMoney(fromAccount.getMoney()-money);</span><br><span class="line">​          toAccount.setMoney(toAccount.getMoney()+money);</span><br><span class="line">​          System.out.println(Thread.currentThread().getName()+&quot;转账后&quot;+fromAccount.getName()+&quot;余额为&quot;+fromAccount.getMoney());</span><br><span class="line">​          System.out.println(Thread.currentThread().getName()+&quot;转账后&quot;+toAccount.getName()+&quot;余额为&quot;+toAccount.getMoney());</span><br><span class="line">​        &#125;else &#123;</span><br><span class="line">​          System.out.println(&quot;余额不足&quot;);</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Account&#123;</span><br><span class="line">  String name;</span><br><span class="line">  double money;</span><br><span class="line">  public Account(String name, double money) &#123;</span><br><span class="line">​    this.name &#x3D; name;</span><br><span class="line">​    this.money &#x3D; money;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getName() &#123;</span><br><span class="line">​    return name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setName(String name) &#123;</span><br><span class="line">​    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public double getMoney() &#123;</span><br><span class="line">​    return money;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setMoney(double money) &#123;</span><br><span class="line">​    this.money &#x3D; money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解决锁顺序死锁的方法：规范加锁顺序"><a href="#解决锁顺序死锁的方法：规范加锁顺序" class="headerlink" title="解决锁顺序死锁的方法：规范加锁顺序"></a>解决锁顺序死锁的方法：规范加锁顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class SiSuo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    ThreadDemo td &#x3D; new ThreadDemo();</span><br><span class="line">​    new Thread(td,&quot;线程一&quot;).start();</span><br><span class="line">​    new Thread(td,&quot;线程二&quot;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThreadDemo implements Runnable &#123;</span><br><span class="line">  Object suo1 &#x3D; new Object();</span><br><span class="line">  Object suo2 &#x3D; new Object();</span><br><span class="line">  Object jiasuo &#x3D; new Object();</span><br><span class="line">  int suo1HashCode &#x3D; System.identityHashCode(suo1);</span><br><span class="line">  int suo2HashCode &#x3D; System.identityHashCode(suo2);</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    m1();</span><br><span class="line">​    m2();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Demo &#123;       &#x2F;&#x2F;加上内部类，简化代码量</span><br><span class="line">​    public void takeSuo()&#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName()+&quot;拿到了锁1,还想拿到锁2&quot;);</span><br><span class="line">​      synchronized (suo2)&#123;</span><br><span class="line">​        System.out.println(Thread.currentThread().getName()+&quot;拿到了锁1,拿到锁2&quot;);</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void m1()&#123;</span><br><span class="line">​    if(suo1HashCode &gt; suo2HashCode)&#123;</span><br><span class="line">​      synchronized (suo1)&#123;</span><br><span class="line">​        new Demo().takeSuo();</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;else if(suo1HashCode &lt; suo2HashCode)&#123;</span><br><span class="line">​      synchronized (suo2)&#123;</span><br><span class="line">​        new Demo().takeSuo();</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;else&#123;</span><br><span class="line">​      synchronized (jiasuo)&#123;</span><br><span class="line">​        synchronized (suo1)&#123;</span><br><span class="line">​          new Demo().takeSuo();</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void m2()&#123;</span><br><span class="line">​    if(suo1HashCode &gt; suo2HashCode)&#123;</span><br><span class="line">​      synchronized (suo1)&#123;</span><br><span class="line">​        new Demo().takeSuo();</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;else if(suo1HashCode &lt; suo2HashCode)&#123;</span><br><span class="line">​      synchronized (suo2)&#123;</span><br><span class="line">​        new Demo().takeSuo();</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;else&#123;</span><br><span class="line">​      synchronized (jiasuo)&#123;</span><br><span class="line">​        synchronized (suo1)&#123;</span><br><span class="line">​          new Demo().takeSuo();</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="死锁原因二"><a href="#死锁原因二" class="headerlink" title="死锁原因二"></a>死锁原因二</h3><p>对象协作过程中，一个功能可能要用多把锁，在多个线程调用的过程中，极大可能导致死锁</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>开放调用避免死锁——尽量使用同步代码块，用同步代码块包裹操作共享数据的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.*;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">public class ThreadTest8 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Taxi&#123;</span><br><span class="line">  private Point location, destination;  &#x2F;&#x2F;自己所在位置，目的地</span><br><span class="line">  private Dispatcher dispatcher;</span><br><span class="line">  public Taxi(Dispatcher dispatcher) &#123;  &#x2F;&#x2F;初始化客户的位置</span><br><span class="line">​    this.dispatcher &#x3D; dispatcher;</span><br><span class="line">  &#125;</span><br><span class="line">  public synchronized Point getLocation() &#123;  &#x2F;&#x2F;获取共享数据，synchronized避免线程安全问题</span><br><span class="line">​    return location;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setLocation(Point location) &#123;    &#x2F;&#x2F;设置车辆位置</span><br><span class="line">​    boolean flag;</span><br><span class="line">​    &#x2F;&#x2F;内置锁保护的范围做了缩小</span><br><span class="line">​    synchronized (this)&#123;</span><br><span class="line">​      this.location &#x3D; location;</span><br><span class="line">​      flag &#x3D; location.equals(destination);</span><br><span class="line">​    &#125;</span><br><span class="line">​    if(flag)&#123;</span><br><span class="line">​      dispatcher.notifyAvailable(this);    &#x2F;&#x2F;满足条件将该车辆加入到调度集合里</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dispatcher&#123;</span><br><span class="line">  private final Set&lt;Taxi&gt; taxis;</span><br><span class="line">  private final Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line">  public Dispatcher() &#123;</span><br><span class="line">​    taxis &#x3D; new HashSet&lt;Taxi&gt;();</span><br><span class="line">​    availableTaxis &#x3D; new HashSet&lt;Taxi&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public synchronized void notifyAvailable(Taxi taxi) &#123;</span><br><span class="line">​    availableTaxis.add(taxi);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Image getImage() &#123;</span><br><span class="line">​    Set&lt;Taxi&gt; copy;</span><br><span class="line">​    synchronized (this)&#123;</span><br><span class="line">​      copy &#x3D; new HashSet&lt;Taxi&gt;(availableTaxis);</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    Image image &#x3D; new Image();</span><br><span class="line">​    for (Taxi t : copy) &#123;</span><br><span class="line">​      &#x2F;&#x2F; 调用getLocation()需要Taxi内置锁</span><br><span class="line">​      image.drawMarker(t.getLocation());</span><br><span class="line">​    &#125;</span><br><span class="line">​    return image;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Image &#123;</span><br><span class="line">  public void drawMarker(Point p) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="定时锁：死锁超时自动结束"><a href="#定时锁：死锁超时自动结束" class="headerlink" title="定时锁：死锁超时自动结束"></a>定时锁：死锁超时自动结束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">public class ThreadTest9 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    System.out.println(&quot;开始&quot;);</span><br><span class="line">​    Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">​    new Thread(new Runnable() &#123;</span><br><span class="line">​      @Override</span><br><span class="line">​      public void run() &#123;</span><br><span class="line">​        try &#123;</span><br><span class="line">​          if(lock.tryLock(1,TimeUnit.SECONDS))&#123;</span><br><span class="line">​            System.out.println(&quot;获取到了锁&quot;);</span><br><span class="line">​            try &#123;</span><br><span class="line">​              for (int i&#x3D;1;i&lt;6;i++)&#123;</span><br><span class="line">​                System.out.println(Thread.currentThread().getName() + &quot;--&quot; + i);</span><br><span class="line">​              &#125;</span><br><span class="line">​            &#125;catch (Exception e)&#123;</span><br><span class="line">​            &#125;finally &#123;</span><br><span class="line">​              lock.unlock();</span><br><span class="line">​            &#125;</span><br><span class="line">​          &#125;else&#123;</span><br><span class="line">​            System.out.println(&quot;没获取到锁&quot;);</span><br><span class="line">​            return;</span><br><span class="line">​          &#125;</span><br><span class="line">​        &#125; catch (Exception e) &#123;</span><br><span class="line">​          e.printStackTrace();</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;, &quot;线程1&quot;).start();</span><br><span class="line"></span><br><span class="line">​    new Thread(new Runnable() &#123;</span><br><span class="line">​      @Override</span><br><span class="line">​      public void run() &#123;</span><br><span class="line">​        try &#123;</span><br><span class="line">​          if(lock.tryLock())&#123;</span><br><span class="line">​            System.out.println(&quot;获取到了锁&quot;);</span><br><span class="line">​            try &#123;</span><br><span class="line">​              for (int i&#x3D;1;i&lt;6;i++)&#123;</span><br><span class="line">​                System.out.println(Thread.currentThread().getName() + &quot;--&quot; + i);</span><br><span class="line">​              &#125;</span><br><span class="line">​            &#125;catch (Exception e)&#123;</span><br><span class="line">​            &#125;finally &#123;</span><br><span class="line">​              lock.unlock();</span><br><span class="line">​            &#125;</span><br><span class="line">​          &#125;else&#123;</span><br><span class="line">​            System.out.println(&quot;没获取到锁&quot;);</span><br><span class="line">​            return;</span><br><span class="line">​          &#125;</span><br><span class="line">​        &#125; catch (Exception e) &#123;</span><br><span class="line">​          e.printStackTrace();</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;, &quot;线程2&quot;).start();</span><br><span class="line">​    System.out.println(&quot;结束&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="volatile关键字和内存可见性"><a href="#volatile关键字和内存可见性" class="headerlink" title="volatile关键字和内存可见性"></a>volatile关键字和内存可见性</h2><h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>线程中的共享变量都是从该变量的内存地址拷贝过来的，线程中的变量是存放在换从和寄存器中的，所以线程中的共享数据和内存中的共享地址的同步需要时间</p>
<h4 id="volatitle"><a href="#volatitle" class="headerlink" title="volatitle"></a>volatitle</h4><p>可以尽快的将线程共享数据与内存共享数据同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    VolatileThread vd &#x3D; new VolatileThread();</span><br><span class="line">​    new Thread(vd,&quot;线程一&quot;).start();</span><br><span class="line">​    while(true)&#123;</span><br><span class="line">​      if(vd.isFlag())&#123;</span><br><span class="line">​        System.out.println(&quot;falg已经设置为true&quot;);</span><br><span class="line">​        break;</span><br><span class="line">​      &#125;</span><br><span class="line">​      System.out.println(vd.isFlag());</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class VolatileThread implements Runnable&#123;</span><br><span class="line">  private volatile boolean flag &#x3D; false;</span><br><span class="line">  public boolean isFlag() &#123;</span><br><span class="line">​    return flag;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setFlag(boolean flag) &#123;</span><br><span class="line">​    this.flag &#x3D; flag;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    try &#123;</span><br><span class="line">​      this.setFlag(true);</span><br><span class="line">​    &#125; catch (Exception e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="synchronized：（高开销）"><a href="#synchronized：（高开销）" class="headerlink" title="synchronized：（高开销）"></a>synchronized：（高开销）</h3><p>JVM关于synchronized的规定：</p>
<p>1.线程解锁前，必须把共享变量的最新值刷新到主内存中</p>
<p>2.线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">synchronized(vd)&#123;</span><br><span class="line">​        if(vd.isFlag())&#123;</span><br><span class="line">​          System.out.println(&quot;falg已经设置为true&quot;);</span><br><span class="line">​          break;</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="/2020/04/28/juc/clip_image001.png"  alt="juc"></p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>1.转账过程中转出账户金额减少100，转入账户金额增加100，转账这一个操作包含了两个动作，如果前者做了后者没做就会出现问题，保证这两个操作要么都做，要么都不做的操作就是原子性</p>
<p>2.volatile只能保证内存可见性，不能保证原子性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class YuanZi &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">  YuanZiThread yzt &#x3D; new YuanZiThread();</span><br><span class="line">​    for (int i &#x3D; 0;i&lt; 10;i++)&#123;</span><br><span class="line">​      new Thread(yzt,&quot;线程&quot;+i).start();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class YuanZiThread implements Runnable&#123;</span><br><span class="line">  private volatile int number &#x3D; 0;</span><br><span class="line">  public int getNumber()&#123;</span><br><span class="line">​    return number++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​      try &#123;</span><br><span class="line">​        Thread.sleep(10);</span><br><span class="line">​      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">​        e.printStackTrace();</span><br><span class="line">​      &#125;</span><br><span class="line">​    System.out.println(Thread.currentThread().getName()+&quot;  &quot;+this.getNumber());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程在执行run方法中的自增方法过程中，由于没有原子性，别的线程开始运行，这个时候前一个线程的运算还没有结束，新的值还没有更新到内存中，就会导致两个线程打印出同样的数字</p>
<p>Java.util.concurrent.atomic包可以解决线程原子性问题（其实就是线程同步问题）</p>
<p>AtomicInteger ,AtomicBoolean ,AtomicLong ,AtomicReference</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">public class ThreadTest2 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    AtomicThread at &#x3D; new AtomicThread();</span><br><span class="line">​    for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">​      new Thread(at,&quot;线程&quot;+i).start();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AtomicThread implements Runnable&#123;</span><br><span class="line">  private AtomicInteger serialNum &#x3D; new AtomicInteger(0);</span><br><span class="line">  public int getSerialNum() &#123;</span><br><span class="line">​    return serialNum.getAndIncrement();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    try &#123;</span><br><span class="line">​      Thread.sleep(500);</span><br><span class="line">​    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line">​    System.out.println(&quot;显示serialNum完后，然它自增一：&quot; + getSerialNum());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>假设每次一次线程都会冲突，采用加锁的方式避免一起冲突可能，但synchronized，lock花销很大  </p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>假设大多数情况下线程都不会发生同步问题，采用检测冲突的方式，检测到冲突就不执行（视为失败，重新执行）花销较小</p>
<h3 id="Cas-compare-and-swap-典型的乐观锁算法-C语言实现的操作系统底层算法，效率高"><a href="#Cas-compare-and-swap-典型的乐观锁算法-C语言实现的操作系统底层算法，效率高" class="headerlink" title="Cas(compare and swap):典型的乐观锁算法(C语言实现的操作系统底层算法，效率高)"></a>Cas(compare and swap):典型的乐观锁算法(C语言实现的操作系统底层算法，效率高)</h3><p> 线程A和线程B从内存中读取数据56，同时抢夺cpu资源，A抢夺成功将内存中数据修改为57（失败的B线程不会被挂起，会接着尝试抢夺资源），当线程B抢夺到资源准备时检测到内存中的数据和自己副本中的数据56不等，B的这次操作就失败了，B会重新到内存中读取数据56，重新参与cpu资源的抢夺。（包装线程共享变量）</p>
<h3 id="Volatile-cas算法解决了线程同步的问题（乐观）"><a href="#Volatile-cas算法解决了线程同步的问题（乐观）" class="headerlink" title="Volatile+cas算法解决了线程同步的问题（乐观）"></a>Volatile+cas算法解决了线程同步的问题（乐观）</h3><h2 id="线程安全的集合对象"><a href="#线程安全的集合对象" class="headerlink" title="线程安全的集合对象"></a>线程安全的集合对象</h2><p>Vector,HashTable,StringBuffer</p>
<h2 id="线程不安全的集合对象"><a href="#线程不安全的集合对象" class="headerlink" title="线程不安全的集合对象"></a>线程不安全的集合对象</h2><p> ArrayList,LinkedList,HashMap,HashSet,TreeMap,TreeSet,StringBuilder</p>
<h2 id="将不安全的集合对象转换为安全的集合对象的方法"><a href="#将不安全的集合对象转换为安全的集合对象的方法" class="headerlink" title="将不安全的集合对象转换为安全的集合对象的方法"></a>将不安全的集合对象转换为安全的集合对象的方法</h2><h3 id="1-使用Collection-synchronizedXXX-方法来转换"><a href="#1-使用Collection-synchronizedXXX-方法来转换" class="headerlink" title="1.使用Collection.synchronizedXXX()方法来转换"></a>1.使用Collection.synchronizedXXX()方法来转换</h3><p>List<String> li = Collection.synchronizedList(new ArrayList<String>)</String></String></p>
<p>Map&lt;String,String&gt; map = Collection.synchronizedMap(new HashMap&lt;&gt;())</p>
<p>HashMap和HashTable二者都是键值对容器，可以相互装换，前者线程不安全，后者线程安全</p>
<p>这个方法程序效率低，且复合操作时（读写）会报并发修改异常ConcurrentModificationException</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Safe &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    safeThread st &#x3D; new safeThread();</span><br><span class="line">​    new Thread(st,&quot;线程1&quot;).start();</span><br><span class="line">​    new Thread(st,&quot;线程2&quot;).start();</span><br><span class="line">​    new Thread(st,&quot;线程3&quot;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class safeThread implements Runnable&#123;</span><br><span class="line">  static List&lt;String&gt; ls &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">  static &#123;</span><br><span class="line">​    ls.add(&quot;1&quot;);</span><br><span class="line">​    ls.add(&quot;2&quot;);</span><br><span class="line">​    ls.add(&quot;3&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    Iterator&lt;String&gt; it &#x3D; ls.iterator();</span><br><span class="line">​    while(it.hasNext())&#123;</span><br><span class="line">​      System.out.println(it.next());</span><br><span class="line">​      ls.add(&quot;4&quot;);</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用JUC中的同步容器类来代替不安全的集合对象"><a href="#2-使用JUC中的同步容器类来代替不安全的集合对象" class="headerlink" title="2.使用JUC中的同步容器类来代替不安全的集合对象"></a>2.使用JUC中的同步容器类来代替不安全的集合对象</h3><p>ConcurrentHashMap替代HashMap</p>
<p>ConcurrentSkipListMap替代TreeMap</p>
<p>CopyOnWriteArrayList替代 ArrayList</p>
<p>CopyOnWriteArraySet 替代ArraySet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Safe &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    safeThread st &#x3D; new safeThread();</span><br><span class="line">​    new Thread(st,&quot;线程1&quot;).start();</span><br><span class="line">​    new Thread(st,&quot;线程2&quot;).start();</span><br><span class="line">​    new Thread(st,&quot;线程3&quot;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class safeThread implements Runnable&#123;</span><br><span class="line">  static CopyOnWriteArrayList&lt;String&gt; ls &#x3D; new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">  static &#123;</span><br><span class="line">​    ls.add(&quot;1&quot;);</span><br><span class="line">​    ls.add(&quot;2&quot;);</span><br><span class="line">​    ls.add(&quot;3&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    ls.add(&quot;4&quot;);</span><br><span class="line">​    Iterator&lt;String&gt; it &#x3D; ls.iterator();</span><br><span class="line">​    while(it.hasNext())&#123;</span><br><span class="line">​      System.out.println(it.next());</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="countDownLatch"><a href="#countDownLatch" class="headerlink" title="countDownLatch"></a>countDownLatch</h2><p>这个类使一个线程等待其他线程各自执行完毕后再执行。</p>
<p>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class CDL &#123;</span><br><span class="line">  public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">​    CountDownLatch latch &#x3D; new CountDownLatch(50);</span><br><span class="line">​    CountDownLatchThread cdt &#x3D; new CountDownLatchThread(latch);</span><br><span class="line">​    for (int i &#x3D; 0;i &lt;50;i++)&#123;</span><br><span class="line">​      new Thread(cdt,&quot;线程&quot;+i).start();</span><br><span class="line">​    &#125;</span><br><span class="line">​    latch.await();</span><br><span class="line">​    System.out.println(&quot;主线程开始执行&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CountDownLatchThread implements Runnable&#123;</span><br><span class="line">  private CountDownLatch latch;</span><br><span class="line">  public CountDownLatchThread(CountDownLatch latch)&#123;</span><br><span class="line">​    this.latch &#x3D; latch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​      try &#123;</span><br><span class="line">​        for(int i &#x3D; 0;i &lt; 500;i++) &#123;</span><br><span class="line">​          if (i % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">​            System.out.println(&quot;这是线程&quot; + Thread.currentThread().getName() + &quot;的偶数&quot; + i);</span><br><span class="line">​          &#125;</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;finally &#123;</span><br><span class="line">​        latch.countDown();     </span><br><span class="line">​      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>发许可证，同时只允许固定数量的线程并发执行，许可证释放后别的线程可以获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Sep &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    Semaphore sp &#x3D; new Semaphore(5);</span><br><span class="line">​    SemaphoreThread spt &#x3D; new SemaphoreThread(sp);</span><br><span class="line">​    for (int i &#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">​      new Thread(spt,&quot;线程&quot;+i).start();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SemaphoreThread implements Runnable&#123;</span><br><span class="line">  private Semaphore semaphore;</span><br><span class="line">  public SemaphoreThread(Semaphore semaphore)&#123;</span><br><span class="line">​    this.semaphore &#x3D; semaphore;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    try &#123;</span><br><span class="line">​      semaphore.acquire();</span><br><span class="line">​      System.out.println(Thread.currentThread().getName()+&quot;获取到许可证&quot;);</span><br><span class="line">​      Thread.sleep(1000);</span><br><span class="line">​    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;finally &#123;</span><br><span class="line">​      System.out.println(Thread.currentThread().getName()+&quot;释放许可证&quot;);</span><br><span class="line">​      semaphore.release();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>可以设置集合点，所有线程都到达时统一放行（存在线程安全问题）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Cyc &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(3);   &#x2F;&#x2F;线程的数量</span><br><span class="line">​    CyclicBarrierThread1 cbt &#x3D; new CyclicBarrierThread1(cyclicBarrier);</span><br><span class="line">​    for(int i &#x3D; 1;i &lt; 4;i++)&#123;       &#x2F;&#x2F;这里的i初始值不能为0</span><br><span class="line">​      new Thread(cbt,&quot;线程&quot;+i).start();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CyclicBarrierThread1 implements Runnable&#123;</span><br><span class="line">  private CyclicBarrier cyclicBarrier;</span><br><span class="line">  public CyclicBarrierThread1(CyclicBarrier cyclicBarrier)&#123;</span><br><span class="line">​    this.cyclicBarrier &#x3D; cyclicBarrier;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    try &#123;</span><br><span class="line">​      Thread.sleep((long)(Math.random()*1000));</span><br><span class="line">​      System.out.println(Thread.currentThread().getName()+&quot;到达了景点一&quot;+&quot;,已到达的人数是&quot;+cyclicBarrier.getNumberWaiting());</span><br><span class="line">​      cyclicBarrier.await();</span><br><span class="line">​      Thread.sleep((long)(Math.random()*1000));</span><br><span class="line">​      System.out.println(Thread.currentThread().getName()+&quot;到达了景点二&quot;+&quot;,已到达的人数是&quot;+cyclicBarrier.getNumberWaiting());</span><br><span class="line">​      cyclicBarrier.await();</span><br><span class="line">​      Thread.sleep((long)(Math.random()*1000));</span><br><span class="line">​      System.out.println(Thread.currentThread().getName()+&quot;到达了景点三&quot;+&quot;,已到达的人数是&quot;+cyclicBarrier.getNumberWaiting());</span><br><span class="line">​      cyclicBarrier.await();</span><br><span class="line">​      System.out.println(&quot;大家一起回家了&quot;);</span><br><span class="line">​    &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程之间数据的交换"><a href="#线程之间数据的交换" class="headerlink" title="线程之间数据的交换"></a>线程之间数据的交换</h2><p>当第一个线程执行到exchange方法时，它会等待第二个线程执行到exchange方法，两个方法执行到同步点的时候，会交换数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line">public class Change &#123;</span><br><span class="line">  private String msg1;</span><br><span class="line">  private String msg2;</span><br><span class="line">  public void a(Exchanger&lt;String&gt; exchanger)&#123;</span><br><span class="line">​    try &#123;</span><br><span class="line">​      msg1 &#x3D; &quot;11111&quot;</span><br><span class="line">​      System.out.println(&quot;交换前的msg1:&quot;+msg1);</span><br><span class="line">​      msg1 &#x3D; exchanger.exchange(msg1);</span><br><span class="line">​      System.out.println(&quot;交换后的msg1:&quot;+msg1);</span><br><span class="line">​      Thread.sleep(1000);</span><br><span class="line">​    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void b(Exchanger&lt;String&gt; exchanger)&#123;</span><br><span class="line">​    try &#123;</span><br><span class="line">​      msg2 &#x3D; &quot;22222&quot;;</span><br><span class="line">​      System.out.println(&quot;交换前的msg2:&quot;+msg2);</span><br><span class="line">​      msg2 &#x3D; exchanger.exchange(msg2);</span><br><span class="line">​      System.out.println(&quot;交换后的msg2:&quot;+msg2);</span><br><span class="line">​      Thread.sleep(1000);</span><br><span class="line">​    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">​      e.printStackTrace();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;&#x2F;&#x2F;主函数所在类的主方法在调用类方法时必须先声明一个类</span><br><span class="line">​    Exchanger&lt;String&gt; exchanger &#x3D; new Exchanger&lt;&gt;();  &#x2F;&#x2F;两个线程使用的是同一个交换器的类</span><br><span class="line">​    Change change &#x3D; new Change();</span><br><span class="line">​    new Thread(new Runnable() &#123;</span><br><span class="line">​      @Override</span><br><span class="line">​      public void run() &#123;</span><br><span class="line">​        change.a(exchanger);</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;).start();</span><br><span class="line"></span><br><span class="line">​    new Thread(new Runnable() &#123;</span><br><span class="line">​      @Override</span><br><span class="line">​      public void run() &#123;</span><br><span class="line">​        change.b(exchanger);</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest1 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    for(int i&#x3D;0;i&lt;20;i++)&#123;</span><br><span class="line">​      new Thread(new Runnable() &#123;</span><br><span class="line">​        @Override</span><br><span class="line">​        public void run() &#123;</span><br><span class="line">​          System.out.println(Singleton4.getInstance());</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;).start();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>线程安全的，多个线程创建实例对象时，JVM只允许一个线程对实例初始化，其余全部失败，但是花销比价大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Singleton1 &#123;</span><br><span class="line">  private static Singleton1 singleton &#x3D; new Singleton1();</span><br><span class="line">  private Singleton1()&#123;&#125;</span><br><span class="line">  public static Singleton1 getInstance()&#123;</span><br><span class="line">​    return singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>非线程安全，加锁保证线程安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Singleton2&#123;</span><br><span class="line">  private volatile static Singleton2 singleton &#x3D; null;</span><br><span class="line">  private Singleton2()&#123;&#125;</span><br><span class="line">  public static Singleton2 getInstance()&#123;</span><br><span class="line">​    if(singleton &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;第一次检查，高并发，很多线程会同时到达这里</span><br><span class="line">​      synchronized (Singleton2.class)&#123; &#x2F;&#x2F;第二层保护</span><br><span class="line">​        if(singleton &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;第三层保护，配合volatile关键字</span><br><span class="line">​          singleton &#x3D; new Singleton2(); &#x2F;&#x2F;除了第一次进来的线程，其他所有线程都进不来了</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    return singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类的单例"><a href="#静态内部类的单例" class="headerlink" title="静态内部类的单例"></a>静态内部类的单例</h3><p>Singleton3被初始化时，静态内部类不会被立即加载，只有在调用SingleTonHoler.singleton时才会被初始化，既有饿汉模式保证线程安全的特性，又有懒汉减少资源使用的特性。缺点是静态内部类不能传参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Singleton3&#123;</span><br><span class="line">  private Singleton3()&#123;&#125;</span><br><span class="line">  private static class SingleTonHoler&#123;</span><br><span class="line">​    private static Singleton3 singleton &#x3D; new Singleton3();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static Singleton3 getInstance()&#123;</span><br><span class="line">​    return SingleTonHoler.singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum Singleton4&#123;</span><br><span class="line">  SINGLETON;</span><br><span class="line">  &#x2F;&#x2F;可以省略此方法，通过Singleton.INSTANCE进行操作</span><br><span class="line">  public static Singleton4 getInstance() &#123;</span><br><span class="line">​    return Singleton4.SINGLETON;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p><img src="/" class="lazyload" data-src="/2020/04/28/juc/clip_image002.png"  alt="juc"></p>
<h2 id="生产者与消费者问题（等待与唤醒机制）"><a href="#生产者与消费者问题（等待与唤醒机制）" class="headerlink" title="生产者与消费者问题（等待与唤醒机制）"></a>生产者与消费者问题（等待与唤醒机制）</h2><p>上锁，等待唤醒的方式有两个：</p>
<h3 id="1-声明一个object类，通过object-wait-object-notify-等待唤醒线程，wait会让线程释放锁"><a href="#1-声明一个object类，通过object-wait-object-notify-等待唤醒线程，wait会让线程释放锁" class="headerlink" title="1.声明一个object类，通过object.wait(),object.notify()等待唤醒线程，wait会让线程释放锁"></a>1.声明一个object类，通过object.wait(),object.notify()等待唤醒线程，wait会让线程释放锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest1 &#123;</span><br><span class="line">  &#x2F;&#x2F;运行测试的main方法</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    Object lock &#x3D; new Object(); &#x2F;&#x2F;声明的是object类来作为锁</span><br><span class="line">​    P p &#x3D; new P(lock);</span><br><span class="line">​    C c &#x3D; new C(lock);</span><br><span class="line">​    p.start();</span><br><span class="line">​    c.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个类，模拟生产者和消费者之间的缓冲区</span><br><span class="line">class ValueObject&#123;</span><br><span class="line">  public static String value &#x3D; &quot;&quot;; &#x2F;&#x2F;模拟的缓冲区    &#x2F;&#x2F;类的静态变量可以被直接调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现生产者的线程类</span><br><span class="line">class P extends Thread&#123;</span><br><span class="line">  private Object lock;</span><br><span class="line">  public P(Object lock)&#123;</span><br><span class="line">​    this.lock &#x3D; lock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    while (true)&#123;</span><br><span class="line">​      try&#123;</span><br><span class="line">​        synchronized (lock)&#123;</span><br><span class="line">​          &#x2F;&#x2F;作为生产者的基本功能，生产数据</span><br><span class="line">​          if(!ValueObject.value.equals(&quot;&quot;))&#123;</span><br><span class="line">​            &#x2F;&#x2F;缓存区里有数据的情况下，生产者不生产数据的</span><br><span class="line">​            lock.wait();&#x2F;&#x2F;让当前线程阻塞，把当前线程的同步锁释放出去</span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​          &#x2F;&#x2F;这时我们才真正的开始生产数据</span><br><span class="line">​          System.out.println(&quot;缓存区没的数据，这时我们才真正的开始生产数据&quot;);</span><br><span class="line">​          ValueObject.value &#x3D; System.currentTimeMillis()+&quot;&quot;;</span><br><span class="line">​          &#x2F;&#x2F;这个生产数据完毕，放进了缓冲区了，通知消费者线程，消费数据</span><br><span class="line">​          lock.notify();</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;catch (Exception e)&#123;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现消费者线程类</span><br><span class="line">class C extends Thread&#123;</span><br><span class="line">  private Object lock;</span><br><span class="line">  public C(Object lock)&#123;</span><br><span class="line">​    this.lock &#x3D; lock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    while (true)&#123;</span><br><span class="line">​     try &#123;</span><br><span class="line">​      synchronized (lock)&#123;</span><br><span class="line">​        &#x2F;&#x2F;判断缓冲区里有数据没的</span><br><span class="line">​        if(ValueObject.value.equals(&quot;&quot;))&#123;</span><br><span class="line">​          lock.wait();</span><br><span class="line">​        &#125;</span><br><span class="line">​        System.out.println(&quot;缓冲区里有数据，现在把数据消费掉！&quot;);</span><br><span class="line">​        ValueObject.value &#x3D; &quot;&quot;;</span><br><span class="line">​        &#x2F;&#x2F;消费者把数据消费后，通知生产者，生产数据</span><br><span class="line">​        lock.notify();</span><br><span class="line">​      &#125;</span><br><span class="line">​     &#125;catch (Exception e)&#123;</span><br><span class="line">​     &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-通过JUC中的lock-condition两个类来等待唤醒线程"><a href="#2-通过JUC中的lock-condition两个类来等待唤醒线程" class="headerlink" title="2.通过JUC中的lock,condition两个类来等待唤醒线程"></a>2.通过JUC中的lock,condition两个类来等待唤醒线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ThreadTest2 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">​    Condition condition &#x3D; lock.newCondition();  &#x2F;&#x2F;condition通过lock来声明</span><br><span class="line">​    P1 p &#x3D; new P1(lock,condition);</span><br><span class="line">​    C1 c &#x3D; new C1(lock,condition);</span><br><span class="line">​    p.start();</span><br><span class="line">​    c.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;定义一个类，模拟生产者和消费者之间的缓冲区</span><br><span class="line">class ValueObject1 &#123;</span><br><span class="line">  public static String value &#x3D; &quot;&quot;; &#x2F;&#x2F;模拟的缓冲区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现生产者的线程类</span><br><span class="line">class P1 extends Thread &#123;</span><br><span class="line">  private Lock lock;</span><br><span class="line">  private Condition condition;</span><br><span class="line">  public P1(Lock lock, Condition condition) &#123;</span><br><span class="line">​    this.lock &#x3D; lock;</span><br><span class="line">​    this.condition &#x3D; condition;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    while (true) &#123;</span><br><span class="line">​      try &#123;</span><br><span class="line">​        lock.lock();</span><br><span class="line">​        &#x2F;&#x2F;作为生产者的基本功能，生产数据</span><br><span class="line">​        if (!ValueObject.value.equals(&quot;&quot;)) &#123;</span><br><span class="line">​          &#x2F;&#x2F;缓存区里有数据的情况下，生产者不生产数据的</span><br><span class="line">​          condition.await();&#x2F;&#x2F;让当前线程阻塞，把当前线程的同步锁释放出去</span><br><span class="line">​        &#125;</span><br><span class="line">​        &#x2F;&#x2F;这时我们才真正的开始生产数据</span><br><span class="line">​        System.out.println(&quot;缓存区没的数据，这时我们才真正的开始生产数据&quot;);</span><br><span class="line">​        ValueObject.value &#x3D; System.currentTimeMillis() + &quot;&quot;;</span><br><span class="line">​        &#x2F;&#x2F;这个生产数据完毕，放进了缓冲区了，通知消费者线程，消费数据</span><br><span class="line">​        condition.signal();</span><br><span class="line">​      &#125; catch (Exception e) &#123;</span><br><span class="line">​      &#125; finally &#123;</span><br><span class="line">​        lock.unlock();</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现消费者线程类</span><br><span class="line">class C1 extends Thread &#123;</span><br><span class="line">  private Lock lock;</span><br><span class="line">  private Condition condition;</span><br><span class="line">  public C1(Lock lock, Condition condition) &#123;</span><br><span class="line">​    this.lock &#x3D; lock;</span><br><span class="line">​    this.condition &#x3D; condition;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    while (true) &#123;</span><br><span class="line">​      try &#123;</span><br><span class="line">​        lock.lock();</span><br><span class="line">​        &#x2F;&#x2F;判断缓冲区里有数据没的</span><br><span class="line">​        if (ValueObject.value.equals(&quot;&quot;)) &#123;</span><br><span class="line">​          condition.await();</span><br><span class="line">​        &#125;</span><br><span class="line">​        System.out.println(&quot;缓冲区里有数据，现在把数据消费掉！&quot;);</span><br><span class="line">​        ValueObject.value &#x3D; &quot;&quot;;</span><br><span class="line">​        &#x2F;&#x2F;消费者把数据消费后，通知生产者，生产数据</span><br><span class="line">​        condition.signal();</span><br><span class="line">​      &#125; catch (Exception e) &#123;</span><br><span class="line">​      &#125; finally &#123;</span><br><span class="line">​        lock.unlock();</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程控制的方法"><a href="#线程控制的方法" class="headerlink" title="线程控制的方法"></a>线程控制的方法</h2><p>Interrupt:给调用者线程打一个中断标记</p>
<p>Interrrupted:检测当前运行的线程是否有中断标记并清除该标记</p>
<p>isInterrupted:检测调用者线程是否有中断标记</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Control &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    ConThread th &#x3D; new ConThread();</span><br><span class="line">​    Thread con &#x3D; new Thread(th);</span><br><span class="line">​    con.start();</span><br><span class="line">​    con.interrupt();  &#x2F;&#x2F;加标记</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConThread implements Runnable&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">​    if(Thread.currentThread().isInterrupted() &#x3D;&#x3D; true)&#123;  &#x2F;&#x2F;读标记</span><br><span class="line">​      System.out.println(&quot;线程已经被打断了&quot;);</span><br><span class="line">​      System.out.println(Thread.currentThread().isInterrupted());</span><br><span class="line">​      return;</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程通讯：按顺序打印ABCABCABC……"><a href="#线程通讯：按顺序打印ABCABCABC……" class="headerlink" title="线程通讯：按顺序打印ABCABCABC……"></a>线程通讯：按顺序打印ABCABCABC……</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">public class Abc &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    Function ft &#x3D; new Function();</span><br><span class="line">​    new Thread(new Runnable() &#123;</span><br><span class="line">​      @Override</span><br><span class="line">​      public void run() &#123;</span><br><span class="line">​        while(true)&#123;</span><br><span class="line">​          ft.A();</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;).start();</span><br><span class="line"></span><br><span class="line">​    new Thread(new Runnable() &#123;</span><br><span class="line">​      @Override</span><br><span class="line">​      public void run() &#123;</span><br><span class="line">​        while(true)&#123;</span><br><span class="line">​          ft.B();</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;).start();</span><br><span class="line"></span><br><span class="line">​    new Thread(new Runnable() &#123;</span><br><span class="line">​      @Override</span><br><span class="line">​      public void run() &#123;</span><br><span class="line">​        while(true)&#123;</span><br><span class="line">​          ft.C();</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Function&#123;</span><br><span class="line">  int number &#x3D;1;</span><br><span class="line">  Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">  Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line">  Condition condition2 &#x3D; lock.newCondition();</span><br><span class="line">  Condition condition3 &#x3D; lock.newCondition();</span><br><span class="line">  public void A()&#123;</span><br><span class="line">​    lock.lock();</span><br><span class="line">​    try&#123;</span><br><span class="line">​      if(number !&#x3D; 1)&#123;</span><br><span class="line">​        condition1.wait();</span><br><span class="line">​      &#125;</span><br><span class="line">​      System.out.println(&quot;A&quot;);</span><br><span class="line">​      number &#x3D; 2;</span><br><span class="line">​    &#125;catch (Exception e)&#123;</span><br><span class="line">​    &#125;finally &#123;</span><br><span class="line">​      lock.unlock();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void B()&#123;</span><br><span class="line">​    lock.lock();</span><br><span class="line">​    try&#123;</span><br><span class="line">​      if(number !&#x3D; 2)&#123;</span><br><span class="line">​        condition2.wait();</span><br><span class="line">​      &#125;</span><br><span class="line">​      System.out.println(&quot;B&quot;);</span><br><span class="line">​      number &#x3D; 3;</span><br><span class="line">​    &#125;catch (Exception e)&#123;</span><br><span class="line">​    &#125;finally &#123;</span><br><span class="line">​      lock.unlock();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void C()&#123;</span><br><span class="line">​    lock.lock();</span><br><span class="line">​    try&#123;</span><br><span class="line">​      if(number !&#x3D; 3)&#123;</span><br><span class="line">​        condition3.wait();</span><br><span class="line">​      &#125;</span><br><span class="line">​      System.out.println(&quot;C&quot;);</span><br><span class="line">​      number &#x3D; 1;</span><br><span class="line">​    &#125;catch (Exception e)&#123;</span><br><span class="line">​    &#125;finally &#123;</span><br><span class="line">​      lock.unlock();</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="读写锁ReadWriteLock：提供readLock-writeLock两种锁，一个是读锁，一个是写锁"><a href="#读写锁ReadWriteLock：提供readLock-writeLock两种锁，一个是读锁，一个是写锁" class="headerlink" title="读写锁ReadWriteLock：提供readLock,writeLock两种锁，一个是读锁，一个是写锁"></a>读写锁ReadWriteLock：提供readLock,writeLock两种锁，一个是读锁，一个是写锁</h2><p>1.读锁可以被多个线程获取，写锁是独占的</p>
<p>2.一个获取读锁的线程必须能够看到前一个写锁对内存数据更新后的最新值</p>
<p>3.主要适用于读操作多，写操作少的数据资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line">public class ReadWrite &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">​    Rw rw &#x3D; new Rw();</span><br><span class="line">​    new Thread(new Runnable() &#123;</span><br><span class="line">​      @Override</span><br><span class="line">​      public void run() &#123;</span><br><span class="line">​        for(int i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class="line">​          rw.Read();</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;,&quot;读线程&quot;).start();</span><br><span class="line"></span><br><span class="line">​    new Thread(new Runnable() &#123;</span><br><span class="line">​      @Override</span><br><span class="line">​      public void run() &#123;</span><br><span class="line">​        rw.Write(12);</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;,&quot;写线程&quot;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rw&#123;</span><br><span class="line">  private int num &#x3D; 0;</span><br><span class="line">  ReadWriteLock rwl &#x3D; new ReentrantReadWriteLock(); </span><br><span class="line">  &#x2F;&#x2F;这个函数是可以传参的，默认为false定义的是不公平锁，true定义的是公平锁，前者拥有更高的吞吐量</span><br><span class="line"></span><br><span class="line">  public void Read()&#123;</span><br><span class="line">​    rwl.readLock().lock();</span><br><span class="line">​    System.out.println(Thread.currentThread().getName()+&quot;  &quot;+num);</span><br><span class="line">​    rwl.readLock().unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void Write(int num)&#123;</span><br><span class="line">​    rwl.writeLock().lock();</span><br><span class="line">​    this.num&#x3D; num;</span><br><span class="line">​    System.out.println(Thread.currentThread().getName()+&quot;  &quot;+num);</span><br><span class="line">​    rwl.writeLock().unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="朵多线程中的函数式lambda编程"><a href="#朵多线程中的函数式lambda编程" class="headerlink" title="朵多线程中的函数式lambda编程"></a>朵多线程中的函数式lambda编程</h2><p><img src="/" class="lazyload" data-src="/2020/04/28/juc/clip_image003.png"  alt="juc"></p>
<h3 id="无参lambda"><a href="#无参lambda" class="headerlink" title="无参lambda"></a>无参lambda</h3><p><img src="/" class="lazyload" data-src="/2020/04/28/juc/clip_image004.png"  alt="juc"></p>
<h3 id="有参lambda"><a href="#有参lambda" class="headerlink" title="有参lambda"></a>有参lambda</h3><p><img src="/" class="lazyload" data-src="/2020/04/28/juc/clip_image005.png"  alt="juc"></p>
<p>lambda表达式的标准格式：（不关注用什么对象来实现,可省略，可推导，凡是根据上下文推导出来的内容，都可以省略，接口有且只有一个抽象方法）</p>
<p>   <strong>a.一些参数</strong></p>
<p>   <strong>b.一个箭头，-&gt;,把参数传给方法体</strong></p>
<p>   <strong>c.一段代码</strong></p>
<p><strong>格式：（参数列表）-&gt;{重写的代码}</strong></p>
<p><strong>可以省略的内容：</strong></p>
<p><strong>1.（参数列表）：括号中**</strong>参数列表的数据类型<strong>**，可以省略不写</strong></p>
<p><strong>2.（参数列表）：括号中的**</strong>参数如果只有一个<strong>**，那么类型和（）都可以省略</strong></p>
<p><strong>3.（一些代码）：如果{}中的**</strong>代码只有一行<strong><strong>，无论是否有返回值，都可以省略{}，return,分号（</strong></strong>三个一起省略<strong>**）</strong></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">李上</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/04/28/juc/">http://yoursite.com/2020/04/28/juc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">定不辱使命</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/">JUC</a><a class="post-meta__tags" href="/tags/%E4%B9%90%E8%A7%82%E9%94%81/">乐观锁</a><a class="post-meta__tags" href="/tags/%E6%82%B2%E8%A7%82%E9%94%81/">悲观锁</a><a class="post-meta__tags" href="/tags/CAS/">CAS</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a><a class="post-meta__tags" href="/tags/%E6%AD%BB%E9%94%81/">死锁</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">线程同步</a><a class="post-meta__tags" href="/tags/volatile/">volatile</a><a class="post-meta__tags" href="/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/">原子性</a><a class="post-meta__tags" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E5%86%99%E9%94%81/">读写锁</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/">线程控制</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%AE%AF/">线程通讯</a></div><div class="post_share"><div class="social-share" data-image="/img/mysql.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><img class="prev_cover lazyload" data-src="/img/JavaCore.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《Java核心卷一》读书笔记</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/28/springmvc/"><img class="next_cover lazyload" data-src="/img/springmvc.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring MVC学习笔记</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 李上</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>