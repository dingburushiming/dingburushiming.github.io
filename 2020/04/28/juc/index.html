<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>juc | 定不辱使命</title><meta name="description" content="juc"><meta name="author" content="李上"><meta name="copyright" content="李上"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="juc"><meta name="twitter:description" content="juc"><meta name="twitter:image" content="http://yoursite.com/img/juc.png"><meta property="og:type" content="article"><meta property="og:title" content="juc"><meta property="og:url" content="http://yoursite.com/2020/04/28/juc/"><meta property="og:site_name" content="定不辱使命"><meta property="og:description" content="juc"><meta property="og:image" content="http://yoursite.com/img/juc.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/04/28/juc/"><link rel="prev" title="Java核心卷——基础知识" href="http://yoursite.com/2020/05/06/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><link rel="next" title="Spring MVC学习笔记" href="http://yoursite.com/2020/04/28/springmvc/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: false  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/juc.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">定不辱使命</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">juc</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-28 22:22:51"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-04-29 22:52:35"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-29</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JUC/">JUC</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>并发与并行的区别：</p>
<p>并行：在同一时刻，多条指令在多个处理器上同时进行</p>
<p>并发：一个时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得宏观上具有多个线程同时执行的效果，在没有引入线程前，进程的并发调度，需要操作系统调度算法运行，效率很低。线程没有算法调度这一步，效率更高</p>
<p>程序，进程，线程之间的关系：</p>
<p>1.进程和程序的关系犹如演出和剧本的关系</p>
<p>2.进程从操作系统获取内存空间，所有的线程共享着这一内存空间（每个线程都会有自己私有的内存地址范围，其他线程不能访问）</p>
<p>3.由于线程之间共享内存空间，所以通过共享进程级全局变量就可以实现线程之间的通讯</p>
<p>第一种创建线程的方法，主函数也是JVM的线程，所有的线程都是在抢JVM的运行地址的权限（直接继承Thread类，重写run方法）</p>
<p>public class FirstThread {</p>
<p>  public static void main(String[] args) throws InterruptedException {</p>
<p>​    for(int i =0;i &lt; 10;i++){</p>
<p>​      System.out.println(Thread.currentThread().getName() + i);</p>
<p>​      if(i == 1){</p>
<p>​        new MyThread().start();</p>
<p>​        new MyThread().start();</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>class MyThread extends Thread{</p>
<p>   @Override</p>
<p>   public void run() {</p>
<p>​     for(int i =0;i &lt; 10;i++){</p>
<p>​       System.out.println(this.getName() + i);  //只有继承了Thread的类中才可以直接使用this代表线程，实现接口Runnable的不可以，主函数也不可以</p>
<p>​     }</p>
<p>   }</p>
<p>}</p>
<p>第二种创建线程的方法（实现Runnable接口，重写run方法）</p>
<p>public class RunnableThread {</p>
<p>  public static void main(String[] args) {</p>
<p>​    MyThread myThread = new MyThread();     //多个线程共用同一个MyThread对象</p>
<p>​    for(int i =0;i &lt; 10;i++){</p>
<p>​      System.out.println(Thread.currentThread().getName() + i);</p>
<p>​      if(i == 1){</p>
<p>​        new Thread(myThread,”thread1”).start();</p>
<p>​        new Thread(myThread,”thread2”).start();</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>class MyThread implements Runnable{</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    for(int i =0;i &lt; 10;i++){</p>
<p>​      System.out.println(Thread.currentThread().getName() + i);</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>第三种创建线程的方法（实现Callable接口，重写call方法）</p>
<p>public class CallableThread {</p>
<p>  public static void main(String[] args) throws ExecutionException, InterruptedException {</p>
<p>​    ThirdThread thirdThread = new ThirdThread();</p>
<p>​    FutureTask<Integer> futureTask = new FutureTask&lt;&gt;(thirdThread);</Integer></p>
<p>​    for(int i =0;i &lt; 10;i++){</p>
<p>​      System.out.println(Thread.currentThread().getName() + i);</p>
<p>​      if(i == 1){</p>
<p>​        new Thread(futureTask,”子线程1”).start();  //一个线程只能对应一个FutureTask对象，不能共享使用</p>
<p>​      }</p>
<p>​    }</p>
<p>​    System.out.println(futureTask.get());  //获取ThirdThread的返回值</p>
<p>  }</p>
<p>}</p>
<p>class ThirdThread implements Callable{</p>
<p>  @Override</p>
<p>  public Object call() throws Exception {</p>
<p>​    int i = 1;</p>
<p>​    for(;i &lt; 10;i++){</p>
<p>​      System.out.println(Thread.currentThread().getName() + i);</p>
<p>​    }</p>
<p>​    return i;</p>
<p>  }</p>
<p>}</p>
<p>三种创建线程方法的优劣：</p>
<p>1.Runnable接口创建线程可以共用一个target对象，非常适合多个相同线程共同处理同一个资源的情况</p>
<p>2.继承Thread类创建线程可以直接用this指代当前线程，其余两种接口创建线程的方法都必须使用Thread.currentThread()来获取当前线程</p>
<p>3.多数情况下优先考虑Runnable接口创建线程</p>
<p>4.两类方法创建线程对象时，继承Thread想要声明线程名，需要定义构造函数，实现接口Runnable则可以直接声明</p>
<p>join方法：让父线程等待子线程结束了才接着执行，由并发执行变成串行执行</p>
<p>public static void main(String[] args) throws InterruptedException {</p>
<p>​      System.out.println(Thread.currentThread().getName());</p>
<p>​        Thread t1 = new MyThread1();</p>
<p>​        t1.start();</p>
<p>​        t1.join(10);</p>
<p>​      System.out.println(“主线程执行结束”);</p>
<p>  }</p>
<p>1.join(n)是可以加参数的，参数的意义是父线程等待子线程运行n毫秒后，父子两个线程由串行重新变成并发执行，抢夺cpu资源，n=0或者不写代表等待无限时间</p>
<p>2.join方法必须在start方法之后使用</p>
<p>后台线程：如果前台线程结束了，后台线程强制结束；后台线程结束了，前台线程仍然可以接着执行</p>
<p>public class FirstThread {</p>
<p>  public static void main(String[] args) throws InterruptedException {</p>
<p>​      Thread t1 = new qiantai(“前台”);</p>
<p>​      t1.start();</p>
<p>​      Thread t2 = new houtai(“后台”);</p>
<p>​      t2.setDaemon(true);       //将线程t2设置为后台线程</p>
<p>​      t2.start();</p>
<p>  }</p>
<p>}</p>
<p>class qiantai extends Thread{</p>
<p>  qiantai(String name){</p>
<p>​    super(name);</p>
<p>  }</p>
<p>   @Override</p>
<p>   public void run() {</p>
<p>​     for(int i =0;i &lt; 100;i++){</p>
<p>​       try {</p>
<p>​         Thread.sleep(5);</p>
<p>​       } catch (InterruptedException e) {</p>
<p>​         e.printStackTrace();</p>
<p>​       }</p>
<p>​       System.out.println(this.getName() +”  “+ i);</p>
<p>​     }</p>
<p>   }</p>
<p>}</p>
<p>class houtai extends Thread{</p>
<p>  houtai(String name){</p>
<p>​    super(name);</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    for(int i =0;i &lt; 100;i++){</p>
<p>​      try {</p>
<p>​        Thread.sleep(10);</p>
<p>​      } catch (InterruptedException e) {</p>
<p>​        e.printStackTrace();</p>
<p>​      }</p>
<p>​      System.out.println(this.getName() +”  “+ i);</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>sleep（）</p>
<p>1.sleep是静态方法，使用方式为 Thread.sleep(),一般情况下放在线程的run方法中</p>
<p>2.sleep只能让当前线程沉睡，t.sleeep()沉睡的不是t线程，而是该语句当前所处的线程</p>
<p>3.使用方式还有：</p>
<p>TimeUnit.SECONDS.sleep()  TimeUnit.MINUTES.sleep()</p>
<p>TimeUnit.HOURS.sleep()     TimeUnit.DAYS.sleep()</p>
<p>线程优先级：1-10数字越大优先级越高</p>
<p>thread.setPriority()设置优先级</p>
<p>thread.getPriority()获取优先级</p>
<p>yield线程让步：</p>
<p>使用yield方法的线程释放cpu资源，进入就绪状态（不阻塞），和别的线程一同抢夺cpu资源</p>
<p>同时满足以下两个情况时，会产生线程安全问题</p>
<p>1.多个线程在操作共享数据（加锁）</p>
<p>2.操作共享数据的代码有多条（原子性，cass算法+volatile）</p>
<p>当一个线程在执行操作共享数据的多行代码时，其他线程参与了运算，就会导致线程安全问题的产生</p>
<p>解决线程安全问题的方法：线程同步</p>
<p>线程同步方法一:添加synchronized代码块</p>
<p>public class RunnableThread {</p>
<p>  public static void main(String[] args) {</p>
<p>​    MyThread mt = new MyThread();</p>
<p>​    Thread t1 = new Thread(mt,”线程1”);</p>
<p>​    t1.start();</p>
<p>​    Thread t2 = new Thread(mt,”线程2”);</p>
<p>​    t2.start();</p>
<p>​    Thread t3 = new Thread(mt,”线程3”);</p>
<p>​    t3.start();</p>
<p>​    Thread t4 = new Thread(mt,”线程4”);</p>
<p>​    t4.start();</p>
<p>  }</p>
<p>}</p>
<p>class MyThread implements Runnable{</p>
<p>  private int ticket = 100;</p>
<p>  Object object = new Object();</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    while(true){</p>
<p>​      synchronized (object){</p>
<p>​        if(ticket &gt; 0){</p>
<p>​          System.out.println(Thread.currentThread().getName()+”卖出了第”+ticket+”号票”);</p>
<p>​          ticket–;</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>线程同步方法二:添加synchronized方法</p>
<p>1.该方法也可以使用static修饰符 但是前者的锁对象是类对象实例，后者的锁对象是函数所在类</p>
<p>2.sleep会让线程沉睡，但是不会释放锁对象</p>
<p>public class RunnableThread {</p>
<p>  public static void main(String[] args) {</p>
<p>​    MyThread mt = new MyThread();     //mt是锁对象</p>
<p>​    Thread t1 = new Thread(mt,”线程1”);</p>
<p>​    t1.start();</p>
<p>​    Thread t2 = new Thread(mt,”线程2”);</p>
<p>​    t2.start();</p>
<p>​    Thread t3 = new Thread(mt,”线程3”);</p>
<p>​    t3.start();</p>
<p>​    Thread t4 = new Thread(mt,”线程4”);</p>
<p>​    t4.start();</p>
<p>  }</p>
<p>}</p>
<p>class MyThread implements Runnable{     //如果使用静态修饰符static ，则MyThread是锁对象</p>
<p>  private int ticket = 100;</p>
<p>  private Object object = new Object();</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    while(true){</p>
<p>​        this.sell();</p>
<p>​    }</p>
<p>  }</p>
<p>  public synchronized void sell(){</p>
<p>​    if(ticket &gt; 0){</p>
<p>​      System.out.println(Thread.currentThread().getName()+”卖出了第”+ticket+”号票”);</p>
<p>​      ticket–;</p>
<p>​    }else{</p>
<p>​      System.exit(0);</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>线程同步方法三:JUC包中的lock接口来进行上锁</p>
<p>class MyThread implements Runnable{</p>
<p>  private int ticket = 100;</p>
<p>  Lock lock = new ReentrantLock();</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    while(true){</p>
<p>​      lock.lock();</p>
<p>​      try{</p>
<p>​        if(ticket &gt; 0){</p>
<p>​          System.out.println(Thread.currentThread().getName()+”卖出了第”+ticket+”号票”);</p>
<p>​          ticket–;</p>
<p>​        }else{</p>
<p>​          System.exit(0);</p>
<p>​        }</p>
<p>​      }catch (Exception e){</p>
<p>​      }finally {</p>
<p>​        lock.unlock();</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>线程同步方法四:使用局部变量实现线程同步</p>
<p>这种方法本质上和前三种存在区别，前三种是共同售卖1同一份资源（多个线程卖100张票），指一种是所有线程售卖相同的不共享的资源（每个线程都卖100张票）</p>
<p>class MyThread implements Runnable{</p>
<p>  ThreadLocal<Integer> ticket = new ThreadLocal<Integer>(){</Integer></Integer></p>
<p>​    @Override</p>
<p>​    protected Integer initialValue() {</p>
<p>​      return 10;</p>
<p>​    }</p>
<p>  };</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    while(true){</p>
<p>​      if(ticket.get() &gt; 0){</p>
<p>​        System.out.println(Thread.currentThread().getName()+”卖出了第”+ticket.get()+”号票”);</p>
<p>​        ticket.set(ticket.get()-1);</p>
<p>​      }else{</p>
<p>​        break;</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>同步机制总结：</p>
<p>1.多线程的同步，本质上是被线程加上了一层锁，得到锁的线程就执行，没有得到的就等待</p>
<p>2.以下情况JVM会释放锁</p>
<p>同步代码块执行结束，线程中遇到了break,return,线程中出现了erroe,exception，线程中调用了wait()方法</p>
<p>3.以下情况JVM不会释放锁</p>
<p>程序中调用sleep(),yield()方法,其他线程调用了该线程的suspend()方法</p>
<p>死锁：当A需要B的资源，B需要A的资源，且二者都不释放对方需要的那个资源。</p>
<p>锁顺序死锁：当两个线程所需锁冲突时</p>
<p>public class SiSuo {</p>
<p>  public static void main(String[] args) {</p>
<p>​    ThreadDemo td = new ThreadDemo();</p>
<p>​    new Thread(td,”线程一”).start();</p>
<p>​    new Thread(td,”线程二”).start();</p>
<p>  }</p>
<p>}</p>
<p>class ThreadDemo implements Runnable {</p>
<p>  Object suo1 = new Object();</p>
<p>  Object suo2 = new Object();</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    m1();</p>
<p>​    m2();</p>
<p>  }</p>
<p>  void m1(){</p>
<p>​    synchronized (suo1){</p>
<p>​      System.out.println(Thread.currentThread().getName()+”拿到了锁1,还想拿到锁2”);</p>
<p>​      synchronized (suo2){</p>
<p>​        System.out.println(Thread.currentThread().getName()+”拿到了锁1,拿到锁2”);</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>  void m2(){</p>
<p>​    synchronized (suo2){</p>
<p>​      System.out.println(Thread.currentThread().getName()+”拿到了锁2,还想拿到锁1”);</p>
<p>​      synchronized (suo1){</p>
<p>​        System.out.println(Thread.currentThread().getName()+”拿到了锁2,拿到锁1”);</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>锁顺序死锁：转账锁顺序死锁：当线程一要从a向b转账拿到a锁想要b锁，线程二要从b向a转账拿到b锁想要a锁</p>
<p>public class ZhuanZhang {</p>
<p>  public static void main(String[] args) {</p>
<p>​    Transfer ts = new Transfer();</p>
<p>​    new Thread(ts,”线程一”).start();</p>
<p>​    new Thread(ts,”线程二”).start();</p>
<p>  }</p>
<p>}</p>
<p>class Transfer implements Runnable{</p>
<p>  Account a = new Account(“a”,1000);</p>
<p>  Account b = new Account(“b”,1000);</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    transferMoney(a,b,100);</p>
<p>​    transferMoney(b,a,100);</p>
<p>  }</p>
<p>  void transferMoney(Account fromAccount, Account toAccount,double money){</p>
<p>​    synchronized (fromAccount){</p>
<p>​      System.out.println(Thread.currentThread().getName()+”拿到转出账户锁”+fromAccount.getName());</p>
<p>​      synchronized (toAccount){</p>
<p>​        System.out.println(Thread.currentThread().getName()+”拿到转入账户锁”+toAccount.getName());</p>
<p>​        if(money &lt; fromAccount.getMoney()){</p>
<p>​          fromAccount.setMoney(fromAccount.getMoney()-money);</p>
<p>​          toAccount.setMoney(toAccount.getMoney()+money);</p>
<p>​          System.out.println(Thread.currentThread().getName()+”转账后”+fromAccount.getName()+”余额为”+fromAccount.getMoney());</p>
<p>​          System.out.println(Thread.currentThread().getName()+”转账后”+toAccount.getName()+”余额为”+toAccount.getMoney());</p>
<p>​        }else {</p>
<p>​          System.out.println(“余额不足”);</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>class Account{</p>
<p>  String name;</p>
<p>  double money;</p>
<p>  public Account(String name, double money) {</p>
<p>​    this.name = name;</p>
<p>​    this.money = money;</p>
<p>  }</p>
<p>  public String getName() {</p>
<p>​    return name;</p>
<p>  }</p>
<p>  public void setName(String name) {</p>
<p>​    this.name = name;</p>
<p>  }</p>
<p>  public double getMoney() {</p>
<p>​    return money;</p>
<p>  }</p>
<p>  public void setMoney(double money) {</p>
<p>​    this.money = money;</p>
<p>  }</p>
<p>}</p>
<p>解决锁顺序死锁的方法：规范加锁顺序</p>
<p>public class SiSuo {</p>
<p>  public static void main(String[] args) {</p>
<p>​    ThreadDemo td = new ThreadDemo();</p>
<p>​    new Thread(td,”线程一”).start();</p>
<p>​    new Thread(td,”线程二”).start();</p>
<p>  }</p>
<p>}</p>
<p>class ThreadDemo implements Runnable {</p>
<p>  Object suo1 = new Object();</p>
<p>  Object suo2 = new Object();</p>
<p>  Object jiasuo = new Object();</p>
<p>  int suo1HashCode = System.identityHashCode(suo1);</p>
<p>  int suo2HashCode = System.identityHashCode(suo2);</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    m1();</p>
<p>​    m2();</p>
<p>  }</p>
<p>  class Demo {       //加上内部类，简化代码量</p>
<p>​    public void takeSuo(){</p>
<p>​      System.out.println(Thread.currentThread().getName()+”拿到了锁1,还想拿到锁2”);</p>
<p>​      synchronized (suo2){</p>
<p>​        System.out.println(Thread.currentThread().getName()+”拿到了锁1,拿到锁2”);</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>  void m1(){</p>
<p>​    if(suo1HashCode &gt; suo2HashCode){</p>
<p>​      synchronized (suo1){</p>
<p>​        new Demo().takeSuo();</p>
<p>​      }</p>
<p>​    }else if(suo1HashCode &lt; suo2HashCode){</p>
<p>​      synchronized (suo2){</p>
<p>​        new Demo().takeSuo();</p>
<p>​      }</p>
<p>​    }else{</p>
<p>​      synchronized (jiasuo){</p>
<p>​        synchronized (suo1){</p>
<p>​          new Demo().takeSuo();</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>  void m2(){</p>
<p>​    if(suo1HashCode &gt; suo2HashCode){</p>
<p>​      synchronized (suo1){</p>
<p>​        new Demo().takeSuo();</p>
<p>​      }</p>
<p>​    }else if(suo1HashCode &lt; suo2HashCode){</p>
<p>​      synchronized (suo2){</p>
<p>​        new Demo().takeSuo();</p>
<p>​      }</p>
<p>​    }else{</p>
<p>​      synchronized (jiasuo){</p>
<p>​        synchronized (suo1){</p>
<p>​          new Demo().takeSuo();</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>对象协作导致死锁：对象协作过程中，一个功能可能要用多把锁，在多个线程调用的过程中，极大可能导致死锁</p>
<p>解决办法：开放调用避免死锁——尽量使用同步代码块，用同步代码块包裹操作共享数据的代码</p>
<p>import java.awt.*;</p>
<p>import java.util.HashSet;</p>
<p>import java.util.Set;</p>
<p>public class ThreadTest8 {</p>
<p>}</p>
<p>class Taxi{</p>
<p>  private Point location, destination;  //自己所在位置，目的地</p>
<p>  private Dispatcher dispatcher;</p>
<p>  public Taxi(Dispatcher dispatcher) {  //初始化客户的位置</p>
<p>​    this.dispatcher = dispatcher;</p>
<p>  }</p>
<p>  public synchronized Point getLocation() {  //获取共享数据，synchronized避免线程安全问题</p>
<p>​    return location;</p>
<p>  }</p>
<p>  public void setLocation(Point location) {    //设置车辆位置</p>
<p>​    boolean flag;</p>
<p>​    //内置锁保护的范围做了缩小</p>
<p>​    synchronized (this){</p>
<p>​      this.location = location;</p>
<p>​      flag = location.equals(destination);</p>
<p>​    }</p>
<p>​    if(flag){</p>
<p>​      dispatcher.notifyAvailable(this);    //满足条件将该车辆加入到调度集合里</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>class Dispatcher{</p>
<p>  private final Set<Taxi> taxis;</Taxi></p>
<p>  private final Set<Taxi> availableTaxis;</Taxi></p>
<p>  public Dispatcher() {</p>
<p>​    taxis = new HashSet<Taxi>();</Taxi></p>
<p>​    availableTaxis = new HashSet<Taxi>();</Taxi></p>
<p>  }</p>
<p>  public synchronized void notifyAvailable(Taxi taxi) {</p>
<p>​    availableTaxis.add(taxi);</p>
<p>  }</p>
<p>  public Image getImage() {</p>
<p>​    Set<Taxi> copy;</Taxi></p>
<p>​    synchronized (this){</p>
<p>​      copy = new HashSet<Taxi>(availableTaxis);</Taxi></p>
<p>​    }</p>
<p>​    Image image = new Image();</p>
<p>​    for (Taxi t : copy) {</p>
<p>​      // 调用getLocation()需要Taxi内置锁</p>
<p>​      image.drawMarker(t.getLocation());</p>
<p>​    }</p>
<p>​    return image;</p>
<p>  }</p>
<p>}</p>
<p>class Image {</p>
<p>  public void drawMarker(Point p) {</p>
<p>  }</p>
<p>}</p>
<p>定时锁：死锁超时自动结束</p>
<p>import java.util.concurrent.TimeUnit;</p>
<p>import java.util.concurrent.locks.Lock;</p>
<p>import java.util.concurrent.locks.ReentrantLock;</p>
<p>public class ThreadTest9 {</p>
<p>  public static void main(String[] args) {</p>
<p>​    System.out.println(“开始”);</p>
<p>​    Lock lock = new ReentrantLock();</p>
<p>​    new Thread(new Runnable() {</p>
<p>​      @Override</p>
<p>​      public void run() {</p>
<p>​        try {</p>
<p>​          if(lock.tryLock(1,TimeUnit.SECONDS)){</p>
<p>​            System.out.println(“获取到了锁”);</p>
<p>​            try {</p>
<p>​              for (int i=1;i&lt;6;i++){</p>
<p>​                System.out.println(Thread.currentThread().getName() + “–” + i);</p>
<p>​              }</p>
<p>​            }catch (Exception e){</p>
<p>​            }finally {</p>
<p>​              lock.unlock();</p>
<p>​            }</p>
<p>​          }else{</p>
<p>​            System.out.println(“没获取到锁”);</p>
<p>​            return;</p>
<p>​          }</p>
<p>​        } catch (Exception e) {</p>
<p>​          e.printStackTrace();</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }, “线程1”).start();</p>
<p>​    new Thread(new Runnable() {</p>
<p>​      @Override</p>
<p>​      public void run() {</p>
<p>​        try {</p>
<p>​          if(lock.tryLock()){</p>
<p>​            System.out.println(“获取到了锁”);</p>
<p>​            try {</p>
<p>​              for (int i=1;i&lt;6;i++){</p>
<p>​                System.out.println(Thread.currentThread().getName() + “–” + i);</p>
<p>​              }</p>
<p>​            }catch (Exception e){</p>
<p>​            }finally {</p>
<p>​              lock.unlock();</p>
<p>​            }</p>
<p>​          }else{</p>
<p>​            System.out.println(“没获取到锁”);</p>
<p>​            return;</p>
<p>​          }</p>
<p>​        } catch (Exception e) {</p>
<p>​          e.printStackTrace();</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }, “线程2”).start();</p>
<p>​    System.out.println(“结束”);</p>
<p>  }</p>
<p>}</p>
<p>volatile关键字和内存可见性</p>
<p>内存可见性：</p>
<p>线程中的共享变量都是从该变量的内存地址拷贝过来的，线程中的变量是存放在换从和寄存器中的，所以线程中的共享数据和内存中的共享地址的同步需要时间</p>
<p>volatitle:</p>
<p>可以尽快的将线程共享数据与内存共享数据同步</p>
<p>public class VolatileDemo {</p>
<p>  public static void main(String[] args) {</p>
<p>​    VolatileThread vd = new VolatileThread();</p>
<p>​    new Thread(vd,”线程一”).start();</p>
<p>​    while(true){</p>
<p>​      if(vd.isFlag()){</p>
<p>​        System.out.println(“falg已经设置为true”);</p>
<p>​        break;</p>
<p>​      }</p>
<p>​      System.out.println(vd.isFlag());</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>class VolatileThread implements Runnable{</p>
<p>  private volatile boolean flag = false;</p>
<p>  public boolean isFlag() {</p>
<p>​    return flag;</p>
<p>  }</p>
<p>  public void setFlag(boolean flag) {</p>
<p>​    this.flag = flag;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    try {</p>
<p>​      this.setFlag(true);</p>
<p>​    } catch (Exception e) {</p>
<p>​      e.printStackTrace();</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>synchronized：（高开销）</p>
<p>JVM关于synchronized的规定：</p>
<p>1.线程解锁前，必须把共享变量的最新值刷新到主内存中</p>
<p>2.线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值</p>
<p>synchronized(vd){</p>
<p>​        if(vd.isFlag()){</p>
<p>​          System.out.println(“falg已经设置为true”);</p>
<p>​          break;</p>
<p>​        }</p>
<p>​      }</p>
<p><img src="/" class="lazyload" data-src="/2020/04/28/juc/clip_image001.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png"  alt="img"></p>
<p>原子性：</p>
<p>1.转账过程中转出账户金额减少100，转入账户金额增加100，转账这一个操作包含了两个动作，如果前者做了后者没做就会出现问题，保证这两个操作要么都做，要么都不做的操作就是原子性</p>
<p>2.volatile只能保证内存可见性，不能保证原子性</p>
<p>public class YuanZi {</p>
<p>  public static void main(String[] args) {</p>
<p>  YuanZiThread yzt = new YuanZiThread();</p>
<p>​    for (int i = 0;i&lt; 10;i++){</p>
<p>​      new Thread(yzt,”线程”+i).start();</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>class YuanZiThread implements Runnable{</p>
<p>  private volatile int number = 0;</p>
<p>  public int getNumber(){</p>
<p>​    return number++;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​      try {</p>
<p>​        Thread.sleep(10);</p>
<p>​      } catch (InterruptedException e) {</p>
<p>​        e.printStackTrace();</p>
<p>​      }</p>
<p>​    System.out.println(Thread.currentThread().getName()+”  “+this.getNumber());</p>
<p>  }</p>
<p>}</p>
<p>线程在执行run方法中的自增方法过程中，由于没有原子性，别的线程开始运行，这个时候前一个线程的运算还没有结束，新的值还没有更新到内存中，就会导致两个线程打印出同样的数字</p>
<p>Java.util.concurrent.atomic包可以解决线程原子性问题（其实就是线程同步问题）</p>
<p>AtomicInteger AtomicBoolean AtomicLong AtomicReference</p>
<p>import java.util.concurrent.atomic.AtomicInteger;</p>
<p>public class ThreadTest2 {</p>
<p>  public static void main(String[] args) {</p>
<p>​    AtomicThread at = new AtomicThread();</p>
<p>​    for(int i=0;i&lt;10;i++){</p>
<p>​      new Thread(at,”线程”+i).start();</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>class AtomicThread implements Runnable{</p>
<p>  private AtomicInteger serialNum = new AtomicInteger(0);</p>
<p>  public int getSerialNum() {</p>
<p>​    return serialNum.getAndIncrement();</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    try {</p>
<p>​      Thread.sleep(500);</p>
<p>​    } catch (InterruptedException e) {</p>
<p>​      e.printStackTrace();</p>
<p>​    }</p>
<p>​    System.out.println(“显示serialNum完后，然它自增一：” + getSerialNum());</p>
<p>  }</p>
<p>}</p>
<p>悲观锁：假设每次一次线程都会冲突，采用加锁的方式避免一起冲突可能，但synchronized，lock </p>
<p>   花销很大  </p>
<p>乐观锁：假设大多数情况下线程都不会发生同步问题，采用检测冲突的方式，检测到冲突就不执行</p>
<p>  （视为失败，重新执行）花销较小</p>
<p>Cas(compare and swap):典型的乐观锁算法(C语言实现的操作系统底层算法，效率高)</p>
<p>   线程A和线程B从内存中读取数据56，同时抢夺cpu资源，A抢夺成功将内存中数据修改为57（失败的B线程不会被挂起，会接着尝试抢夺资源），当线程B抢夺到资源准备时检测到内存中的数据和自己副本中的数据56不等，B的这次操作就失败了，B会重新到内存中读取数据56，重新参与cpu资源的抢夺。（包装线程共享变量）</p>
<p>Volatile+cas算法解决了线程同步的问题（乐观）</p>
<p>线程安全的集合对象：</p>
<p>Vector,HashTable,StringBuffer</p>
<p>线程不安全的集合对象: ArrayList,LinkedList,HashMap,HashSet,TreeMap,TreeSet,StringBuilder</p>
<p>将不安全的集合对象转换为安全的集合对象的方法有两种</p>
<p>1.使用Collection.synchronizedXXX()方法来转换</p>
<p>List<String> li = Collection.synchronizedList(new ArrayList<String>)</String></String></p>
<p>Map&lt;String,String&gt; map = Collection.synchronizedMap(new HashMap&lt;&gt;())</p>
<p>HashMap和HashTable二者都是键值对容器，可以相互装换，前者线程不安全，后者线程安全</p>
<p>这个方法程序效率低，且复合操作时（读写）会报并发修改异常ConcurrentModificationException</p>
<p>public class Safe {</p>
<p>  public static void main(String[] args) {</p>
<p>​    safeThread st = new safeThread();</p>
<p>​    new Thread(st,”线程1”).start();</p>
<p>​    new Thread(st,”线程2”).start();</p>
<p>​    new Thread(st,”线程3”).start();</p>
<p>  }</p>
<p>}</p>
<p>class safeThread implements Runnable{</p>
<p>  static List<String> ls = Collections.synchronizedList(new ArrayList&lt;&gt;());</String></p>
<p>  static {</p>
<p>​    ls.add(“1”);</p>
<p>​    ls.add(“2”);</p>
<p>​    ls.add(“3”);</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    Iterator<String> it = ls.iterator();</String></p>
<p>​    while(it.hasNext()){</p>
<p>​      System.out.println(it.next());</p>
<p>​      ls.add(“4”);</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>2.使用JUC中的同步容器类来代替不安全的集合对象</p>
<p>ConcurrentHashMap替代HashMap</p>
<p>ConcurrentSkipListMap替代TreeMap</p>
<p>CopyOnWriteArrayList替代 ArrayList</p>
<p>CopyOnWriteArraySet 替代ArraySet</p>
<p>public class Safe {</p>
<p>  public static void main(String[] args) {</p>
<p>​    safeThread st = new safeThread();</p>
<p>​    new Thread(st,”线程1”).start();</p>
<p>​    new Thread(st,”线程2”).start();</p>
<p>​    new Thread(st,”线程3”).start();</p>
<p>  }</p>
<p>}</p>
<p>class safeThread implements Runnable{</p>
<p>  static CopyOnWriteArrayList<String> ls = new CopyOnWriteArrayList&lt;&gt;();</String></p>
<p>  static {</p>
<p>​    ls.add(“1”);</p>
<p>​    ls.add(“2”);</p>
<p>​    ls.add(“3”);</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    ls.add(“4”);</p>
<p>​    Iterator<String> it = ls.iterator();</String></p>
<p>​    while(it.hasNext()){</p>
<p>​      System.out.println(it.next());</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>CountDownLatch:</p>
<p>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</p>
<p>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</p>
<p>public class CDL {</p>
<p>  public static void main(String[] args) throws InterruptedException {</p>
<p>​    CountDownLatch latch = new CountDownLatch(50);</p>
<p>​    CountDownLatchThread cdt = new CountDownLatchThread(latch);</p>
<p>​    for (int i = 0;i &lt;50;i++){</p>
<p>​      new Thread(cdt,”线程”+i).start();</p>
<p>​    }</p>
<p>​    latch.await();</p>
<p>​    System.out.println(“主线程开始执行”);</p>
<p>  }</p>
<p>}</p>
<p>class CountDownLatchThread implements Runnable{</p>
<p>  private CountDownLatch latch;</p>
<p>  public CountDownLatchThread(CountDownLatch latch){</p>
<p>​    this.latch = latch;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​      try {</p>
<p>​        for(int i = 0;i &lt; 500;i++) {</p>
<p>​          if (i % 2 == 0) {</p>
<p>​            System.out.println(“这是线程” + Thread.currentThread().getName() + “的偶数” + i);</p>
<p>​          }</p>
<p>​        }</p>
<p>​      }finally {</p>
<p>​        latch.countDown();     </p>
<p>​      }</p>
<p>  }</p>
<p>}</p>
<p>Semaphore</p>
<p>发许可证，同时只允许固定数量的线程并发执行，许可证释放后别的线程可以获取</p>
<p>public class Sep {</p>
<p>  public static void main(String[] args) {</p>
<p>​    Semaphore sp = new Semaphore(5);</p>
<p>​    SemaphoreThread spt = new SemaphoreThread(sp);</p>
<p>​    for (int i =0;i&lt;10;i++){</p>
<p>​      new Thread(spt,”线程”+i).start();</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>class SemaphoreThread implements Runnable{</p>
<p>  private Semaphore semaphore;</p>
<p>  public SemaphoreThread(Semaphore semaphore){</p>
<p>​    this.semaphore = semaphore;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    try {</p>
<p>​      semaphore.acquire();</p>
<p>​      System.out.println(Thread.currentThread().getName()+”获取到许可证”);</p>
<p>​      Thread.sleep(1000);</p>
<p>​    } catch (InterruptedException e) {</p>
<p>​      e.printStackTrace();</p>
<p>​    }finally {</p>
<p>​      System.out.println(Thread.currentThread().getName()+”释放许可证”);</p>
<p>​      semaphore.release();</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>CyclicBarrier，可以设置集合点，所有线程都到达时统一放行（存在线程安全问题）</p>
<p>public class Cyc {</p>
<p>  public static void main(String[] args) {</p>
<p>​    CyclicBarrier cyclicBarrier = new CyclicBarrier(3);   //线程的数量</p>
<p>​    CyclicBarrierThread1 cbt = new CyclicBarrierThread1(cyclicBarrier);</p>
<p>​    for(int i = 1;i &lt; 4;i++){       //这里的i初始值不能为0</p>
<p>​      new Thread(cbt,”线程”+i).start();</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>class CyclicBarrierThread1 implements Runnable{</p>
<p>  private CyclicBarrier cyclicBarrier;</p>
<p>  public CyclicBarrierThread1(CyclicBarrier cyclicBarrier){</p>
<p>​    this.cyclicBarrier = cyclicBarrier;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    try {</p>
<p>​      Thread.sleep((long)(Math.random()*1000));</p>
<p>​      System.out.println(Thread.currentThread().getName()+”到达了景点一”+”,已到达的人数是”+cyclicBarrier.getNumberWaiting());</p>
<p>​      cyclicBarrier.await();</p>
<p>​      Thread.sleep((long)(Math.random()*1000));</p>
<p>​      System.out.println(Thread.currentThread().getName()+”到达了景点二”+”,已到达的人数是”+cyclicBarrier.getNumberWaiting());</p>
<p>​      cyclicBarrier.await();</p>
<p>​      Thread.sleep((long)(Math.random()*1000));</p>
<p>​      System.out.println(Thread.currentThread().getName()+”到达了景点三”+”,已到达的人数是”+cyclicBarrier.getNumberWaiting());</p>
<p>​      cyclicBarrier.await();</p>
<p>​      System.out.println(“大家一起回家了”);</p>
<p>​    } catch (InterruptedException | BrokenBarrierException e) {</p>
<p>​      e.printStackTrace();</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>线程之间数据的交换</p>
<p>当第一个线程执行到exchange方法时，它会等待第二个线程执行到exchange方法，两个方法执行到同步点的时候，会交换数据</p>
<p>import java.util.concurrent.Exchanger;</p>
<p>public class Change {</p>
<p>  private String msg1;</p>
<p>  private String msg2;</p>
<p>  public void a(Exchanger<String> exchanger){</String></p>
<p>​    try {</p>
<p>​      msg1 = “11111”;</p>
<p>​      System.out.println(“交换前的msg1:”+msg1);</p>
<p>​      msg1 = exchanger.exchange(msg1);</p>
<p>​      System.out.println(“交换后的msg1:”+msg1);</p>
<p>​      Thread.sleep(1000);</p>
<p>​    } catch (InterruptedException e) {</p>
<p>​      e.printStackTrace();</p>
<p>​    }</p>
<p>  }</p>
<p>  public void b(Exchanger<String> exchanger){</String></p>
<p>​    try {</p>
<p>​      msg2 = “22222”;</p>
<p>​      System.out.println(“交换前的msg2:”+msg2);</p>
<p>​      msg2 = exchanger.exchange(msg2);</p>
<p>​      System.out.println(“交换后的msg2:”+msg2);</p>
<p>​      Thread.sleep(1000);</p>
<p>​    } catch (InterruptedException e) {</p>
<p>​      e.printStackTrace();</p>
<p>​    }</p>
<p>  }</p>
<p>  public static void main(String[] args) {//主函数所在类的主方法在调用类方法时必须先声明一个类</p>
<p>​    Exchanger<String> exchanger = new Exchanger&lt;&gt;();  //两个线程使用的是同一个交换器的类</String></p>
<p>​    Change change = new Change();</p>
<p>​    new Thread(new Runnable() {</p>
<p>​      @Override</p>
<p>​      public void run() {</p>
<p>​        change.a(exchanger);</p>
<p>​      }</p>
<p>​    }).start();</p>
<p>​    new Thread(new Runnable() {</p>
<p>​      @Override</p>
<p>​      public void run() {</p>
<p>​        change.b(exchanger);</p>
<p>​      }</p>
<p>​    }).start();</p>
<p>  }</p>
<p>}</p>
<p>线程安全的单例模式</p>
<p>public class ThreadTest1 {</p>
<p>  public static void main(String[] args) {</p>
<p>​    for(int i=0;i&lt;20;i++){</p>
<p>​      new Thread(new Runnable() {</p>
<p>​        @Override</p>
<p>​        public void run() {</p>
<p>​          System.out.println(Singleton4.getInstance());</p>
<p>​        }</p>
<p>​      }).start();</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>//饿汉</p>
<p>//饿汉模式是线程安全的，多个线程创建实例对象时，JVM只允许一个线程对实例初始化，其余全部失败，但是花销比价大</p>
<p>class Singleton1 {</p>
<p>  private static Singleton1 singleton = new Singleton1();</p>
<p>  private Singleton1(){}</p>
<p>  public static Singleton1 getInstance(){</p>
<p>​    return singleton;</p>
<p>  }</p>
<p>}</p>
<p>//懒汉 非线程安全，加锁保证线程安全</p>
<p>class Singleton2{</p>
<p>  private volatile static Singleton2 singleton = null;</p>
<p>  private Singleton2(){}</p>
<p>  public static Singleton2 getInstance(){</p>
<p>​    if(singleton == null){ //第一次检查，高并发，很多线程会同时到达这里</p>
<p>​      synchronized (Singleton2.class){ //第二层保护</p>
<p>​        if(singleton == null){ //第三层保护，配合volatile关键字</p>
<p>​          singleton = new Singleton2(); //除了第一次进来的线程，其他所有线程都进不来了</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }</p>
<p>​    return singleton;</p>
<p>  }</p>
<p>}</p>
<p>//静态内部类的单例</p>
<p>//Singleton3被初始化时，静态内部类不会被立即加载，只有在调用SingleTonHoler.singleton时才会被初始化，既有饿汉模式保证线程安全的特性，又有懒汉减少资源使用的特性。缺点是静态内部类不能传参</p>
<p>class Singleton3{</p>
<p>  private Singleton3(){}</p>
<p>  private static class SingleTonHoler{</p>
<p>​    private static Singleton3 singleton = new Singleton3();</p>
<p>  }</p>
<p>  public static Singleton3 getInstance(){</p>
<p>​    return SingleTonHoler.singleton;</p>
<p>  }</p>
<p>}</p>
<p>//枚举的方式</p>
<p>enum Singleton4{</p>
<p>  SINGLETON;</p>
<p>  //可以省略此方法，通过Singleton.INSTANCE进行操作</p>
<p>  public static Singleton4 getInstance() {</p>
<p>​    return Singleton4.SINGLETON;</p>
<p>  }</p>
<p>}</p>
<p>匿名内部类</p>
<p><img src="/" class="lazyload" data-src="/2020/04/28/juc/clip_image002.png"  alt="img"></p>
<p>生产者与消费者问题（等待与唤醒机制）</p>
<p>上锁，等待唤醒的方式有两个：</p>
<p>1.声明一个object类，通过object.wait(),object.notify()等待唤醒线程，wait会让线程释放锁</p>
<p>public class ThreadTest1 {</p>
<p>  //运行测试的main方法</p>
<p>  public static void main(String[] args) {</p>
<p>​    Object lock = new Object(); //声明的是object类来作为锁</p>
<p>​    P p = new P(lock);</p>
<p>​    C c = new C(lock);</p>
<p>​    p.start();</p>
<p>​    c.start();</p>
<p>  }</p>
<p>}</p>
<p>//定义一个类，模拟生产者和消费者之间的缓冲区</p>
<p>class ValueObject{</p>
<p>  public static String value = “”; //模拟的缓冲区    //类的静态变量可以被直接调用</p>
<p>}</p>
<p>//实现生产者的线程类</p>
<p>class P extends Thread{</p>
<p>  private Object lock;</p>
<p>  public P(Object lock){</p>
<p>​    this.lock = lock;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    while (true){</p>
<p>​      try{</p>
<p>​        synchronized (lock){</p>
<p>​          //作为生产者的基本功能，生产数据</p>
<p>​          if(!ValueObject.value.equals(“”)){</p>
<p>​            //缓存区里有数据的情况下，生产者不生产数据的</p>
<p>​            lock.wait();//让当前线程阻塞，把当前线程的同步锁释放出去</p>
<p>​          }</p>
<p>​          //这时我们才真正的开始生产数据</p>
<p>​          System.out.println(“缓存区没的数据，这时我们才真正的开始生产数据”);</p>
<p>​          ValueObject.value = System.currentTimeMillis()+””;</p>
<p>​          //这个生产数据完毕，放进了缓冲区了，通知消费者线程，消费数据</p>
<p>​          lock.notify();</p>
<p>​        }</p>
<p>​      }catch (Exception e){</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>//实现消费者线程类</p>
<p>class C extends Thread{</p>
<p>  private Object lock;</p>
<p>  public C(Object lock){</p>
<p>​    this.lock = lock;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    while (true){</p>
<p>​     try {</p>
<p>​      synchronized (lock){</p>
<p>​        //判断缓冲区里有数据没的</p>
<p>​        if(ValueObject.value.equals(“”)){</p>
<p>​          lock.wait();</p>
<p>​        }</p>
<p>​        System.out.println(“缓冲区里有数据，现在把数据消费掉！”);</p>
<p>​        ValueObject.value = “”;</p>
<p>​        //消费者把数据消费后，通知生产者，生产数据</p>
<p>​        lock.notify();</p>
<p>​      }</p>
<p>​     }catch (Exception e){</p>
<p>​     }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>2.通过JUC中的lock,condition两个类来等待唤醒线程</p>
<p>import java.util.concurrent.locks.Condition;</p>
<p>import java.util.concurrent.locks.Lock;</p>
<p>import java.util.concurrent.locks.ReentrantLock;</p>
<p>public class ThreadTest2 {</p>
<p>  public static void main(String[] args) {</p>
<p>​    Lock lock = new ReentrantLock();</p>
<p>​    Condition condition = lock.newCondition();  //condition通过lock来声明</p>
<p>​    P1 p = new P1(lock,condition);</p>
<p>​    C1 c = new C1(lock,condition);</p>
<p>​    p.start();</p>
<p>​    c.start();</p>
<p>  }</p>
<p>}</p>
<p>//定义一个类，模拟生产者和消费者之间的缓冲区</p>
<p>class ValueObject1 {</p>
<p>  public static String value = “”; //模拟的缓冲区</p>
<p>}</p>
<p>//实现生产者的线程类</p>
<p>class P1 extends Thread {</p>
<p>  private Lock lock;</p>
<p>  private Condition condition;</p>
<p>  public P1(Lock lock, Condition condition) {</p>
<p>​    this.lock = lock;</p>
<p>​    this.condition = condition;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    while (true) {</p>
<p>​      try {</p>
<p>​        lock.lock();</p>
<p>​        //作为生产者的基本功能，生产数据</p>
<p>​        if (!ValueObject.value.equals(“”)) {</p>
<p>​          //缓存区里有数据的情况下，生产者不生产数据的</p>
<p>​          condition.await();//让当前线程阻塞，把当前线程的同步锁释放出去</p>
<p>​        }</p>
<p>​        //这时我们才真正的开始生产数据</p>
<p>​        System.out.println(“缓存区没的数据，这时我们才真正的开始生产数据”);</p>
<p>​        ValueObject.value = System.currentTimeMillis() + “”;</p>
<p>​        //这个生产数据完毕，放进了缓冲区了，通知消费者线程，消费数据</p>
<p>​        condition.signal();</p>
<p>​      } catch (Exception e) {</p>
<p>​      } finally {</p>
<p>​        lock.unlock();</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>//实现消费者线程类</p>
<p>class C1 extends Thread {</p>
<p>  private Lock lock;</p>
<p>  private Condition condition;</p>
<p>  public C1(Lock lock, Condition condition) {</p>
<p>​    this.lock = lock;</p>
<p>​    this.condition = condition;</p>
<p>  }</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    while (true) {</p>
<p>​      try {</p>
<p>​        lock.lock();</p>
<p>​        //判断缓冲区里有数据没的</p>
<p>​        if (ValueObject.value.equals(“”)) {</p>
<p>​          condition.await();</p>
<p>​        }</p>
<p>​        System.out.println(“缓冲区里有数据，现在把数据消费掉！”);</p>
<p>​        ValueObject.value = “”;</p>
<p>​        //消费者把数据消费后，通知生产者，生产数据</p>
<p>​        condition.signal();</p>
<p>​      } catch (Exception e) {</p>
<p>​      } finally {</p>
<p>​        lock.unlock();</p>
<p>​      }</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>线程控制的方法：</p>
<p>Interrupt:给调用者线程打一个中断标记</p>
<p>Interrrupted:检测当前运行的线程是否有中断标记并清除该标记</p>
<p>isInterrupted:检测调用者线程是否有中断标记</p>
<p>public class Control {</p>
<p>  public static void main(String[] args) {</p>
<p>​    ConThread th = new ConThread();</p>
<p>​    Thread con = new Thread(th);</p>
<p>​    con.start();</p>
<p>​    con.interrupt();  //加标记</p>
<p>  }</p>
<p>}</p>
<p>class ConThread implements Runnable{</p>
<p>  @Override</p>
<p>  public void run() {</p>
<p>​    if(Thread.currentThread().isInterrupted() == true){  //读标记</p>
<p>​      System.out.println(“线程已经被打断了”);</p>
<p>​      System.out.println(Thread.currentThread().isInterrupted());</p>
<p>​      return;</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>线程通讯：按顺序打印ABCABCABC……</p>
<p>import java.util.concurrent.locks.Condition;</p>
<p>import java.util.concurrent.locks.Lock;</p>
<p>import java.util.concurrent.locks.ReentrantLock;</p>
<p>public class Abc {</p>
<p>  public static void main(String[] args) {</p>
<p>​    Function ft = new Function();</p>
<p>​    new Thread(new Runnable() {</p>
<p>​      @Override</p>
<p>​      public void run() {</p>
<p>​        while(true){</p>
<p>​          ft.A();</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }).start();</p>
<p>​    new Thread(new Runnable() {</p>
<p>​      @Override</p>
<p>​      public void run() {</p>
<p>​        while(true){</p>
<p>​          ft.B();</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }).start();</p>
<p>​    new Thread(new Runnable() {</p>
<p>​      @Override</p>
<p>​      public void run() {</p>
<p>​        while(true){</p>
<p>​          ft.C();</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }).start();</p>
<p>  }</p>
<p>}</p>
<p>class Function{</p>
<p>  int number =1;</p>
<p>  Lock lock = new ReentrantLock();</p>
<p>  Condition condition1 = lock.newCondition();</p>
<p>  Condition condition2 = lock.newCondition();</p>
<p>  Condition condition3 = lock.newCondition();</p>
<p>  public void A(){</p>
<p>​    lock.lock();</p>
<p>​    try{</p>
<p>​      if(number != 1){</p>
<p>​        condition1.wait();</p>
<p>​      }</p>
<p>​      System.out.println(“A”);</p>
<p>​      number = 2;</p>
<p>​    }catch (Exception e){</p>
<p>​    }finally {</p>
<p>​      lock.unlock();</p>
<p>​    }</p>
<p>  }</p>
<p>  public void B(){</p>
<p>​    lock.lock();</p>
<p>​    try{</p>
<p>​      if(number != 2){</p>
<p>​        condition2.wait();</p>
<p>​      }</p>
<p>​      System.out.println(“B”);</p>
<p>​      number = 3;</p>
<p>​    }catch (Exception e){</p>
<p>​    }finally {</p>
<p>​      lock.unlock();</p>
<p>​    }</p>
<p>  }</p>
<p>  public void C(){</p>
<p>​    lock.lock();</p>
<p>​    try{</p>
<p>​      if(number != 3){</p>
<p>​        condition3.wait();</p>
<p>​      }</p>
<p>​      System.out.println(“C”);</p>
<p>​      number = 1;</p>
<p>​    }catch (Exception e){</p>
<p>​    }finally {</p>
<p>​      lock.unlock();</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p>读写锁ReadWriteLock：提供readLock,writeLock两种锁，一个是读锁，一个是写锁</p>
<p>1.读锁可以被多个线程获取，写锁是独占的</p>
<p>2.一个获取读锁的线程必须能够看到前一个写锁对内存数据更新后的最新值</p>
<p>3.主要适用于读操作多，写操作少的数据资源</p>
<p>import java.util.concurrent.locks.ReadWriteLock;</p>
<p>import java.util.concurrent.locks.ReentrantReadWriteLock;</p>
<p>public class ReadWrite {</p>
<p>  public static void main(String[] args) {</p>
<p>​    Rw rw = new Rw();</p>
<p>​    new Thread(new Runnable() {</p>
<p>​      @Override</p>
<p>​      public void run() {</p>
<p>​        for(int i = 0;i &lt; 10;i++){</p>
<p>​          rw.Read();</p>
<p>​        }</p>
<p>​      }</p>
<p>​    },”读线程”).start();</p>
<p>​    new Thread(new Runnable() {</p>
<p>​      @Override</p>
<p>​      public void run() {</p>
<p>​        rw.Write(12);</p>
<p>​      }</p>
<p>​    },”写线程”).start();</p>
<p>  }</p>
<p>}</p>
<p>class Rw{</p>
<p>  private int num = 0;</p>
<p>  ReadWriteLock rwl = new ReentrantReadWriteLock(); </p>
<p>  //这个函数是可以传参的，默认为false定义的是不公平锁，true定义的是公平锁，前者拥有更高的吞吐量</p>
<p>  public void Read(){</p>
<p>​    rwl.readLock().lock();</p>
<p>​    System.out.println(Thread.currentThread().getName()+”  “+num);</p>
<p>​    rwl.readLock().unlock();</p>
<p>  }</p>
<p>  public void Write(int num){</p>
<p>​    rwl.writeLock().lock();</p>
<p>​    this.num= num;</p>
<p>​    System.out.println(Thread.currentThread().getName()+”  “+num);</p>
<p>​    rwl.writeLock().unlock();</p>
<p>  }</p>
<p>}</p>
<p>函数式lambda编程：</p>
<p><img src="/" class="lazyload" data-src="/2020/04/28/juc/clip_image003.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png"  alt="img"></p>
<p>无参lambda</p>
<p><img src="/" class="lazyload" data-src="/2020/04/28/juc/clip_image004.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png"  alt="img"></p>
<p>有参lambda</p>
<p><img src="/" class="lazyload" data-src="/2020/04/28/juc/clip_image005.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png"  alt="img"></p>
<p>lambda表达式的标准格式：（不关注用什么对象来实现,可省略，可推导，凡是根据上下文推导出来的内容，都可以省略，接口有且只有一个抽象方法）</p>
<p>   <strong>a.一些参数</strong></p>
<p>   <strong>b.一个箭头，-&gt;,把参数传给方法体</strong></p>
<p>   <strong>c.一段代码</strong></p>
<p><strong>格式：（参数列表）-&gt;{重写的代码}</strong></p>
<p><strong>可以省略的内容：</strong></p>
<p><strong>1.（参数列表）：括号中**</strong>参数列表的数据类型<strong>**，可以省略不写</strong></p>
<p><strong>2.（参数列表）：括号中的**</strong>参数如果只有一个<strong>**，那么类型和（）都可以省略</strong></p>
<p><strong>3.（一些代码）：如果{}中的**</strong>代码只有一行<strong><strong>，无论是否有返回值，都可以省略{}，return,分号（</strong></strong>三个一起省略<strong>**）</strong></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">李上</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/04/28/juc/">http://yoursite.com/2020/04/28/juc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">定不辱使命</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/06/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java核心卷——基础知识</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/28/springmvc/"><img class="next_cover lazyload" data-src="/img/springmvc.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring MVC学习笔记</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 李上</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>