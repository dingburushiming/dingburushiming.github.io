<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《Java核心卷一》读书笔记 | 定不辱使命</title><meta name="description" content="《Java核心卷一》读书笔记"><meta name="keywords" content="基础知识"><meta name="author" content="李上"><meta name="copyright" content="李上"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《Java核心卷一》读书笔记"><meta name="twitter:description" content="《Java核心卷一》读书笔记"><meta name="twitter:image" content="http://yoursite.com/img/JavaCore.jpg"><meta property="og:type" content="article"><meta property="og:title" content="《Java核心卷一》读书笔记"><meta property="og:url" content="http://yoursite.com/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><meta property="og:site_name" content="定不辱使命"><meta property="og:description" content="《Java核心卷一》读书笔记"><meta property="og:image" content="http://yoursite.com/img/JavaCore.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><link rel="prev" title="MySQL学习笔记" href="http://yoursite.com/2020/05/09/mysql/"><link rel="next" title="JUC(java.util.concurrent)学习笔记" href="http://yoursite.com/2020/04/28/juc/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java的基本程序设计结构"><span class="toc-number">1.</span> <span class="toc-text">Java的基本程序设计结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整型"><span class="toc-number">1.1.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浮点类型"><span class="toc-number">1.1.2.</span> <span class="toc-text">浮点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char类型"><span class="toc-number">1.1.3.</span> <span class="toc-text">char类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unicode和char类型"><span class="toc-number">1.1.4.</span> <span class="toc-text">Unicode和char类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boolean类型"><span class="toc-number">1.1.5.</span> <span class="toc-text">boolean类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-number">1.1.6.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量初始化"><span class="toc-number">1.1.7.</span> <span class="toc-text">变量初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常量"><span class="toc-number">1.1.8.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符"><span class="toc-number">1.1.9.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数学函数与常量"><span class="toc-number">1.1.10.</span> <span class="toc-text">数学函数与常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数值类型之间的转换"><span class="toc-number">1.1.11.</span> <span class="toc-text">数值类型之间的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强制类型转换"><span class="toc-number">1.1.12.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结合赋值和运算符"><span class="toc-number">1.1.13.</span> <span class="toc-text">结合赋值和运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自增自减运算符"><span class="toc-number">1.1.14.</span> <span class="toc-text">自增自减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关系和boolean运算符"><span class="toc-number">1.1.15.</span> <span class="toc-text">关系和boolean运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算符"><span class="toc-number">1.1.16.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#括号与运算符级别"><span class="toc-number">1.1.17.</span> <span class="toc-text">括号与运算符级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">1.2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#子串"><span class="toc-number">1.2.1.</span> <span class="toc-text">子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拼接"><span class="toc-number">1.2.2.</span> <span class="toc-text">拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检查字符串是否相等"><span class="toc-number">1.2.3.</span> <span class="toc-text">检查字符串是否相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字串与Null值"><span class="toc-number">1.2.4.</span> <span class="toc-text">字串与Null值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#码点与代码单元"><span class="toc-number">1.2.5.</span> <span class="toc-text">码点与代码单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建字符串"><span class="toc-number">1.2.6.</span> <span class="toc-text">构建字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入输出"><span class="toc-number">1.3.</span> <span class="toc-text">输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读取输入"><span class="toc-number">1.3.1.</span> <span class="toc-text">读取输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式化输出"><span class="toc-number">1.3.2.</span> <span class="toc-text">格式化输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#控制流程"><span class="toc-number">1.4.</span> <span class="toc-text">控制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#块作用域"><span class="toc-number">1.4.1.</span> <span class="toc-text">块作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件语句"><span class="toc-number">1.4.2.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环"><span class="toc-number">1.4.3.</span> <span class="toc-text">循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大数值"><span class="toc-number">1.5.</span> <span class="toc-text">大数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">1.6.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-each循环"><span class="toc-number">1.6.1.</span> <span class="toc-text">for each循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组初始化以及匿名数组"><span class="toc-number">1.6.2.</span> <span class="toc-text">数组初始化以及匿名数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组拷贝"><span class="toc-number">1.6.3.</span> <span class="toc-text">数组拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行参数"><span class="toc-number">1.6.4.</span> <span class="toc-text">命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组排序"><span class="toc-number">1.6.5.</span> <span class="toc-text">数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机数"><span class="toc-number">1.6.6.</span> <span class="toc-text">随机数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象与类"><span class="toc-number">1.7.</span> <span class="toc-text">对象与类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象程序设计-OOP-的优点"><span class="toc-number">1.7.1.</span> <span class="toc-text">面向对象程序设计(OOP)的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类"><span class="toc-number">1.7.2.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类之间的关系"><span class="toc-number">1.7.3.</span> <span class="toc-text">类之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#依赖"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#聚合-关联"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">聚合&#x2F;关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时间类型Date"><span class="toc-number">1.8.</span> <span class="toc-text">时间类型Date</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalDate-LocalTime-LocalDateTime，Instant"><span class="toc-number">1.8.1.</span> <span class="toc-text">LocalDate,LocalTime,LocalDateTime，Instant</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalDate"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">LocalDate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalTime"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">LocalTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalDateTime"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">LocalDateTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instant"><span class="toc-number">1.8.1.4.</span> <span class="toc-text">Instant</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户自定义类"><span class="toc-number">1.9.</span> <span class="toc-text">用户自定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#封装的优点"><span class="toc-number">1.9.1.</span> <span class="toc-text">封装的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态域与静态方法"><span class="toc-number">1.10.</span> <span class="toc-text">静态域与静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态域"><span class="toc-number">1.10.1.</span> <span class="toc-text">静态域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态常量"><span class="toc-number">1.10.2.</span> <span class="toc-text">静态常量</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/JavaCore.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">定不辱使命</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">《Java核心卷一》读书笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-07 16:14:28"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-07</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-03 09:11:13"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-03</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="Java的基本程序设计结构"><a href="#Java的基本程序设计结构" class="headerlink" title="Java的基本程序设计结构"></a>Java的基本程序设计结构</h1><p>Java区分大小写，出现大小写错误程序将无法运行</p>
<p>Java应用程序中的全部内容都必须放置在类中</p>
<p>关键字class后面必须紧跟类名，Java定义类名的规则很宽松，名字必须 以字母开头，后面可以跟字母和数字的任意组合，长度上基本没有限制，但是不能使用Java保留字</p>
<p>标准的命名规范是：类名以大写字母开头的名词，如果有多个单词，每个单词的第一个字母都应该大写(CamelCase骆驼命名法)</p>
<p>源代码的文件名必须与公共类的名字相同，并用.java作为扩展名</p>
<p>main必须是public的，也必须是静态的，每个Java程序都必须有一个main方法</p>
<p>main方法正常退出的退出代码为0，通过System.exit()可以设置退出代码</p>
<p>Java编译器会忽略空白符，如果需要可以将一条语句写在多行上</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java是强类型语言，每一个变量必须声明类型，Java中一共有8种基本类型，四种整形，两种浮点型，一种表示Unicode编码的字符类型char，一种表示真假的Boolean类型</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/001.png"  alt="Java核心卷——基础知识"></p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>长整型数值有一个后缀L,十六进制有一个前缀OX,八进制有一个前缀0,二进制有一个前缀0B</p>
<p>Java7开始支持数字字面量加下划线，目的在于易读，Java编译器会去除这些下划线,例如1_000_000是完全等价于1000000</p>
<p>Java没有任何无符号unsigned形式的int,long,short,byte类型</p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>浮点类型用于表示有小数部分的数值</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/002.png"  alt="Java核心卷——基础知识"></p>
<p>double的精度是float的两倍，被称之为双精度数值</p>
<p>float类型的数值有一个后缀F或f，例如3.14F；double类型的数值有一个后缀3.14D。没有后缀F的浮点数值3.14默认为double类型</p>
<p>浮点数值计算都遵循IEEE 754规范，有三个特殊的浮点数值用于表示溢出和出错情况，例如0/0，负数的平方根结果都为NaN</p>
<p>1.正无穷大</p>
<p>2.负无穷大</p>
<p>3.NaN(不是一个数字)</p>
<p>可以通过Double.isNan()方法判断非数值</p>
<p>浮点数值不能用于精确计算，sout(2.0-1.1)的值不是0.9而是0.8999999999999999，这种舍入误差的主要原因是因为浮点数值采用二进制系统表示，而二进制系统无法精确到1/10，就像十进制无法精确到1/3一样，数值计算不允许有任何舍入误差应该使用BigDecimal类</p>
<h3 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h3><p>Unicode字符有的需要一个char值描述，有的需要两个</p>
<p>char类型的字面量值需要被单引号括起来，例如‘A’是编码值为65所对应的字符常量</p>
<p>\u是转义字符，转义序列可以出现在引号内(单双即可)</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/003.png"  alt="Java核心卷——基础知识"></p>
<p>“\u022+\u0022”不是“+” 字符串，而是” “+” “两个空字符相加</p>
<p>不要将转义序列放到注释中，可能导致错误。例如\u00A0在编译时会被替换成一个换行符又例如//C:\users也会产生一个语法错误，因为\u后面并未跟着4个16进制数</p>
<h3 id="Unicode和char类型"><a href="#Unicode和char类型" class="headerlink" title="Unicode和char类型"></a>Unicode和char类型</h3><p>编码标准：美国的ASCII，西欧的ISO 8859-1,俄罗斯的KOI-8,中国的GB 18030和BIG-5</p>
<p>不同编码标准产生的问题：</p>
<p>1.任意确定的代码在不同编码环境下可能对应不同的字母</p>
<p>2.同一字符，不同的编码标准使用的字节长度可能不同</p>
<p>Unicode打破了传统字符编码机制的限制，Unicode俗称万国码，描述了所有字符，常见的类型又UTF-8,解决了上述问题</p>
<h3 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h3><p>boolean类型有两个值：false,true,整型与布尔值之间不能相互转换</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Java变量必须是字母开头并且由字母和数字构成，这里的字母不仅仅包含26个英文字符，还有Unicode中的字符，下划线_,圆周率都属于Java广义范围上的字母</p>
<p>变量名中所有的字符都是有意义的，并且大小写敏感，变量名的长度基本没有限制</p>
<p>可以通过Character类的isJavaIdenifierStart和isJavaIdentierPart方法来检查那些Unicode字符属于Java中的”字母“</p>
<p>尽管$属于Java字母，但是它只用于在Java编译器或其他生成工具中使用</p>
<p>可以在一行中声明多个变量，例如int i,j;但是不提倡，逐一声明变量可以提高程序的可读性</p>
<h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>变量的声明尽可能的靠近该变量第一次使用的地方，这是一种良好的编程习惯</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>final声明后只能被赋值一次，赋值后就不可再更改了，一般常量名使用全大写</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>当参与/运算 两个操作数都是整数时，表示整数除法，否则表示浮点除法</p>
<p>整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NAN结果</p>
<p>浮点型数据计算 的准确性是很难保证的，因为不同芯片计算时使用的寄存器位数存在差异，使用strictfp关键字s可以确保精确计算</p>
<h3 id="数学函数与常量"><a href="#数学函数与常量" class="headerlink" title="数学函数与常量"></a>数学函数与常量</h3><p>幂运算Math.pow(x,a)</p>
<p>两个参数是double类型，结果也是double类型</p>
<h3 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h3><p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/005.png"  alt="Java核心卷——基础知识"></p>
<p>实心箭头表示不会丢失精度，虚线箭头表示可能会丢失精度</p>
<p>大转小会损失精度，小转大不会损失精度</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/006.png"  alt="Java核心卷——基础知识"></p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>低精度转向高精度需要强转，方法是在()中给出想要转换的目标类型</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/007.png"  alt="Java核心卷——基础知识"></p>
<p>浮点型舍入运算，round舍入操作的结果为long</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/008.png"  alt="Java核心卷——基础知识"></p>
<p>注意：将一个数值强行转换为另外一个数值，如果超出了目标类型的表示范围，结果就会截断成一个完全不同的值，例如(byte)300的实际值为44</p>
<h3 id="结合赋值和运算符"><a href="#结合赋值和运算符" class="headerlink" title="结合赋值和运算符"></a>结合赋值和运算符</h3><p>x+=3.5等价于x=(int)(x+3.5)</p>
<p>当两个操作数不同时，会发生强制转换</p>
<h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>n++</p>
<p>n不能是常量</p>
<p>n++，先用后加；++n,先加后用</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/009.png"  alt="Java核心卷——基础知识"></p>
<p>不建议在表达式中使用++,会导致bug且让人困惑</p>
<h3 id="关系和boolean运算符"><a href="#关系和boolean运算符" class="headerlink" title="关系和boolean运算符"></a>关系和boolean运算符</h3><p>&amp;&amp;逻辑与</p>
<p>||逻辑或</p>
<p>！逻辑非</p>
<p>&amp;&amp;和||是按照短路的方式来求值的，如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了</p>
<p>例如x!=0&amp;&amp;1/0&gt;x+y,如果x=0那么x!=0的值为false,也就不会执行1/0报异常</p>
<p>三元运算符?:</p>
<p>x &lt; y?x:y   会返回返回x,y中较小的那一个</p>
<p>三目运算符是有返回值的，x,y都必须是值，没有if语句灵活，主要用于判断赋值</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>&amp;(“and”)   |(“or”)   ^(“xor”)   ~(“not”)</p>
<p>位运算符可以使用掩码技术得到整数中的各个位</p>
<p>|和&amp;用于计算布尔值时，与||和&amp;&amp;相似，但是不采用短路的方式来求值，也就是说计算结果之前两个操作数都需要计算</p>
<p>&lt;&lt;,&gt;&gt;将位模式右移或者左移,用符号位填充高位，&gt;&gt;&gt;会用0填充高位，没有&lt;&lt;&lt;</p>
<h3 id="括号与运算符级别"><a href="#括号与运算符级别" class="headerlink" title="括号与运算符级别"></a>括号与运算符级别</h3><p>不使用圆括号，就按照给出的运算符优先级次序进行计算，同一个级别的运算符按照从左到右的次序进行计算(右结合运算符除外)。例如</p>
<p>a&amp;&amp;b||c  </p>
<p>&amp;&amp;的优先级高于||，上述表达式等价于(a&amp;&amp;b)||c</p>
<p>+=是右结合运算符,即从右到左的运算顺序</p>
<p>a+=b+=c等价于a+=(b+=c)</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/010.png"  alt="Java核心卷——基础知识"></p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/011.png"  alt="Java核心卷——基础知识"></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Java没有内置的字符串类型，而是提供了一个预定义类String</p>
<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><p>substring(a,b)</p>
<p>a起始截取位置,b截取长度</p>
<h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>Java允许通过+拼接两个字符串</p>
<p>当一个字符串和一个非字符串的值进行拼接时，后者被转换成字符串</p>
<p>任何一个Java对象都可以转换成字符串</p>
<p>如果需要把多个字符串放在一起，用一个定界符/分隔，可以使用静态join方法</p>
<p>String all = String.join(“/“,”s”,”m”,”l”);</p>
<h3 id="检查字符串是否相等"><a href="#检查字符串是否相等" class="headerlink" title="检查字符串是否相等"></a>检查字符串是否相等</h3><p>使用equals方法检测两个字符串是否相等</p>
<p>检测两个字符串是否相等且不区分大小写，可以使用equalsIgnoreCase方法</p>
<p>不能用==比较两个字符串是否相等，==只能比较两个字符串是否在同一个位置。虽然在同一个位置的字符串必然是相等的，但是不同位置的字符串也可能是相同的，==只能判断位置相同，不能判断字符串相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String greeting &#x3D; &quot;Hello&quot;;</span><br><span class="line">System.out.println(greeting &#x3D;&#x3D; &quot;Hello&quot;);&#x2F;&#x2F;true</span><br><span class="line">System.out.println(greeting.substring(0, 3) &#x3D;&#x3D; &quot;Hel&quot;);&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p>Java虚拟机中，字符串常量是共享的，而+和substring等操作产生的结果不是共享的，所以不要使用==测试字符串的相等性，以免出现bug</p>
<p>compareTo也能比较两个字符串是否相等，但是返回的结果是0，-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String greeting &#x3D; &quot;Hello&quot;;</span><br><span class="line">System.out.println(greeting.compareTo(&quot;Hello1&quot;));&#x2F;&#x2F;-1</span><br><span class="line">System.out.println(greeting.substring(0, 3).compareTo(&quot;Hel&quot;));&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>

<h3 id="字串与Null值"><a href="#字串与Null值" class="headerlink" title="字串与Null值"></a>字串与Null值</h3><p>字串“”是一个长度为0的字符串，可以调用一下方法检查一个字符串是否为空</p>
<p> if (str.length() == 0) 或 if (str.equals(“”)) </p>
<p>字符串值为null表示当前没有任何对象与该变量关联，使用以下方法检查一个字符串是否为null</p>
<p> if (str == null) </p>
<p>检查一个字符串既不是null也不是空字符串，使用以下方法</p>
<p> if (str != null &amp;&amp; str.length() != 0) </p>
<p>必须先检测字符串是否为null,因为null调用方法会报错</p>
<h3 id="码点与代码单元"><a href="#码点与代码单元" class="headerlink" title="码点与代码单元"></a>码点与代码单元</h3><p>Java字符串由char值序列组成</p>
<p>char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元</p>
<p>大多数Unicode字符使用一个代码单元，而辅助字符需要一对代码单元表示</p>
<p>length方法将返回采用UTF-16编码表示的给定字符串所需要的代码单元数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String greeting &#x3D; &quot;Hello&quot;;</span><br><span class="line">int n &#x3D; greeting.length。; &#x2F;&#x2F; is 5 .</span><br><span class="line">获取码点数量</span><br><span class="line">int cpCount &#x3D; greeting.codePointCount(0, greeting.length());</span><br><span class="line">返回某个码点的字符</span><br><span class="line">char first &#x3D; greeting.charAt(0)); &#x2F;&#x2F; first is &#39;H&#39;</span><br><span class="line">char last &#x3D; greeting.charAt(4); &#x2F;&#x2F; last is ’o’</span><br><span class="line">想得到第i个码点</span><br><span class="line">int index &#x3D; greeting.offsetByCodePoints(0, i);</span><br><span class="line">int cp &#x3D; greeting.codePointAt(index);</span><br></pre></td></tr></table></figure>

<p>当字符串中存在辅助字符时，遍历码点会出现问题，最好的方式是将字符串转换成一个数组进行操作？？</p>
<h3 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h3><p>当一个字符串由多个短字符串拼接而成时，不要使用String对象，String对象每次拼接都会产生一个新的对象，耗时且浪费时间。使用StringBuilder可以避免这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构建一个空的字符串构建器</span><br><span class="line">StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line">每次拼接调用append方法</span><br><span class="line">builder.append(ch); &#x2F;&#x2F; appends a single character</span><br><span class="line">bui1der.append(str); &#x2F;&#x2F; appends a string</span><br><span class="line">需要完成字符串时就调用同String()方法</span><br><span class="line">String completedString &#x3D; builder.toString();</span><br></pre></td></tr></table></figure>

<p>StringBuilder是StringBuffer的前身(功能基本一样)，后者效率稍低但是允许采用多线程的方式执行添加或删除字符的操作(线程安全)，如果是单线程程序应当使用StringBuilder</p>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造Scanner对象并于标准输入流System.in关联</span><br><span class="line">Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">nextLine输入一行</span><br><span class="line">System.out.println(&quot;What is your name?&quot;);</span><br><span class="line">String name &#x3D; in.nextLine();</span><br><span class="line">System.out.println(name);</span><br><span class="line">读取一个单词</span><br><span class="line">String firstName &#x3D; in.next();</span><br><span class="line">读取一个整数</span><br><span class="line">int age &#x3D; in.nextlnt();</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">double x &#x3D; 10000.0 &#x2F; 3.0;</span><br><span class="line">System.out.println(x);&#x2F;&#x2F;3333.3333333333335</span><br><span class="line"></span><br><span class="line">用八个字符的宽度和小数点后三个字符长度的精度打印x</span><br><span class="line">打印出一个空格和七个字符？？？</span><br><span class="line">System.out.printf(&quot;%8.3f&quot;,x);&#x2F;&#x2F;3333.333</span><br><span class="line"></span><br><span class="line">printf中使用多个参数</span><br><span class="line">System.out.printf(&quot;Hello, %s,Next year, you&#39;ll be %d&quot;, name, age);</span><br><span class="line">&#x2F;&#x2F;Hello, lishang,Next year, you&#39;ll be 20</span><br></pre></td></tr></table></figure>

<p>每一个以%字符开始的格式说明符都用相应的参数替换，不同的字符表示不同的数值类型</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/012.png"  alt="Java核心卷——基础知识"></p>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>指由一对大括号括起来的若干条简单的Java语句，块确定了变量的作用域</p>
<p>块与块可以相互嵌套，但是嵌套的块中不能定义同名的变量</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">switch (ch) &#123;</span><br><span class="line">         case &#39;B&#39;:</span><br><span class="line">            System.out.println(&quot;case one&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case &#39;A&#39;:</span><br><span class="line">            System.out.println(&quot;case two&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case &#39;C&#39;:</span><br><span class="line">            System.out.println(&quot;case three&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">         	break;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(condition)&#123;</span><br><span class="line">   &#x2F;&#x2F;执行语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line">   &#x2F;&#x2F;执行语句</span><br><span class="line">&#125;while(condition)</span><br></pre></td></tr></table></figure>

<h2 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h2><p>BigInteger类实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算</p>
<p>使用静态的valueOf方法可以将普通的数值转换为大数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a &#x3D; BigInterger.valueOf(100);</span><br></pre></td></tr></table></figure>

<p>不能使用常见的算数运算符(+,-*,/)处理大数值，需要使用大数值类的add和multiply方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Biglnteger c &#x3D; a.add(b); &#x2F;&#x2F; c &#x3D; a + b</span><br><span class="line">Biglnteger d &#x3D; c.multiply(b.add(Biglnteger.val ueOf(2))); &#x2F;&#x2F; d &#x3D; c * (b + 2)</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在声明数组之前，需要指出数组类型和数组变量的名字</p>
<p>int[] a和int a[]两种声明方式是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] a &#x3D; new int[10];&#x2F;&#x2F;数组的长度必须指定</span><br></pre></td></tr></table></figure>

<p>创建一个数字数组时，所有元素都初始化为0，boolean数组的元素都会初始化为false,对象数组的元素初始化为一个特殊值null(表示这些元素还没存放任何对象)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] names &#x3D; new String[10];&#x2F;&#x2F;字符串数组内的每个元素都是null</span><br></pre></td></tr></table></figure>

<p>数组一旦创建就不能再改变其长度，如果需要频繁扩展数组的大小，应该使用数组链表</p>
<h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h3><p>可以处理任意集合，遍历整个集合，不需要使用下标值去寻值</p>
<p>如果不希望遍历集合中的每个元素，或者循环内部需要使用下标值，还是用for循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] names &#x3D; new String[10];</span><br><span class="line">&#x2F;&#x2F;将数组变成字符串打印输出</span><br><span class="line">System.out.println(Arrays.toString(names));</span><br><span class="line">&#x2F;&#x2F;没有foreach,通过for实现</span><br><span class="line">for(String name:names)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组初始化以及匿名数组"><a href="#数组初始化以及匿名数组" class="headerlink" title="数组初始化以及匿名数组"></a>数组初始化以及匿名数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化简化方式</span><br><span class="line">int[] smallPrimes &#x3D; &#123; 2, 3, 5, 7, 11, 13 &#125;;</span><br><span class="line">&#x2F;&#x2F;可以创建一个匿名数组对象，需要操作才能不报错(返回或者打印)</span><br><span class="line">new int[] &#123; 17, 19, 23, 29, 31, 37 &#125;;</span><br></pre></td></tr></table></figure>

<p>Java中允许数组长度为0，在编写一个结果为数组的方法时，如果碰巧为空，可以创建一个长度为0的数组</p>
<p>数组长度为0与null不同</p>
<h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><p>将一个数组变量拷贝给另外一个数组变量，两个变量将引用同一个数组</p>
<p>如果希望将一个数组的所有值拷贝到一个新数组中去，就要使用Arrays类的copyOf方法。copiedLuckyNumbers是新数组,newLength是新数组长度，luckyNumbers是旧数组，可以通过copyOf方法对数组进行扩容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] copiedLuckyNumbers &#x3D; Arrays.copyOf(luckyNumbers,newLength);</span><br></pre></td></tr></table></figure>

<p>拷贝后新数组多余的元素将会被类型默认值填充，如果长度小于原数组的长度，则只拷贝最前面的数据元素</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>主函数中的String[] args接收的就是命令行参数</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>sort可以通过快排对数组进行排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] a &#x3D; new int[]&#123;3,2,1&#125;;</span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure>

<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>random()可以得到从[0-1)之间的随机浮点数，用n乘以这个浮点数，可以得到[0,n)之间的一个随机数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.random()*100);</span><br></pre></td></tr></table></figure>

<h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><h3 id="面向对象程序设计-OOP-的优点"><a href="#面向对象程序设计-OOP-的优点" class="headerlink" title="面向对象程序设计(OOP)的优点"></a>面向对象程序设计(OOP)的优点</h3><p>类包含方法，简化开发流程，易于程序员掌握,找到问题</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类的三大特性：继承，多态，封装</p>
<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另外一个类(耦合比较高，不建议使用)，依赖就是调用的意思</p>
<h4 id="聚合-关联"><a href="#聚合-关联" class="headerlink" title="聚合/关联"></a>聚合/关联</h4><p>一个类包含包含另外一个类</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/012.png"  alt="Java核心卷——基础知识"></p>
<h2 id="时间类型Date"><a href="#时间类型Date" class="headerlink" title="时间类型Date"></a>时间类型Date</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;可以指定不同格式的时间</span><br><span class="line">SimpleDateFormat df2&#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">df1.format(new Date());</span><br></pre></td></tr></table></figure>

<h3 id="LocalDate-LocalTime-LocalDateTime，Instant"><a href="#LocalDate-LocalTime-LocalDateTime，Instant" class="headerlink" title="LocalDate,LocalTime,LocalDateTime，Instant"></a>LocalDate,LocalTime,LocalDateTime，Instant</h3><p>Date一般情况下会使用 SimpleDateFormat 对时间进行格式化，但 SimpleDateFormat 是线程不安全的，应该使用Java8提供的全新的日期和时间API,LocalDateTime=LocalDate+LocalTime</p>
<p> 和<code>SimpleDateFormat</code>相比，<code>DateTimeFormatter</code>是线程安全的 </p>
<p>LocalDate,LocalTime,LocalDateTime,Instant四个对象为不可变对象，修改这些对象会返回一个副本</p>
<h4 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取当前年月日</span><br><span class="line">LocalDate localDate &#x3D; LocalDate.now();</span><br><span class="line">&#x2F;&#x2F;构造指定的年月日</span><br><span class="line">LocalDate localDate1 &#x3D; LocalDate.of(2019, 9, 10);</span><br><span class="line">&#x2F;&#x2F;获取年</span><br><span class="line">int year &#x3D; localDate.getYear();</span><br><span class="line">int year1 &#x3D; localDate.get(ChronoField.YEAR);</span><br><span class="line">&#x2F;&#x2F;获取月</span><br><span class="line">Month month &#x3D; localDate.getMonth();</span><br><span class="line">int month1 &#x3D; localDate.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line">&#x2F;&#x2F;获取日</span><br><span class="line">int day &#x3D; localDate.getDayOfMonth();</span><br><span class="line">int day1 &#x3D; localDate.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line">&#x2F;&#x2F;获取星期</span><br><span class="line">DayOfWeek dayOfWeek &#x3D; localDate.getDayOfWeek();</span><br><span class="line">int dayOfWeek1 &#x3D; localDate.get(ChronoField.DAY_OF_WEEK);</span><br><span class="line">&#x2F;&#x2F;计算时间，例如当前时间的第一天</span><br><span class="line">LocalDate localDate &#x3D; LocalDate.now();</span><br><span class="line">LocalDate localDate1 &#x3D; localDate.with(firstDayOfYear());</span><br><span class="line">&#x2F;&#x2F;格式化时间</span><br><span class="line">LocalDate localDate &#x3D; LocalDate.of(2019, 9, 10);</span><br><span class="line">String s1 &#x3D; localDate.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 &#x3D; localDate.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">&#x2F;&#x2F;自定义格式化</span><br><span class="line">DateTimeFormatter dateTimeFormatter &#x3D;   DateTimeFormatter.ofPattern(&quot;dd&#x2F;MM&#x2F;yyyy&quot;);</span><br><span class="line">String s3 &#x3D; localDate.format(dateTimeFormatter);</span><br></pre></td></tr></table></figure>

<h4 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建LocalTime</span><br><span class="line">LocalTime localTime &#x3D; LocalTime.of(13, 51, 10);</span><br><span class="line">LocalTime localTime1 &#x3D; LocalTime.now();</span><br><span class="line">&#x2F;&#x2F;获取时分秒</span><br><span class="line">&#x2F;&#x2F;获取小时</span><br><span class="line">int hour &#x3D; localTime.getHour();</span><br><span class="line">int hour1 &#x3D; localTime.get(ChronoField.HOUR_OF_DAY);</span><br><span class="line">&#x2F;&#x2F;获取分</span><br><span class="line">int minute &#x3D; localTime.getMinute();</span><br><span class="line">int minute1 &#x3D; localTime.get(ChronoField.MINUTE_OF_HOUR);</span><br><span class="line">&#x2F;&#x2F;获取秒</span><br><span class="line">int second &#x3D; localTime.getMinute();</span><br><span class="line">int second1 &#x3D; localTime.get(ChronoField.SECOND_OF_MINUTE);</span><br></pre></td></tr></table></figure>

<h4 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建LocalDateTime</span><br><span class="line">LocalDateTime localDateTime &#x3D; LocalDateTime.now();</span><br><span class="line">LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2019, Month.SEPTEMBER, 10, 14, 46, 56);</span><br><span class="line">LocalDateTime localDateTime2 &#x3D; LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime3 &#x3D; localDate.atTime(localTime);</span><br><span class="line">LocalDateTime localDateTime4 &#x3D; localTime.atDate(localDate);</span><br><span class="line">&#x2F;&#x2F;获取LocalDate</span><br><span class="line">LocalDate localDate2 &#x3D; localDateTime.toLocalDate();</span><br><span class="line">&#x2F;&#x2F;获取LocalTime</span><br><span class="line">LocalTime localTime2 &#x3D; localDateTime.toLocalTime();</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime &#x3D; LocalDateTime.of(2019, Month.SEPTEMBER, 10,</span><br><span class="line">              14, 46, 56);</span><br><span class="line">&#x2F;&#x2F;增加一年</span><br><span class="line">localDateTime &#x3D; localDateTime.plusYears(1);</span><br><span class="line">localDateTime &#x3D; localDateTime.plus(1, ChronoUnit.YEARS);</span><br><span class="line">&#x2F;&#x2F;减少一个月</span><br><span class="line">localDateTime &#x3D; localDateTime.minusMonths(1);</span><br><span class="line">localDateTime &#x3D; localDateTime.minus(1, ChronoUnit.MONTHS); </span><br><span class="line">&#x2F;&#x2F;修改年为2019</span><br><span class="line">localDateTime &#x3D; localDateTime.withYear(2020);</span><br><span class="line">&#x2F;&#x2F;修改为2022</span><br><span class="line">localDateTime &#x3D; localDateTime.with(ChronoField.YEAR, 2022);</span><br></pre></td></tr></table></figure>

<h4 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建Instant对象</span><br><span class="line">Instant instant &#x3D; Instant.now();</span><br><span class="line">&#x2F;&#x2F;获取秒数</span><br><span class="line">long currentSecond &#x3D; instant.getEpochSecond();</span><br><span class="line">&#x2F;&#x2F;获取毫秒数</span><br><span class="line">long currentMilli &#x3D; instant.toEpochMilli();</span><br><span class="line">System.currentTimeMillis()</span><br></pre></td></tr></table></figure>

<h2 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h2><p>文件名必须与public类的名字相匹配，在一个源文件中，只能有一个公有类，但可以有任意数量的非公有类</p>
<p>在编译有多个类的文件时，编译器将在目录下创建相应数量的.class类文件</p>
<p>类中的变量用private，方法用public可以更好的保护类的封装性</p>
<p>类的构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置变量数据的目的</p>
<p>构造器没有返回值</p>
<p>不能在构造器中定义与类变量同名的局部变量，构造器中的变量会将类变量屏蔽</p>
<p>一个类方法可以有隐式参数和显式参数两种类型，显式参数就是写在方法中的参数；隐式参数是this.salary之类的类参数</p>
<p>私有方法只能类内部调用，类设计者可以确信删除该方法不会对本类以外的类产生影响</p>
<h3 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h3><p>类变量如果是public，那么可以直接通过类对象调用</p>
<p>使用私有变量，公有setter,getter方法的好处</p>
<p>1.是程序内聚性更好，也更安全</p>
<p>2.setter可以对数据进行错误检查在内的额外操作</p>
<p>不要编写返回引用可变对象的访问器方法，可变变量自身的方法会破坏类对象的封装性，如果需要该类方法，可以返回克隆对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    private Date time;</span><br><span class="line">    public test(Date time) &#123;this.time &#x3D; time; &#125;</span><br><span class="line">    </span><br><span class="line">    public Date getTime() &#123;</span><br><span class="line">    &#x2F;&#x2F;正确写法</span><br><span class="line">    return (Date) time.clone();</span><br><span class="line">    &#x2F;&#x2F;错误写法</span><br><span class="line">    return time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class chuli&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Date d &#x3D; new test(new Date()).getTime();</span><br><span class="line">        &#x2F;&#x2F;如果getTime方法不返回克隆值，Date的setTime方法会破坏time变量的封装性</span><br><span class="line">        d.setTime(12323466446L);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态域与静态方法"><a href="#静态域与静态方法" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h2><h3 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h3><p>每个类只能有一个静态域(static)，静态域是属于类的；实例域则是每个类对象都有一个</p>
<h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">李上</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">http://yoursite.com/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">定不辱使命</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post_share"><div class="social-share" data-image="/img/designpatterns.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/09/mysql/"><img class="prev_cover lazyload" data-src="/img/mysql.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL学习笔记</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/28/juc/"><img class="next_cover lazyload" data-src="/img/juc.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC(java.util.concurrent)学习笔记</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 李上</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>