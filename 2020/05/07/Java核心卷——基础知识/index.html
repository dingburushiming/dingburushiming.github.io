<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《Java核心卷一》读书笔记 | 定不辱使命</title><meta name="description" content="《Java核心卷一》读书笔记"><meta name="keywords" content="基础知识"><meta name="author" content="李上"><meta name="copyright" content="李上"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《Java核心卷一》读书笔记"><meta name="twitter:description" content="《Java核心卷一》读书笔记"><meta name="twitter:image" content="http://yoursite.com/img/JavaCore.jpg"><meta property="og:type" content="article"><meta property="og:title" content="《Java核心卷一》读书笔记"><meta property="og:url" content="http://yoursite.com/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><meta property="og:site_name" content="定不辱使命"><meta property="og:description" content="《Java核心卷一》读书笔记"><meta property="og:image" content="http://yoursite.com/img/JavaCore.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><link rel="prev" title="MySQL学习笔记" href="http://yoursite.com/2020/05/09/mysql/"><link rel="next" title="JUC(java.util.concurrent)学习笔记" href="http://yoursite.com/2020/04/28/juc/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java的基本程序设计结构"><span class="toc-number">1.</span> <span class="toc-text">Java的基本程序设计结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#整型"><span class="toc-number">1.1.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浮点类型"><span class="toc-number">1.1.2.</span> <span class="toc-text">浮点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char类型"><span class="toc-number">1.1.3.</span> <span class="toc-text">char类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unicode和char类型"><span class="toc-number">1.1.4.</span> <span class="toc-text">Unicode和char类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boolean类型"><span class="toc-number">1.1.5.</span> <span class="toc-text">boolean类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-number">1.1.6.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量初始化"><span class="toc-number">1.1.7.</span> <span class="toc-text">变量初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常量"><span class="toc-number">1.1.8.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符"><span class="toc-number">1.1.9.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数学函数与常量"><span class="toc-number">1.1.10.</span> <span class="toc-text">数学函数与常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数值类型之间的转换"><span class="toc-number">1.1.11.</span> <span class="toc-text">数值类型之间的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强制类型转换"><span class="toc-number">1.1.12.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结合赋值和运算符"><span class="toc-number">1.1.13.</span> <span class="toc-text">结合赋值和运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自增自减运算符"><span class="toc-number">1.1.14.</span> <span class="toc-text">自增自减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关系和boolean运算符"><span class="toc-number">1.1.15.</span> <span class="toc-text">关系和boolean运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算符"><span class="toc-number">1.1.16.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#括号与运算符级别"><span class="toc-number">1.1.17.</span> <span class="toc-text">括号与运算符级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">1.2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#子串"><span class="toc-number">1.2.1.</span> <span class="toc-text">子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拼接"><span class="toc-number">1.2.2.</span> <span class="toc-text">拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检查字符串是否相等"><span class="toc-number">1.2.3.</span> <span class="toc-text">检查字符串是否相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字串与Null值"><span class="toc-number">1.2.4.</span> <span class="toc-text">字串与Null值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#码点与代码单元"><span class="toc-number">1.2.5.</span> <span class="toc-text">码点与代码单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建字符串"><span class="toc-number">1.2.6.</span> <span class="toc-text">构建字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入输出"><span class="toc-number">1.3.</span> <span class="toc-text">输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读取输入"><span class="toc-number">1.3.1.</span> <span class="toc-text">读取输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式化输出"><span class="toc-number">1.3.2.</span> <span class="toc-text">格式化输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#控制流程"><span class="toc-number">1.4.</span> <span class="toc-text">控制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#块作用域"><span class="toc-number">1.4.1.</span> <span class="toc-text">块作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件语句"><span class="toc-number">1.4.2.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环"><span class="toc-number">1.4.3.</span> <span class="toc-text">循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大数值"><span class="toc-number">1.5.</span> <span class="toc-text">大数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">1.6.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-each循环"><span class="toc-number">1.6.1.</span> <span class="toc-text">for each循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组初始化以及匿名数组"><span class="toc-number">1.6.2.</span> <span class="toc-text">数组初始化以及匿名数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组拷贝"><span class="toc-number">1.6.3.</span> <span class="toc-text">数组拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行参数"><span class="toc-number">1.6.4.</span> <span class="toc-text">命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组排序"><span class="toc-number">1.6.5.</span> <span class="toc-text">数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机数"><span class="toc-number">1.6.6.</span> <span class="toc-text">随机数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对象与类"><span class="toc-number">2.</span> <span class="toc-text">对象与类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象程序设计-OOP-的优点"><span class="toc-number">2.0.1.</span> <span class="toc-text">面向对象程序设计(OOP)的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类"><span class="toc-number">2.0.2.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类之间的关系"><span class="toc-number">2.0.3.</span> <span class="toc-text">类之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#依赖"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#聚合-关联"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">聚合&#x2F;关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承"><span class="toc-number">2.0.3.3.</span> <span class="toc-text">继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时间类型Date"><span class="toc-number">2.1.</span> <span class="toc-text">时间类型Date</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalDate-LocalTime-LocalDateTime，Instant"><span class="toc-number">2.1.1.</span> <span class="toc-text">LocalDate,LocalTime,LocalDateTime，Instant</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalDate"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">LocalDate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalTime"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">LocalTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalDateTime"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">LocalDateTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instant"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">Instant</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户自定义类"><span class="toc-number">2.2.</span> <span class="toc-text">用户自定义类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#封装的优点"><span class="toc-number">2.2.1.</span> <span class="toc-text">封装的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态域与静态方法"><span class="toc-number">2.3.</span> <span class="toc-text">静态域与静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态域"><span class="toc-number">2.3.1.</span> <span class="toc-text">静态域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态常量"><span class="toc-number">2.3.2.</span> <span class="toc-text">静态常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法"><span class="toc-number">2.3.3.</span> <span class="toc-text">静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用静态方法的场景"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">使用静态方法的场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂方法"><span class="toc-number">2.3.4.</span> <span class="toc-text">工厂方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NumberFormat类不使用构造器完成构造工作"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">NumberFormat类不使用构造器完成构造工作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法参数"><span class="toc-number">2.4.</span> <span class="toc-text">方法参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#按值调用"><span class="toc-number">2.4.1.</span> <span class="toc-text">按值调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按引用调用"><span class="toc-number">2.4.2.</span> <span class="toc-text">按引用调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中方法参数的使用情况"><span class="toc-number">2.4.3.</span> <span class="toc-text">Java中方法参数的使用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象构造"><span class="toc-number">2.4.4.</span> <span class="toc-text">对象构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重载"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认域初始化"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">默认域初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无参数的构造器"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">无参数的构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调用另一个构造器"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">调用另一个构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化块"><span class="toc-number">2.4.4.5.</span> <span class="toc-text">初始化块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#调用构造器后具体的处理步骤"><span class="toc-number">2.4.4.5.1.</span> <span class="toc-text">调用构造器后具体的处理步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象解析与finalize方法"><span class="toc-number">2.4.5.</span> <span class="toc-text">对象解析与finalize方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包"><span class="toc-number">2.5.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类的导入"><span class="toc-number">2.5.1.</span> <span class="toc-text">类的导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态导入"><span class="toc-number">2.5.2.</span> <span class="toc-text">静态导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将类放入包中"><span class="toc-number">2.5.3.</span> <span class="toc-text">将类放入包中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#警告"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">警告</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包作用域"><span class="toc-number">2.5.4.</span> <span class="toc-text">包作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类路径-这一块没看懂"><span class="toc-number">2.5.5.</span> <span class="toc-text">类路径(这一块没看懂)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为了使类能够被多个程序共享，需要做到以下几点："><span class="toc-number">2.5.5.1.</span> <span class="toc-text">为了使类能够被多个程序共享，需要做到以下几点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类路径示例"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">类路径示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档注释"><span class="toc-number">2.5.6.</span> <span class="toc-text">文档注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注释的插入"><span class="toc-number">2.5.6.1.</span> <span class="toc-text">注释的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类注释"><span class="toc-number">2.5.6.2.</span> <span class="toc-text">类注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法注释"><span class="toc-number">2.5.6.3.</span> <span class="toc-text">方法注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#域注释"><span class="toc-number">2.5.6.4.</span> <span class="toc-text">域注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通用注释"><span class="toc-number">2.5.6.5.</span> <span class="toc-text">通用注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#包与概述注释"><span class="toc-number">2.5.6.6.</span> <span class="toc-text">包与概述注释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类设计技巧"><span class="toc-number">2.5.7.</span> <span class="toc-text">类设计技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一定要保证数据私有"><span class="toc-number">2.5.7.1.</span> <span class="toc-text">一定要保证数据私有</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一定要对数据初始化"><span class="toc-number">2.5.7.2.</span> <span class="toc-text">一定要对数据初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不要在类中使用过多的基本类型"><span class="toc-number">2.5.7.3.</span> <span class="toc-text">不要在类中使用过多的基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不是所有的域都需要独立的域访问器和域更改器"><span class="toc-number">2.5.7.4.</span> <span class="toc-text">不是所有的域都需要独立的域访问器和域更改器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将职责过多的类进行分解"><span class="toc-number">2.5.7.5.</span> <span class="toc-text">将职责过多的类进行分解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类名和方法名要能够体现它们的职责"><span class="toc-number">2.5.7.6.</span> <span class="toc-text">类名和方法名要能够体现它们的职责</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优先使用不可变的类"><span class="toc-number">2.5.7.7.</span> <span class="toc-text">优先使用不可变的类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#继承-1"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类，超类和子类"><span class="toc-number">3.1.</span> <span class="toc-text">类，超类和子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义子类"><span class="toc-number">3.1.1.</span> <span class="toc-text">定义子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#覆盖方法"><span class="toc-number">3.1.2.</span> <span class="toc-text">覆盖方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子类构造器"><span class="toc-number">3.1.3.</span> <span class="toc-text">子类构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-number">3.1.4.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解方法调用"><span class="toc-number">3.1.5.</span> <span class="toc-text">理解方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻止继承：final类和方法"><span class="toc-number">3.1.6.</span> <span class="toc-text">阻止继承：final类和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强制类型转换-1"><span class="toc-number">3.1.7.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">3.1.8.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#受保护访问"><span class="toc-number">3.1.9.</span> <span class="toc-text">受保护访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-所有类的父类"><span class="toc-number">3.2.</span> <span class="toc-text">Object:所有类的父类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#equals方法"><span class="toc-number">3.2.1.</span> <span class="toc-text">equals方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals与-的区别"><span class="toc-number">3.2.2.</span> <span class="toc-text">equals与&#x3D;&#x3D;的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#对于字符串变量来说"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">对于字符串变量来说</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对于非字符串变量来说-对象"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">对于非字符串变量来说(对象)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#比较时的注意事项"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">比较时的注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相等测试与继承"><span class="toc-number">3.2.3.</span> <span class="toc-text">相等测试与继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#编写一个完美equals的建议"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">编写一个完美equals的建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#实现equals方法的一种常见的错误"><span class="toc-number">3.2.3.2.1.</span> <span class="toc-text">实现equals方法的一种常见的错误</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode方法"><span class="toc-number">3.2.4.</span> <span class="toc-text">hashCode方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashCode方法必须与equals方法保持一致"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">hashCode方法必须与equals方法保持一致</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重写hashCode方法"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">重写hashCode方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString方法"><span class="toc-number">3.2.5.</span> <span class="toc-text">toString方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组的toString方法"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">数组的toString方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">3.2.6.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#访问ArrayList元素"><span class="toc-number">3.2.6.1.</span> <span class="toc-text">访问ArrayList元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一举两得的方法"><span class="toc-number">3.2.6.2.</span> <span class="toc-text">一举两得的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象包装器与自动装箱"><span class="toc-number">3.2.7.</span> <span class="toc-text">对象包装器与自动装箱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自动装箱"><span class="toc-number">3.2.7.1.</span> <span class="toc-text">自动装箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数数量可变的方法"><span class="toc-number">3.2.8.</span> <span class="toc-text">参数数量可变的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举类"><span class="toc-number">3.2.9.</span> <span class="toc-text">枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#toString，valueOf，values"><span class="toc-number">3.2.9.1.</span> <span class="toc-text">toString，valueOf，values</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#枚举类构造函数"><span class="toc-number">3.2.9.2.</span> <span class="toc-text">枚举类构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射"><span class="toc-number">3.2.10.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Class类"><span class="toc-number">3.2.10.1.</span> <span class="toc-text">Class类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用反射分析类的能力"><span class="toc-number">3.2.10.2.</span> <span class="toc-text">利用反射分析类的能力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在运行时使用反射分析对象"><span class="toc-number">3.2.10.3.</span> <span class="toc-text">在运行时使用反射分析对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用反射编写泛型数组代码"><span class="toc-number">3.2.10.4.</span> <span class="toc-text">使用反射编写泛型数组代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#copyOf"><span class="toc-number">3.2.10.4.1.</span> <span class="toc-text">copyOf</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用任意方法？？？"><span class="toc-number">3.2.11.</span> <span class="toc-text">调用任意方法？？？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承的设计技巧"><span class="toc-number">3.3.</span> <span class="toc-text">继承的设计技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接口，lambda表达式于内部类"><span class="toc-number">4.</span> <span class="toc-text">接口，lambda表达式于内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-number">4.1.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接口与抽象类"><span class="toc-number">4.1.1.</span> <span class="toc-text">接口与抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#默认方法"><span class="toc-number">4.1.2.</span> <span class="toc-text">默认方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决默认方法冲突"><span class="toc-number">4.1.3.</span> <span class="toc-text">解决默认方法冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口示例"><span class="toc-number">4.2.</span> <span class="toc-text">接口示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的克隆"><span class="toc-number">4.2.1.</span> <span class="toc-text">对象的克隆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda表达式"><span class="toc-number">4.3.</span> <span class="toc-text">lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要引入lambda表达式"><span class="toc-number">4.3.1.</span> <span class="toc-text">为什么要引入lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda表达式式的语法"><span class="toc-number">4.3.2.</span> <span class="toc-text">lambda表达式式的语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式接口"><span class="toc-number">4.4.</span> <span class="toc-text">函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法引用"><span class="toc-number">4.4.1.</span> <span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造器引用"><span class="toc-number">4.4.2.</span> <span class="toc-text">构造器引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量作用域"><span class="toc-number">4.4.3.</span> <span class="toc-text">变量作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内部类"><span class="toc-number">4.5.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用内部类访问对象状态"><span class="toc-number">4.5.1.</span> <span class="toc-text">使用内部类访问对象状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类的特殊语法规则"><span class="toc-number">4.5.2.</span> <span class="toc-text">内部类的特殊语法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类是否有用，必要和安全？？？"><span class="toc-number">4.5.3.</span> <span class="toc-text">内部类是否有用，必要和安全？？？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部内部类"><span class="toc-number">4.5.4.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名内部类"><span class="toc-number">4.5.5.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态内部类"><span class="toc-number">4.6.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理？？？"><span class="toc-number">4.7.</span> <span class="toc-text">代理？？？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#何时使用代理"><span class="toc-number">4.7.1.</span> <span class="toc-text">何时使用代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建代理对象"><span class="toc-number">4.7.2.</span> <span class="toc-text">创建代理对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异常，断言和日志"><span class="toc-number">5.</span> <span class="toc-text">异常，断言和日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#异常分类"><span class="toc-number">5.1.</span> <span class="toc-text">异常分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RuntimeException异常"><span class="toc-number">5.1.1.</span> <span class="toc-text">RuntimeException异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO异常"><span class="toc-number">5.1.2.</span> <span class="toc-text">IO异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#声明受查异常"><span class="toc-number">5.2.</span> <span class="toc-text">声明受查异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何抛出异常"><span class="toc-number">5.2.1.</span> <span class="toc-text">如何抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建异常类"><span class="toc-number">5.2.2.</span> <span class="toc-text">创建异常类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#捕获异常"><span class="toc-number">5.3.</span> <span class="toc-text">捕获异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#捕获多个异常"><span class="toc-number">5.3.1.</span> <span class="toc-text">捕获多个异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#再次抛出异常与异常链"><span class="toc-number">5.3.2.</span> <span class="toc-text">再次抛出异常与异常链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally子句"><span class="toc-number">5.3.3.</span> <span class="toc-text">finally子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带资源的try语句"><span class="toc-number">5.3.4.</span> <span class="toc-text">带资源的try语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用异常机制的技巧"><span class="toc-number">5.3.5.</span> <span class="toc-text">使用异常机制的技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#异常处理不能代替简单的测试"><span class="toc-number">5.3.5.1.</span> <span class="toc-text">异常处理不能代替简单的测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不要过分地细分异常"><span class="toc-number">5.3.5.2.</span> <span class="toc-text">不要过分地细分异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用异常层次结构"><span class="toc-number">5.3.5.3.</span> <span class="toc-text">利用异常层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不要压制异常"><span class="toc-number">5.3.5.4.</span> <span class="toc-text">不要压制异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在检测错误时，严格要比放任好"><span class="toc-number">5.3.5.5.</span> <span class="toc-text">在检测错误时，严格要比放任好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不要羞于传递异常"><span class="toc-number">5.3.5.6.</span> <span class="toc-text">不要羞于传递异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#断言"><span class="toc-number">5.4.</span> <span class="toc-text">断言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型程序设计"><span class="toc-number">6.</span> <span class="toc-text">泛型程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要使用泛型程序设计"><span class="toc-number">6.1.</span> <span class="toc-text">为什么要使用泛型程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类型参数的好处"><span class="toc-number">6.1.1.</span> <span class="toc-text">类型参数的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义简单泛型类"><span class="toc-number">6.2.</span> <span class="toc-text">定义简单泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型方法"><span class="toc-number">6.3.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型变量的限定"><span class="toc-number">6.4.</span> <span class="toc-text">类型变量的限定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型擦除"><span class="toc-number">6.5.</span> <span class="toc-text">类型擦除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#翻译泛型表达式"><span class="toc-number">6.6.</span> <span class="toc-text">翻译泛型表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#翻译泛型方法"><span class="toc-number">6.7.</span> <span class="toc-text">翻译泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#约束与局限性"><span class="toc-number">6.8.</span> <span class="toc-text">约束与局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不能用基本类型实例化类型参数"><span class="toc-number">6.8.1.</span> <span class="toc-text">不能用基本类型实例化类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时类型查询只适用于原始类型"><span class="toc-number">6.8.2.</span> <span class="toc-text">运行时类型查询只适用于原始类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不能创建参数化类型的数组"><span class="toc-number">6.8.3.</span> <span class="toc-text">不能创建参数化类型的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Varargs警告"><span class="toc-number">6.8.4.</span> <span class="toc-text">Varargs警告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不能实例化类型变量"><span class="toc-number">6.8.5.</span> <span class="toc-text">不能实例化类型变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不能构造泛型数组"><span class="toc-number">6.8.6.</span> <span class="toc-text">不能构造泛型数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型类的静态上下文中类型变量无效"><span class="toc-number">6.8.7.</span> <span class="toc-text">泛型类的静态上下文中类型变量无效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不能抛出或捕获泛型类的实例"><span class="toc-number">6.8.8.</span> <span class="toc-text">不能抛出或捕获泛型类的实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可以消除对受查异常的检查"><span class="toc-number">6.8.9.</span> <span class="toc-text">可以消除对受查异常的检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意擦除后的冲突"><span class="toc-number">6.8.10.</span> <span class="toc-text">注意擦除后的冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型类型的继承规则"><span class="toc-number">6.9.</span> <span class="toc-text">泛型类型的继承规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合"><span class="toc-number">7.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java集合框架"><span class="toc-number">7.1.</span> <span class="toc-text">Java集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将集合的接口与实现分离"><span class="toc-number">7.1.1.</span> <span class="toc-text">将集合的接口与实现分离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#队列"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection接口"><span class="toc-number">7.1.2.</span> <span class="toc-text">Collection接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器"><span class="toc-number">7.1.3.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型实用方法"><span class="toc-number">7.1.4.</span> <span class="toc-text">泛型实用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合框架中的接口"><span class="toc-number">7.1.5.</span> <span class="toc-text">集合框架中的接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体的集合"><span class="toc-number">7.2.</span> <span class="toc-text">具体的集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-number">7.2.1.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList链表集合"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">LinkedList链表集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组列表"><span class="toc-number">7.2.2.</span> <span class="toc-text">数组列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#散列集"><span class="toc-number">7.2.3.</span> <span class="toc-text">散列集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树集"><span class="toc-number">7.2.4.</span> <span class="toc-text">树集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列与双端队列"><span class="toc-number">7.2.5.</span> <span class="toc-text">队列与双端队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优先级队列"><span class="toc-number">7.2.6.</span> <span class="toc-text">优先级队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#映射"><span class="toc-number">7.3.</span> <span class="toc-text">映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本映射操作"><span class="toc-number">7.3.1.</span> <span class="toc-text">基本映射操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新映射项"><span class="toc-number">7.3.2.</span> <span class="toc-text">更新映射项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#映射视图"><span class="toc-number">7.3.3.</span> <span class="toc-text">映射视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#弱散列映射"><span class="toc-number">7.3.4.</span> <span class="toc-text">弱散列映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链接散列集与映射"><span class="toc-number">7.3.5.</span> <span class="toc-text">链接散列集与映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举集和映射"><span class="toc-number">7.3.6.</span> <span class="toc-text">枚举集和映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标识散列映射"><span class="toc-number">7.3.7.</span> <span class="toc-text">标识散列映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#视图与包装器"><span class="toc-number">7.4.</span> <span class="toc-text">视图与包装器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#轻量级集合包装器"><span class="toc-number">7.4.1.</span> <span class="toc-text">轻量级集合包装器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子范围"><span class="toc-number">7.4.2.</span> <span class="toc-text">子范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法"><span class="toc-number">7.5.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#排序与混排"><span class="toc-number">7.5.1.</span> <span class="toc-text">排序与混排</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#部署Java应用程序"><span class="toc-number">8.</span> <span class="toc-text">部署Java应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAR文件"><span class="toc-number">8.1.</span> <span class="toc-text">JAR文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发"><span class="toc-number">9.</span> <span class="toc-text">并发</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/JavaCore.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">定不辱使命</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">《Java核心卷一》读书笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-07 16:14:28"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-07</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-14 15:24:02"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-14</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="Java的基本程序设计结构"><a href="#Java的基本程序设计结构" class="headerlink" title="Java的基本程序设计结构"></a>Java的基本程序设计结构</h1><p>Java区分大小写，出现大小写错误程序将无法运行</p>
<p>Java应用程序中的全部内容都必须放置在类中</p>
<p>关键字class后面必须紧跟类名，Java定义类名的规则很宽松，名字必须 以字母开头，后面可以跟字母和数字的任意组合，长度上基本没有限制，但是不能使用Java保留字</p>
<p>标准的命名规范是：类名以大写字母开头的名词，如果有多个单词，每个单词的第一个字母都应该大写(CamelCase骆驼命名法)</p>
<p>源代码的文件名必须与公共类的名字相同，并用.java作为扩展名</p>
<p>main必须是public的，也必须是静态的，每个Java程序都必须有一个main方法</p>
<p>main方法正常退出的退出代码为0，通过System.exit()可以设置退出代码</p>
<p>Java编译器会忽略空白符，如果需要可以将一条语句写在多行上</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java是强类型语言，每一个变量必须声明类型，Java中一共有8种基本类型，四种整形，两种浮点型，一种表示Unicode编码的字符类型char，一种表示真假的Boolean类型</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/001.png"  alt="Java核心卷——基础知识"></p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>长整型数值有一个后缀L,十六进制有一个前缀OX,八进制有一个前缀0,二进制有一个前缀0B</p>
<p>Java7开始支持数字字面量加下划线，目的在于易读，Java编译器会去除这些下划线,例如1_000_000是完全等价于1000000</p>
<p>Java没有任何无符号unsigned形式的int,long,short,byte类型</p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>浮点类型用于表示有小数部分的数值</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/002.png"  alt="Java核心卷——基础知识"></p>
<p>double的精度是float的两倍，被称之为双精度数值</p>
<p>float类型的数值有一个后缀F或f，例如3.14F；double类型的数值有一个后缀3.14D。没有后缀F的浮点数值3.14默认为double类型</p>
<p>浮点数值计算都遵循IEEE 754规范，有三个特殊的浮点数值用于表示溢出和出错情况，例如0/0，负数的平方根结果都为NaN</p>
<p>1.正无穷大</p>
<p>2.负无穷大</p>
<p>3.NaN(不是一个数字)</p>
<p>可以通过Double.isNan()方法判断非数值</p>
<p>浮点数值不能用于精确计算，sout(2.0-1.1)的值不是0.9而是0.8999999999999999，这种舍入误差的主要原因是因为浮点数值采用二进制系统表示，而二进制系统无法精确到1/10，就像十进制无法精确到1/3一样，数值计算不允许有任何舍入误差应该使用BigDecimal类</p>
<h3 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h3><p>Unicode字符有的需要一个char值描述，有的需要两个</p>
<p>char类型的字面量值需要被单引号括起来，例如‘A’是编码值为65所对应的字符常量</p>
<p>\u是转义字符，转义序列可以出现在引号内(单双即可)</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/003.png"  alt="Java核心卷——基础知识"></p>
<p>“\u022+\u0022”不是“+” 字符串，而是” “+” “两个空字符相加</p>
<p>不要将转义序列放到注释中，可能导致错误。例如\u00A0在编译时会被替换成一个换行符又例如//C:\users也会产生一个语法错误，因为\u后面并未跟着4个16进制数</p>
<h3 id="Unicode和char类型"><a href="#Unicode和char类型" class="headerlink" title="Unicode和char类型"></a>Unicode和char类型</h3><p>编码标准：美国的ASCII，西欧的ISO 8859-1,俄罗斯的KOI-8,中国的GB 18030和BIG-5</p>
<p>不同编码标准产生的问题：</p>
<p>1.任意确定的代码在不同编码环境下可能对应不同的字母</p>
<p>2.同一字符，不同的编码标准使用的字节长度可能不同</p>
<p>Unicode打破了传统字符编码机制的限制，Unicode俗称万国码，描述了所有字符，常见的类型又UTF-8,解决了上述问题</p>
<h3 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h3><p>boolean类型有两个值：false,true,整型与布尔值之间不能相互转换</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Java变量必须是字母开头并且由字母和数字构成，这里的字母不仅仅包含26个英文字符，还有Unicode中的字符，下划线_,圆周率都属于Java广义范围上的字母</p>
<p>变量名中所有的字符都是有意义的，并且大小写敏感，变量名的长度基本没有限制</p>
<p>可以通过Character类的isJavaIdenifierStart和isJavaIdentierPart方法来检查那些Unicode字符属于Java中的”字母“</p>
<p>尽管$属于Java字母，但是它只用于在Java编译器或其他生成工具中使用</p>
<p>可以在一行中声明多个变量，例如int i,j;但是不提倡，逐一声明变量可以提高程序的可读性</p>
<h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>变量的声明尽可能的靠近该变量第一次使用的地方，这是一种良好的编程习惯</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>final声明后只能被赋值一次，赋值后就不可再更改了，一般常量名使用全大写</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>当参与/运算 两个操作数都是整数时，表示整数除法，否则表示浮点除法</p>
<p>整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NAN结果</p>
<p>浮点型数据计算 的准确性是很难保证的，因为不同芯片计算时使用的寄存器位数存在差异，使用strictfp关键字s可以确保精确计算</p>
<h3 id="数学函数与常量"><a href="#数学函数与常量" class="headerlink" title="数学函数与常量"></a>数学函数与常量</h3><p>幂运算Math.pow(x,a)</p>
<p>两个参数是double类型，结果也是double类型</p>
<h3 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h3><p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/005.png"  alt="Java核心卷——基础知识"></p>
<p>实心箭头表示不会丢失精度，虚线箭头表示可能会丢失精度</p>
<p>大转小会损失精度，小转大不会损失精度</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/006.png"  alt="Java核心卷——基础知识"></p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>低精度转向高精度需要强转，方法是在()中给出想要转换的目标类型</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/007.png"  alt="Java核心卷——基础知识"></p>
<p>浮点型舍入运算，round舍入操作的结果为long</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/008.png"  alt="Java核心卷——基础知识"></p>
<p>注意：将一个数值强行转换为另外一个数值，如果超出了目标类型的表示范围，结果就会截断成一个完全不同的值，例如(byte)300的实际值为44</p>
<h3 id="结合赋值和运算符"><a href="#结合赋值和运算符" class="headerlink" title="结合赋值和运算符"></a>结合赋值和运算符</h3><p>x+=3.5等价于x=(int)(x+3.5)</p>
<p>当两个操作数不同时，会发生强制转换</p>
<h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>n++</p>
<p>n不能是常量</p>
<p>n++，先用后加；++n,先加后用</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/009.png"  alt="Java核心卷——基础知识"></p>
<p>不建议在表达式中使用++,会导致bug且让人困惑</p>
<h3 id="关系和boolean运算符"><a href="#关系和boolean运算符" class="headerlink" title="关系和boolean运算符"></a>关系和boolean运算符</h3><p>&amp;&amp;逻辑与</p>
<p>||逻辑或</p>
<p>！逻辑非</p>
<p>&amp;&amp;和||是按照短路的方式来求值的，如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了</p>
<p>例如x!=0&amp;&amp;1/0&gt;x+y,如果x=0那么x!=0的值为false,也就不会执行1/0报异常</p>
<p>三元运算符?:</p>
<p>x &lt; y?x:y   会返回返回x,y中较小的那一个</p>
<p>三目运算符是有返回值的，x,y都必须是值，没有if语句灵活，主要用于判断赋值</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>&amp;(“and”)   |(“or”)   ^(“xor”)   ~(“not”)</p>
<p>位运算符可以使用掩码技术得到整数中的各个位</p>
<p>|和&amp;用于计算布尔值时，与||和&amp;&amp;相似，但是不采用短路的方式来求值，也就是说计算结果之前两个操作数都需要计算</p>
<p>&lt;&lt;,&gt;&gt;将位模式右移或者左移,用符号位填充高位，&gt;&gt;&gt;会用0填充高位，没有&lt;&lt;&lt;</p>
<h3 id="括号与运算符级别"><a href="#括号与运算符级别" class="headerlink" title="括号与运算符级别"></a>括号与运算符级别</h3><p>不使用圆括号，就按照给出的运算符优先级次序进行计算，同一个级别的运算符按照从左到右的次序进行计算(右结合运算符除外)。例如</p>
<p>a&amp;&amp;b||c  </p>
<p>&amp;&amp;的优先级高于||，上述表达式等价于(a&amp;&amp;b)||c</p>
<p>+=是右结合运算符,即从右到左的运算顺序</p>
<p>a+=b+=c等价于a+=(b+=c)</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/010.png"  alt="Java核心卷——基础知识"></p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/011.png"  alt="Java核心卷——基础知识"></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Java没有内置的字符串类型，而是提供了一个预定义类String</p>
<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><p>substring(a,b)</p>
<p>a起始截取位置,b截取长度</p>
<h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>Java允许通过+拼接两个字符串</p>
<p>当一个字符串和一个非字符串的值进行拼接时，后者被转换成字符串</p>
<p>任何一个Java对象都可以转换成字符串</p>
<p>如果需要把多个字符串放在一起，用一个定界符/分隔，可以使用静态join方法</p>
<p>String all = String.join(“/“,”s”,”m”,”l”);</p>
<h3 id="检查字符串是否相等"><a href="#检查字符串是否相等" class="headerlink" title="检查字符串是否相等"></a>检查字符串是否相等</h3><p>使用equals方法检测两个字符串是否相等</p>
<p>检测两个字符串是否相等且不区分大小写，可以使用equalsIgnoreCase方法</p>
<p>不能用==比较两个字符串是否相等，==只能比较两个字符串是否在同一个位置。虽然在同一个位置的字符串必然是相等的，但是不同位置的字符串也可能是相同的，==只能判断位置相同，不能判断字符串相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String greeting &#x3D; &quot;Hello&quot;;</span><br><span class="line">System.out.println(greeting &#x3D;&#x3D; &quot;Hello&quot;);&#x2F;&#x2F;true</span><br><span class="line">System.out.println(greeting.substring(0, 3) &#x3D;&#x3D; &quot;Hel&quot;);&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p>Java虚拟机中，字符串常量是共享的，而+和substring等操作产生的结果不是共享的，所以不要使用==测试字符串的相等性，以免出现bug</p>
<p>compareTo也能比较两个字符串是否相等，但是返回的结果是0，-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String greeting &#x3D; &quot;Hello&quot;;</span><br><span class="line">System.out.println(greeting.compareTo(&quot;Hello1&quot;));&#x2F;&#x2F;-1</span><br><span class="line">System.out.println(greeting.substring(0, 3).compareTo(&quot;Hel&quot;));&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>

<h3 id="字串与Null值"><a href="#字串与Null值" class="headerlink" title="字串与Null值"></a>字串与Null值</h3><p>字串“”是一个长度为0的字符串，可以调用一下方法检查一个字符串是否为空</p>
<p> if (str.length() == 0) 或 if (str.equals(“”)) </p>
<p>字符串值为null表示当前没有任何对象与该变量关联，使用以下方法检查一个字符串是否为null</p>
<p> if (str == null) </p>
<p>检查一个字符串既不是null也不是空字符串，使用以下方法</p>
<p> if (str != null &amp;&amp; str.length() != 0) </p>
<p>必须先检测字符串是否为null,因为null调用方法会报错</p>
<h3 id="码点与代码单元"><a href="#码点与代码单元" class="headerlink" title="码点与代码单元"></a>码点与代码单元</h3><p>Java字符串由char值序列组成</p>
<p>char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元</p>
<p>大多数Unicode字符使用一个代码单元，而辅助字符需要一对代码单元表示</p>
<p>length方法将返回采用UTF-16编码表示的给定字符串所需要的代码单元数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String greeting &#x3D; &quot;Hello&quot;;</span><br><span class="line">int n &#x3D; greeting.length。; &#x2F;&#x2F; is 5 .</span><br><span class="line">获取码点数量</span><br><span class="line">int cpCount &#x3D; greeting.codePointCount(0, greeting.length());</span><br><span class="line">返回某个码点的字符</span><br><span class="line">char first &#x3D; greeting.charAt(0)); &#x2F;&#x2F; first is &#39;H&#39;</span><br><span class="line">char last &#x3D; greeting.charAt(4); &#x2F;&#x2F; last is ’o’</span><br><span class="line">想得到第i个码点</span><br><span class="line">int index &#x3D; greeting.offsetByCodePoints(0, i);</span><br><span class="line">int cp &#x3D; greeting.codePointAt(index);</span><br></pre></td></tr></table></figure>

<p>当字符串中存在辅助字符时，遍历码点会出现问题，最好的方式是将字符串转换成一个数组进行操作？？</p>
<h3 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h3><p>当一个字符串由多个短字符串拼接而成时，不要使用String对象，String对象每次拼接都会产生一个新的对象，耗时且浪费时间。使用StringBuilder可以避免这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构建一个空的字符串构建器</span><br><span class="line">StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line">每次拼接调用append方法</span><br><span class="line">builder.append(ch); &#x2F;&#x2F; appends a single character</span><br><span class="line">bui1der.append(str); &#x2F;&#x2F; appends a string</span><br><span class="line">需要完成字符串时就调用同String()方法</span><br><span class="line">String completedString &#x3D; builder.toString();</span><br></pre></td></tr></table></figure>

<p>StringBuilder是StringBuffer的前身(功能基本一样)，后者效率稍低但是允许采用多线程的方式执行添加或删除字符的操作(线程安全)，如果是单线程程序应当使用StringBuilder</p>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造Scanner对象并于标准输入流System.in关联</span><br><span class="line">Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">nextLine输入一行</span><br><span class="line">System.out.println(&quot;What is your name?&quot;);</span><br><span class="line">String name &#x3D; in.nextLine();</span><br><span class="line">System.out.println(name);</span><br><span class="line">读取一个单词</span><br><span class="line">String firstName &#x3D; in.next();</span><br><span class="line">读取一个整数</span><br><span class="line">int age &#x3D; in.nextlnt();</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">double x &#x3D; 10000.0 &#x2F; 3.0;</span><br><span class="line">System.out.println(x);&#x2F;&#x2F;3333.3333333333335</span><br><span class="line"></span><br><span class="line">用八个字符的宽度和小数点后三个字符长度的精度打印x</span><br><span class="line">打印出一个空格和七个字符？？？</span><br><span class="line">System.out.printf(&quot;%8.3f&quot;,x);&#x2F;&#x2F;3333.333</span><br><span class="line"></span><br><span class="line">printf中使用多个参数</span><br><span class="line">System.out.printf(&quot;Hello, %s,Next year, you&#39;ll be %d&quot;, name, age);</span><br><span class="line">&#x2F;&#x2F;Hello, lishang,Next year, you&#39;ll be 20</span><br></pre></td></tr></table></figure>

<p>每一个以%字符开始的格式说明符都用相应的参数替换，不同的字符表示不同的数值类型</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/012.png"  alt="Java核心卷——基础知识"></p>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>指由一对大括号括起来的若干条简单的Java语句，块确定了变量的作用域</p>
<p>块与块可以相互嵌套，但是嵌套的块中不能定义同名的变量</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">switch (ch) &#123;</span><br><span class="line">         case &#39;B&#39;:</span><br><span class="line">            System.out.println(&quot;case one&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case &#39;A&#39;:</span><br><span class="line">            System.out.println(&quot;case two&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case &#39;C&#39;:</span><br><span class="line">            System.out.println(&quot;case three&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">         	break;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(condition)&#123;</span><br><span class="line">   &#x2F;&#x2F;执行语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line">   &#x2F;&#x2F;执行语句</span><br><span class="line">&#125;while(condition)</span><br></pre></td></tr></table></figure>

<h2 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h2><p>BigInteger类实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算</p>
<p>使用静态的valueOf方法可以将普通的数值转换为大数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a &#x3D; BigInterger.valueOf(100);</span><br></pre></td></tr></table></figure>

<p>不能使用常见的算数运算符(+,-*,/)处理大数值，需要使用大数值类的add和multiply方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Biglnteger c &#x3D; a.add(b); &#x2F;&#x2F; c &#x3D; a + b</span><br><span class="line">Biglnteger d &#x3D; c.multiply(b.add(Biglnteger.val ueOf(2))); &#x2F;&#x2F; d &#x3D; c * (b + 2)</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在声明数组之前，需要指出数组类型和数组变量的名字</p>
<p>int[] a和int a[]两种声明方式是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] a &#x3D; new int[10];&#x2F;&#x2F;数组的长度必须指定</span><br></pre></td></tr></table></figure>

<p>创建一个数字数组时，所有元素都初始化为0，boolean数组的元素都会初始化为false,对象数组的元素初始化为一个特殊值null(表示这些元素还没存放任何对象)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] names &#x3D; new String[10];&#x2F;&#x2F;字符串数组内的每个元素都是null</span><br></pre></td></tr></table></figure>

<p>数组一旦创建就不能再改变其长度，如果需要频繁扩展数组的大小，应该使用数组链表</p>
<h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h3><p>可以处理任意集合，遍历整个集合，不需要使用下标值去寻值</p>
<p>如果不希望遍历集合中的每个元素，或者循环内部需要使用下标值，还是用for循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] names &#x3D; new String[10];</span><br><span class="line">&#x2F;&#x2F;将数组变成字符串打印输出</span><br><span class="line">System.out.println(Arrays.toString(names));</span><br><span class="line">&#x2F;&#x2F;没有foreach,通过for实现</span><br><span class="line">for(String name:names)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组初始化以及匿名数组"><a href="#数组初始化以及匿名数组" class="headerlink" title="数组初始化以及匿名数组"></a>数组初始化以及匿名数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化简化方式</span><br><span class="line">int[] smallPrimes &#x3D; &#123; 2, 3, 5, 7, 11, 13 &#125;;</span><br><span class="line">&#x2F;&#x2F;可以创建一个匿名数组对象，需要操作才能不报错(返回或者打印)</span><br><span class="line">new int[] &#123; 17, 19, 23, 29, 31, 37 &#125;;</span><br></pre></td></tr></table></figure>

<p>Java中允许数组长度为0，在编写一个结果为数组的方法时，如果碰巧为空，可以创建一个长度为0的数组</p>
<p>数组长度为0与null不同</p>
<h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><p>将一个数组变量拷贝给另外一个数组变量，两个变量将引用同一个数组</p>
<p>如果希望将一个数组的所有值拷贝到一个新数组中去，就要使用Arrays类的copyOf方法。copiedLuckyNumbers是新数组,newLength是新数组长度，luckyNumbers是旧数组，可以通过copyOf方法对数组进行扩容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] copiedLuckyNumbers &#x3D; Arrays.copyOf(luckyNumbers,newLength);</span><br></pre></td></tr></table></figure>

<p>拷贝后新数组多余的元素将会被类型默认值填充，如果长度小于原数组的长度，则只拷贝最前面的数据元素</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>主函数中的String[] args接收的就是命令行参数</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>sort可以通过快排对数组进行排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] a &#x3D; new int[]&#123;3,2,1&#125;;</span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure>

<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>random()可以得到从[0-1)之间的随机浮点数，用n乘以这个浮点数，可以得到[0,n)之间的一个随机数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.random()*100);</span><br></pre></td></tr></table></figure>

<h1 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h1><h3 id="面向对象程序设计-OOP-的优点"><a href="#面向对象程序设计-OOP-的优点" class="headerlink" title="面向对象程序设计(OOP)的优点"></a>面向对象程序设计(OOP)的优点</h3><p>类包含方法，简化开发流程，易于程序员掌握,找到问题</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类的三大特性：继承，多态，封装</p>
<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另外一个类(耦合比较高，不建议使用)，依赖就是调用的意思</p>
<h4 id="聚合-关联"><a href="#聚合-关联" class="headerlink" title="聚合/关联"></a>聚合/关联</h4><p>一个类包含包含另外一个类</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/012.png"  alt="Java核心卷——基础知识"></p>
<h2 id="时间类型Date"><a href="#时间类型Date" class="headerlink" title="时间类型Date"></a>时间类型Date</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;可以指定不同格式的时间</span><br><span class="line">SimpleDateFormat df2&#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">df1.format(new Date());</span><br></pre></td></tr></table></figure>

<h3 id="LocalDate-LocalTime-LocalDateTime，Instant"><a href="#LocalDate-LocalTime-LocalDateTime，Instant" class="headerlink" title="LocalDate,LocalTime,LocalDateTime，Instant"></a>LocalDate,LocalTime,LocalDateTime，Instant</h3><p>Date一般情况下会使用 SimpleDateFormat 对时间进行格式化，但 SimpleDateFormat 是线程不安全的，应该使用Java8提供的全新的日期和时间API,LocalDateTime=LocalDate+LocalTime</p>
<p> 和<code>SimpleDateFormat</code>相比，<code>DateTimeFormatter</code>是线程安全的 </p>
<p>LocalDate,LocalTime,LocalDateTime,Instant四个对象为不可变对象，修改这些对象会返回一个副本</p>
<h4 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取当前年月日</span><br><span class="line">LocalDate localDate &#x3D; LocalDate.now();</span><br><span class="line">&#x2F;&#x2F;构造指定的年月日</span><br><span class="line">LocalDate localDate1 &#x3D; LocalDate.of(2019, 9, 10);</span><br><span class="line">&#x2F;&#x2F;获取年</span><br><span class="line">int year &#x3D; localDate.getYear();</span><br><span class="line">int year1 &#x3D; localDate.get(ChronoField.YEAR);</span><br><span class="line">&#x2F;&#x2F;获取月</span><br><span class="line">Month month &#x3D; localDate.getMonth();</span><br><span class="line">int month1 &#x3D; localDate.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line">&#x2F;&#x2F;获取日</span><br><span class="line">int day &#x3D; localDate.getDayOfMonth();</span><br><span class="line">int day1 &#x3D; localDate.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line">&#x2F;&#x2F;获取星期</span><br><span class="line">DayOfWeek dayOfWeek &#x3D; localDate.getDayOfWeek();</span><br><span class="line">int dayOfWeek1 &#x3D; localDate.get(ChronoField.DAY_OF_WEEK);</span><br><span class="line">&#x2F;&#x2F;计算时间，例如当前时间的第一天</span><br><span class="line">LocalDate localDate &#x3D; LocalDate.now();</span><br><span class="line">LocalDate localDate1 &#x3D; localDate.with(firstDayOfYear());</span><br><span class="line">&#x2F;&#x2F;格式化时间</span><br><span class="line">LocalDate localDate &#x3D; LocalDate.of(2019, 9, 10);</span><br><span class="line">String s1 &#x3D; localDate.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 &#x3D; localDate.format(DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">&#x2F;&#x2F;自定义格式化</span><br><span class="line">DateTimeFormatter dateTimeFormatter &#x3D;   DateTimeFormatter.ofPattern(&quot;dd&#x2F;MM&#x2F;yyyy&quot;);</span><br><span class="line">String s3 &#x3D; localDate.format(dateTimeFormatter);</span><br></pre></td></tr></table></figure>

<h4 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建LocalTime</span><br><span class="line">LocalTime localTime &#x3D; LocalTime.of(13, 51, 10);</span><br><span class="line">LocalTime localTime1 &#x3D; LocalTime.now();</span><br><span class="line">&#x2F;&#x2F;获取时分秒</span><br><span class="line">&#x2F;&#x2F;获取小时</span><br><span class="line">int hour &#x3D; localTime.getHour();</span><br><span class="line">int hour1 &#x3D; localTime.get(ChronoField.HOUR_OF_DAY);</span><br><span class="line">&#x2F;&#x2F;获取分</span><br><span class="line">int minute &#x3D; localTime.getMinute();</span><br><span class="line">int minute1 &#x3D; localTime.get(ChronoField.MINUTE_OF_HOUR);</span><br><span class="line">&#x2F;&#x2F;获取秒</span><br><span class="line">int second &#x3D; localTime.getMinute();</span><br><span class="line">int second1 &#x3D; localTime.get(ChronoField.SECOND_OF_MINUTE);</span><br></pre></td></tr></table></figure>

<h4 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建LocalDateTime</span><br><span class="line">LocalDateTime localDateTime &#x3D; LocalDateTime.now();</span><br><span class="line">LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2019, Month.SEPTEMBER, 10, 14, 46, 56);</span><br><span class="line">LocalDateTime localDateTime2 &#x3D; LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime3 &#x3D; localDate.atTime(localTime);</span><br><span class="line">LocalDateTime localDateTime4 &#x3D; localTime.atDate(localDate);</span><br><span class="line">&#x2F;&#x2F;获取LocalDate</span><br><span class="line">LocalDate localDate2 &#x3D; localDateTime.toLocalDate();</span><br><span class="line">&#x2F;&#x2F;获取LocalTime</span><br><span class="line">LocalTime localTime2 &#x3D; localDateTime.toLocalTime();</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime &#x3D; LocalDateTime.of(2019, Month.SEPTEMBER, 10,</span><br><span class="line">              14, 46, 56);</span><br><span class="line">&#x2F;&#x2F;增加一年</span><br><span class="line">localDateTime &#x3D; localDateTime.plusYears(1);</span><br><span class="line">localDateTime &#x3D; localDateTime.plus(1, ChronoUnit.YEARS);</span><br><span class="line">&#x2F;&#x2F;减少一个月</span><br><span class="line">localDateTime &#x3D; localDateTime.minusMonths(1);</span><br><span class="line">localDateTime &#x3D; localDateTime.minus(1, ChronoUnit.MONTHS); </span><br><span class="line">&#x2F;&#x2F;修改年为2019</span><br><span class="line">localDateTime &#x3D; localDateTime.withYear(2020);</span><br><span class="line">&#x2F;&#x2F;修改为2022</span><br><span class="line">localDateTime &#x3D; localDateTime.with(ChronoField.YEAR, 2022);</span><br></pre></td></tr></table></figure>

<h4 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建Instant对象</span><br><span class="line">Instant instant &#x3D; Instant.now();</span><br><span class="line">&#x2F;&#x2F;获取秒数</span><br><span class="line">long currentSecond &#x3D; instant.getEpochSecond();</span><br><span class="line">&#x2F;&#x2F;获取毫秒数</span><br><span class="line">long currentMilli &#x3D; instant.toEpochMilli();</span><br><span class="line">System.currentTimeMillis()</span><br></pre></td></tr></table></figure>

<h2 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h2><p>文件名必须与public类的名字相匹配，在一个源文件中，只能有一个公有类，但可以有任意数量的非公有类</p>
<p>在编译有多个类的文件时，编译器将在目录下创建相应数量的.class类文件</p>
<p>类中的变量用private，方法用public可以更好的保护类的封装性</p>
<p>类的构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置变量数据的目的</p>
<p>构造器没有返回值</p>
<p>不能在构造器中定义与类变量同名的局部变量，构造器中的变量会将类变量屏蔽</p>
<p>一个类方法可以有隐式参数和显式参数两种类型，显式参数就是写在方法中的参数；隐式参数是this.salary之类的类参数</p>
<p>私有方法只能类内部调用，类设计者可以确信删除该方法不会对本类以外的类产生影响</p>
<h3 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h3><p>类变量如果是public，那么可以直接通过类对象调用</p>
<p>使用私有变量，公有setter,getter方法的好处</p>
<p>1.是程序内聚性更好，也更安全</p>
<p>2.setter可以对数据进行错误检查在内的额外操作</p>
<p>不要编写返回引用可变对象的访问器方法，可变变量自身的方法会破坏类对象的封装性，如果需要该类方法，可以返回克隆对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    private Date time;</span><br><span class="line">    public test(Date time) &#123;this.time &#x3D; time; &#125;</span><br><span class="line">    </span><br><span class="line">    public Date getTime() &#123;</span><br><span class="line">    &#x2F;&#x2F;正确写法</span><br><span class="line">    return (Date) time.clone();</span><br><span class="line">    &#x2F;&#x2F;错误写法</span><br><span class="line">    return time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class chuli&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Date d &#x3D; new test(new Date()).getTime();</span><br><span class="line">        &#x2F;&#x2F;如果getTime方法不返回克隆值，Date的setTime方法会破坏time变量的封装性</span><br><span class="line">        d.setTime(12323466446L);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态域与静态方法"><a href="#静态域与静态方法" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h2><h3 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h3><p>每个类只能有一个静态域(static)，静态域是属于类的，静态域可以通过类名直接调用；实例域则是每个类对象都有一个</p>
<h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><p>静态变量用的比较少，但静态常量却使用的比较多</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Math&#123;</span><br><span class="line">	public static final double PI &#x3D; 3.14159265358979323846;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过Math.PI的形式对PI进行调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class System&#123;</span><br><span class="line">	public static final PrintStream out &#x3D; new PrintStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于每个类都可以对共有域进行修改，所以要将共有域的对象设置为private，并且最好设置为final域，例如out被声明为final,所以不允许再将其他打印流赋给它</p>
<p>在System类中，存在着一个setOut方法，它可以将System.out设置为不同的流。这是因为setOut方法是一个本地方法不是Java语言实现的，所以可以绕过Java语言的存取控制机制</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>一种不能向对象实施操作的方法，即静态方法中不能调用非静态数据(常量，变量，对象)，静态方法只能调用自身类的静态域</p>
<p>静态方法是没有this参数的方法的，在一个非静态的方法中，this参数表示这个方法的隐式参数</p>
<p>静态方法可以直接通过类名调用，非静态方法必须通过类对象进行调用，这是因为静态方法在类加载的时候就已经被创建了。</p>
<p>当然通过类对象调用静态方法也是可以的，但是很容易造成混淆，建议使用类名而不是类对象，因为使用类对象调用静态方法的结果与类对象毫无关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int getNextId()&#123;</span><br><span class="line">	return nextld; &#x2F;&#x2F; returns static field</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;类名调用静态方法</span><br><span class="line">int n &#x3D; Employee.getNextId();</span><br><span class="line">&#x2F;&#x2F;类对象调用静态方法(不推荐)</span><br><span class="line">int n &#x3D; new Employee().getNextId();</span><br></pre></td></tr></table></figure>

<h4 id="使用静态方法的场景"><a href="#使用静态方法的场景" class="headerlink" title="使用静态方法的场景"></a>使用静态方法的场景</h4><p>一个方法不需要访问对象状态，其所需参数都是通过显示参数提供</p>
<p>一个方法只需要访问类的静态域</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>通过静态函数的方式构造类对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat currencyFormatter &#x3D; NumberFormat.getCurrencylnstance();</span><br><span class="line">NumberFormat percentFormatter &#x3D; NumberFormat.getPercentlnstance();</span><br><span class="line">double x &#x3D; 0.1;</span><br><span class="line">System.out.println(currencyFormatter.format(x)); &#x2F;&#x2F; prints $0.10</span><br><span class="line">System.out.println(percentFomatter.format(x)); &#x2F;&#x2F; prints 10%</span><br></pre></td></tr></table></figure>

<h4 id="NumberFormat类不使用构造器完成构造工作"><a href="#NumberFormat类不使用构造器完成构造工作" class="headerlink" title="NumberFormat类不使用构造器完成构造工作"></a>NumberFormat类不使用构造器完成构造工作</h4><p>无法命名构造器：构造器的名字必须与类名相同，但是这里希望将得到的货币实例和百分比实例采用不同的名字</p>
<p>当使用构造器时，无法改变所构造的对象类型，而Factory方法将返回一个DecimalFormat类对象，这是NumberFormat的子类</p>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>一个方法不可能修改一个基本数据类型的参数，而对象引用作为参数就不同了</p>
<h3 id="按值调用"><a href="#按值调用" class="headerlink" title="按值调用"></a>按值调用</h3><p>方法接收的是调用者提供的值，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void tripieValue(double x)&#123;</span><br><span class="line">	x &#x3D; 3*x;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;按值调用，percent的值不会发生变化，x只是拷贝了percent的值，不会操作percent</span><br><span class="line">double percent &#x3D; 10;</span><br><span class="line">tripieValue(percent);</span><br></pre></td></tr></table></figure>

<h3 id="按引用调用"><a href="#按引用调用" class="headerlink" title="按引用调用"></a>按引用调用</h3><p>方法接收的是调用者提供的对象地址，对象引用及其拷贝指向的是同一个地址，所以按引用调用对象的值会被改变</p>
<h3 id="Java中方法参数的使用情况"><a href="#Java中方法参数的使用情况" class="headerlink" title="Java中方法参数的使用情况"></a>Java中方法参数的使用情况</h3><p>Java程序设计语言对对象采用的不是引用调用</p>
<p>一个方法不能修改一个基本数据类型的参数(数值型或布尔型)</p>
<p>一个方法可以改变一个对象参数的状态</p>
<p>一个方法不能让对象参数引用一个新的对象</p>
<p>我的理解：一个方法可以操作一个对象，不能操作两个对象进行交互操作</p>
<h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>如果多个方法有相同的名字，不同的参数，便发生了重载</p>
<p>Java允许重载任何方法，而不只是构造器方法</p>
<p>方法签名指的是方法名以及参数类型，方法签名必须不同。返回值不是方法签名的一部分，不能存在方法签名相同但是返回值类型不同的方法</p>
<h4 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h4><p>如果构造器中没有显示地给域赋予初值，那么就会被自动地赋值为默认值：数值为0，布尔值为false，对象引用为null。如果不明确地进行域初始化，就会影响程序代码的可读性</p>
<h4 id="无参数的构造器"><a href="#无参数的构造器" class="headerlink" title="无参数的构造器"></a>无参数的构造器</h4><p>无参构造器的主要作用是构造默认值对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Employee()&#123;</span><br><span class="line">	name &#x3D; &quot;&quot;</span><br><span class="line">	salary &#x3D; 0;</span><br><span class="line">	hireDay &#x3D; LocalDate,now();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有定义系统会提供一个无参构造器，这个构造器会将所有实例域设置为默认值，自定义的无参构造器也有这个效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ClassName()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果类中提供了一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法</p>
<h4 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h4><p>构造器内调用构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Employee(double s)&#123;</span><br><span class="line">	this(&quot;Employee #&quot; + nextld, s);</span><br><span class="line">	nextld++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：对公共的构造器代码部分只编写一次即可</p>
<h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>初始化数据域的方法：在构造器中设置值，在声明中赋值，初始化块</p>
<p>一个类的声明中，可以包含多个代码块，只要构造类的对象，这些块就会被执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Employee&#123;</span><br><span class="line">    private static int nextld;</span><br><span class="line">    private int id;</span><br><span class="line">    &#123;</span><br><span class="line">        id &#x3D; nextld;</span><br><span class="line">        nextld++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论使用哪个构造器对象，id域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器的主体部分</p>
<h5 id="调用构造器后具体的处理步骤"><a href="#调用构造器后具体的处理步骤" class="headerlink" title="调用构造器后具体的处理步骤"></a>调用构造器后具体的处理步骤</h5><p>1.所有数据域被初始化为默认值</p>
<p>2.按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块</p>
<p>3.如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</p>
<p>4.执行这个构造器的主体</p>
<p>可以通过静态代码块提前在类加载的时候就初始化变量值(相当于改变默认值)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static&#123;</span><br><span class="line">    Random generator &#x3D; new Random()；</span><br><span class="line">    nextld &#x3D; generator.nextlnt(1OOOO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象解析与finalize方法"><a href="#对象解析与finalize方法" class="headerlink" title="对象解析与finalize方法"></a>对象解析与finalize方法</h3><p>可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源。</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>所有标准的Java包都处于java和javax包层次中</p>
<p>使用包的主要原因是确保类名的唯一性，两个同名的类放在不同的包内就不会发生冲突</p>
<p>为了确保包名的绝对唯一性，Sun公司建议将公司的因特网域名以逆序的形式作为包名，并且对于不同的项目使用不同的子包</p>
<h3 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h3><p>一个类可以使用所属包的所有类，以及其他包中的公有类</p>
<h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><p>import不仅可以导入类，还增加了导入静态方法和静态域的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;导入System类的静态方法和静态域，而不必加类名前缀</span><br><span class="line">import static java.lang.System.*;</span><br></pre></td></tr></table></figure>

<p>导入指定的方法或域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static java.lang.System.out;</span><br></pre></td></tr></table></figure>

<h3 id="将类放入包中"><a href="#将类放入包中" class="headerlink" title="将类放入包中"></a>将类放入包中</h3><p>要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package com.horstiann.corejava;</span><br><span class="line">public class Employee&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包中，默认包是一个没有名字的包</p>
<p>将包中的文件放到与完整的包名匹配的子目录中，编译器将编译后的类文件也放在相同的目录结构中</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/014.png"  alt="Java核心卷——基础知识"></p>
<p>PackageTest类放置在默认包中(默认包就是基目录)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac com&#x2F;myCompany&#x2F;Payrol1App.java</span><br><span class="line">java com.mycompany.PayrollApp</span><br></pre></td></tr></table></figure>

<p>编译器对文件(带有文件分隔符和扩展名.java的文件)进行操作，而Java解释器加载类(带有.分隔符)</p>
<h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><p>编译器在编译源文件的时候不检查目录结构。假如有一个源文件开头有下列语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package con.myconpany;</span><br></pre></td></tr></table></figure>

<p>即使这个源文件没有在子目录com/mycompany下，也可以进行编译。如果它不依赖于其他包，就不会出现编译错误。但是，最终的程序无法运行，除非先将所有类文件移到正确的位置上，如果出现包与目录不匹配的情况，虚拟机就找不到类</p>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>访问修饰词</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/015.png"  alt="Java核心卷——基础知识"></p>
<p>不设置访问修饰词的方法可以被整个包中的所有类调用。但是变量必须设置为private，避免破坏封装性</p>
<h3 id="类路径-这一块没看懂"><a href="#类路径-这一块没看懂" class="headerlink" title="类路径(这一块没看懂)"></a>类路径(这一块没看懂)</h3><p>类存储在文件系统的子目录中，类的路径必须与包名匹配</p>
<p>类文件也可以存储在JAR(Java归档)文件中。在一个JAR中，可以包含多个压缩形式的类文件和子目录，这样既可以节省空间又可以改善性能</p>
<p>JAR文件使用ZIP格式组织文件和子目录</p>
<h4 id="为了使类能够被多个程序共享，需要做到以下几点："><a href="#为了使类能够被多个程序共享，需要做到以下几点：" class="headerlink" title="为了使类能够被多个程序共享，需要做到以下几点："></a>为了使类能够被多个程序共享，需要做到以下几点：</h4><p>把类放到一个目录中，例如/home/user/classdir，这个目录是包树状结构的基目录</p>
<p>将JAR文件放在一个目录中，例如/home/user/archives</p>
<p>设置类路径，类路径是所有包含类文件的路径的集合</p>
<p>在UNIX环境中，类路径中的不同项目之间采用冒号:分隔</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;home&#x2F;user&#x2F;classdir:.:&#x2F;home&#x2F;user&#x2F;archives&#x2F;archive.jar</span><br></pre></td></tr></table></figure>

<p>在windows环境中，则以分号;分隔</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\classdir;.;c:\archives\archive.jar</span><br></pre></td></tr></table></figure>

<p>句号.表示当前目录</p>
<p>类路径包括</p>
<p>基目录/home/user/classdir或c:\classes</p>
<p>当前目录(.)</p>
<p>JAR文件/home/user/archives/archive.jar或c:\archives\archive.jar</p>
<p>警告：javac编译器总是在当前的目录中查找文件，但Java虚拟机仅在类路径中有.目录的时候才查看当前目录。如果没有设置类路径，那么并不会产生什么问题，默认的路径包含.目录。然而如果设置了类路径却忘记了包含.目录，则程序仍然可以通过编译，但不能运行</p>
<h4 id="类路径示例"><a href="#类路径示例" class="headerlink" title="类路径示例"></a>类路径示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;home&#x2F;user&#x2F;classdir:.:&#x2F;home&#x2F;user&#x2F;archives&#x2F;archive.jar</span><br></pre></td></tr></table></figure>

<p>假定虚拟机要搜寻com.horstmann.corejava.Employee类文件。它首先要查看存储在jre/lib和jre/ext目录下的归档文件中所存放的系统类文件。 显然，在那里找不到相应的类文件，然后再查看类路径，然后查找以下文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">•&#x2F;home&#x2F;user&#x2F;classdir&#x2F;com&#x2F;horstmann&#x2F;corejava&#x2F;Employee.class</span><br><span class="line">•com&#x2F;horstmann&#x2F;corejava&#x2F;Employee.class &#x2F;&#x2F;从当前目录开始</span><br><span class="line">•com&#x2F;horstmann&#x2F;corejava&#x2F;Employee.class inside &#x2F;home&#x2F;user&#x2F;archives&#x2F;archive.jar</span><br></pre></td></tr></table></figure>

<p>编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所有的import指令，确定其中是否包含了被引用的类</p>
<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>JDK包含一个很有用的工具，叫做javadoc，它可以通过源文件生成一个HTML文件</p>
<h4 id="注释的插入"><a href="#注释的插入" class="headerlink" title="注释的插入"></a>注释的插入</h4><p>javadoc从下面几个特性中抽取信息</p>
<ul>
<li>包</li>
<li>公有类接口</li>
<li>公有的和受保护的构造器及方法</li>
<li>公有的和受保护的域</li>
</ul>
<p>应该为上面四个部分编写注释，注释应该放置在所描述特性的前面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">注释内容</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>文档注释在标记之后紧跟着自由格式文本，标记由@开始，例如@author或@param</p>
<p>自由格式文本的第一句应该是一个概要性的句子，javadoc会自动的将这些句子抽取出来形成概要页</p>
<p>在自由格式文本中，可以使用HTML修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;em&gt;&lt;&#x2F;em&gt;表示强调</span><br><span class="line">&lt;strong&gt;&lt;&#x2F;strong&gt;表示着重强调</span><br><span class="line">&lt;img&gt;包含图像</span><br></pre></td></tr></table></figure>

<p>一定不要使用h1,hr它们会和文档的格式产生冲突</p>
<h4 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h4><p>类注释必须放在import语句之后，类定义之前</p>
<p>以下两种注释都是合法的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">注释内容</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">*注释内容</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>每一个方法注释必须放在所描述的方法之前，可以使用以下标记</p>
<p>@param变量,描述参数信息</p>
<p>@return描述,返回值信息</p>
<p>@throws类,描述可能抛出的异常的信息</p>
<h4 id="域注释"><a href="#域注释" class="headerlink" title="域注释"></a>域注释</h4><p>只需要对公有域(静态常量)建立文档</p>
<h4 id="通用注释"><a href="#通用注释" class="headerlink" title="通用注释"></a>通用注释</h4><p>@author姓名</p>
<p>@version版本</p>
<p>@since始于版本</p>
<p>@deprecated文本</p>
<p>@see引用</p>
<h4 id="包与概述注释"><a href="#包与概述注释" class="headerlink" title="包与概述注释"></a>包与概述注释</h4><p>想要对包进行注释，就需要在每一个包目录中添加一个单独的文件</p>
<h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><p>应用这些技巧可以使设计出来的类更具有OOP的专业水准</p>
<h4 id="一定要保证数据私有"><a href="#一定要保证数据私有" class="headerlink" title="一定要保证数据私有"></a>一定要保证数据私有</h4><p>绝对不要破坏封装性</p>
<h4 id="一定要对数据初始化"><a href="#一定要对数据初始化" class="headerlink" title="一定要对数据初始化"></a>一定要对数据初始化</h4><p>Java不对局部变量进行初始化，但是会对对象的实例域进行初始化，最好不要依赖系统的默认值，而是应该显式地初始化所有的数据</p>
<h4 id="不要在类中使用过多的基本类型"><a href="#不要在类中使用过多的基本类型" class="headerlink" title="不要在类中使用过多的基本类型"></a>不要在类中使用过多的基本类型</h4><p>用其他类代替多个相关的基本类型的使用，这样会使类更加容易理解且易于修改，例如用一个Address类替换以下实例域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private String street;</span><br><span class="line">private String city;</span><br><span class="line">private String state;</span><br><span class="line">private int zip;</span><br></pre></td></tr></table></figure>

<h4 id="不是所有的域都需要独立的域访问器和域更改器"><a href="#不是所有的域都需要独立的域访问器和域更改器" class="headerlink" title="不是所有的域都需要独立的域访问器和域更改器"></a>不是所有的域都需要独立的域访问器和域更改器</h4><p>一旦构造雇员对象，就应该禁止更改雇佣日期</p>
<h4 id="将职责过多的类进行分解"><a href="#将职责过多的类进行分解" class="headerlink" title="将职责过多的类进行分解"></a>将职责过多的类进行分解</h4><h4 id="类名和方法名要能够体现它们的职责"><a href="#类名和方法名要能够体现它们的职责" class="headerlink" title="类名和方法名要能够体现它们的职责"></a>类名和方法名要能够体现它们的职责</h4><h4 id="优先使用不可变的类"><a href="#优先使用不可变的类" class="headerlink" title="优先使用不可变的类"></a>优先使用不可变的类</h4><p>使用不可变的类可以避免并发问题， LocalDate 类以及 java.time 包中的其他类是不可变的，没有方法能修改对象的状态。 </p>
<h1 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h1><p>利用继承，人们可以基于已存在的类构造一个新类，继承已存在的类就是复用(继承)这些类的方法和域，在此基础上，还可以添加一些新的方法和域，以满足新的需求</p>
<p>反射是指在程序运行期间发现更多的类及其属性的能力</p>
<h2 id="类，超类和子类"><a href="#类，超类和子类" class="headerlink" title="类，超类和子类"></a>类，超类和子类</h2><p>以manager和employee为例，管理者也属于员工，拥有员工的一部分属性</p>
<h3 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h3><p>关键字extends表明正在构造的新类派生于一个已经存在的类，已存在的类称为超类，基类或者父类；新类称为子类，派生类或者孩子类</p>
<p>子类比父类拥有更多的数据，子类可以调用父类的数据，但是父类不能调用子类的数据</p>
<h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>父类方法不满足子类方法时，子类可以提供一个新的方法来覆盖父类中的方法</p>
<p>子类覆盖父类方法时，如果要调用父类的方法必须使用super关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;子类无法直接调用父类中的salary</span><br><span class="line">public double getSalary()&#123;</span><br><span class="line">	return salary + bonus; &#x2F;&#x2F; won&#39;t work</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;子类无法直接调用父类中的getSalary方法</span><br><span class="line">public double getSalary()&#123;</span><br><span class="line">	double baseSalary &#x3D; getSalary()；&#x2F;&#x2F; still won&#39;t work</span><br><span class="line">	return baseSalary + bonus;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;只能通过super关键字去调用父类的方法</span><br><span class="line">public double getSalary()&#123;</span><br><span class="line">	double baseSalary &#x3D; super.getSalary();</span><br><span class="line">	return baseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super与this不同，super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用父类方法的特殊关键字</p>
<p>子类可以增加域，增加方法，覆盖父类，但是绝对不能删除继承的任何域和方法</p>
<p>覆盖只要求方法签名相同，返回值是可以不同的,一般要保证返回类型的兼容性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Employee getBuddy()&#123;&#125;</span><br><span class="line">public Manager getBuddy()&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过super调用父类的构造器</span><br><span class="line">public Manager(String name, double salary, int year, int month, int day)&#123;</span><br><span class="line">	super(name, salary, year, month, day);</span><br><span class="line">	bonus &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>manager类的构造器不能访问employee类的私有域，所以必须利用employee类的构造器对这部分私有域进行初始化</p>
<p>使用super实现对父类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句</p>
<p>如果子类的构造器没有显示地调用父类的构造器，则将自动地调用父类默认的无参构造器；如果父类没有无参的构造器，并且在子类构造器中又没有显示地调用父类的其他构造器，则Java编译器将报告错误</p>
<p>this有两个用途：一个是引用隐式参数，二是调用该类其他的构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;n,s是显式参数。name,salary是隐式参数</span><br><span class="line">public Employee(String n, double s) &#123;</span><br><span class="line">	this.name &#x3D; n;</span><br><span class="line">	this.salary &#x3D; s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super有两个用途:  一是调用父类的方法，二是调用父类的构造器</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Java对象是多态的，一个employee变量既可以引用一个employee类对象，也可以引用一个employee类的任何一个子类的对象，但是不可以引用employee类的父类</p>
<p>子类数组的引用可以转换成父类数组的引用，而不需要采用强制类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;转换是合法的</span><br><span class="line">Manager[] managers &#x3D; new Manager[10];</span><br><span class="line">Employee[] staff &#x3D; managers;</span><br><span class="line">&#x2F;&#x2F;如果试图在managers中混入Employee，会引发ArrayStoreException异常</span><br><span class="line">staff[0] &#x3D; new Employee(&quot;Harry Hacker&quot;, . . .);</span><br></pre></td></tr></table></figure>

<h3 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h3><p>假设调用x.f(args),x为类C的一个对象，下面是调用过程的详细描述</p>
<ol>
<li>编译器查看对象的声明类型和方法名。编译器将会一一列举所有C类中名为f的方法和其父类中访问属性为public且名为f的方法(父类的私有方法不可访问)</li>
<li>编译器将查看调用方法时提供的参数类型。如果有匹配的方法就选择这个方法，这个过程被称为重载解析。由于允许类型转换，即int可以转换成double,manager可以转换成employee，所以重载解析这个过程很复杂，如果编译器没有找到匹配的方法就会报错</li>
<li>如果是private，static，final方法或者构造器，那么编译器将可以准确地知道应该调用那个方法，这种调用方式称为静态绑定。与之对应的，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定</li>
<li>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际类型是D,D是C类的子类。如果D类定义了方法f(String),就直接调用它；否则，将在D类的父类中寻找f(String),以此类推</li>
<li>每次调用方法都要进行搜索，时间开销相当大，因此虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法，真正调用方法的时候，虚拟机仅查找这个表就行了</li>
</ol>
<p>警告：在覆盖一个方法时，子类方法不能低于父类方法的可见性。如果父类方法是public，子类方法一定要声明为public,经常会发生这类错误：在声明子类方法的时候，遗漏了public修饰符，此时，编译器将会把它解释为试图提供更严格的访问权限，会导致覆盖失败</p>
<h3 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h3><p>不允许扩展的类被称为final类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class Executive extends Manager&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>类中的特定方法也可以被声明为final,这样子类就不能覆盖这个方法(final类中的所有方法自动地称为final方法)</p>
<p>域也可以声明为final,构造对象之后就不允许改变它们的值了。一个final类，只有其中的方法会自动变成final的，不包括域</p>
<p>final的主要目的是确保类，方法，域不会在子类中改变语义。例如String类也是final类，这意味着不允许任何人定义String的子类</p>
<p>final关键字能够避免动态绑定</p>
<p>如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化，这个过程称为内联。例如，内联调用e.getName()将被替换成e.name域，如果getName在另外一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了</p>
<h3 id="强制类型转换-1"><a href="#强制类型转换-1" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>将一个子类的引用赋给一个父类变量，编译器是允许的。但是将一个父类的引用赋给一个子类变量，必须进行类型转换，这样才能通过运行时的检查</p>
<p>只能在继承层次内进行类型转换，不满足要求的转换会报ClassCastException异常</p>
<p>在父类转换成子类之前，应该用instanceof进行检查</p>
<p>类型转换之前，应该先查看是否能够成功地转换，使用instanceof操作符就可以实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (staff[1] instanceof Manager)&#123;</span><br><span class="line">	boss &#x3D; (Manager) staff[1]:</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;x instanceof C的返回值为false</span><br></pre></td></tr></table></figure>

<p>父类可以直接引用子类，但是子类想要引用父类，必须将父类进行类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;&#125;</span><br><span class="line">class Manager extends  Employee&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Manager boss &#x3D; new Manager();</span><br><span class="line">        Employee staff &#x3D; new Employee();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;子类引用父类必须将父类进行类型转换</span><br><span class="line">        boss &#x3D; (Manager)staff;</span><br><span class="line">        &#x2F;&#x2F;父类可以直接引用子类</span><br><span class="line">        staff &#x3D; boss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常使用重新设置父类子类的方式代替类型转换，应该尽量少用类型转换和instanceof运算符</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>对于一些公共的方法，域，如果在每一份子类中都定义一份显得非常冗余；如果在父类中定义，父类不知道子类情况，无法定义。所以出现了抽象类</p>
<p>为了提高程序的清晰度，包含一个或者多个抽象方法的类本身必须被声明为抽象的</p>
<p>抽象类出抽象方法外，还可以包含具体的数据和具体的方法</p>
<p>抽象类类似于继承和接口的合体，既能定义一部分公共域，方法，又能定义抽象方法，要求子类必须实现</p>
<h3 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h3><p>类中的域标记为private,方法标记为public,任何声明为private的内容对其他类都是不可见的，子类也不能访问父类的私有域</p>
<p>如果允许子类访问父类中的某个域，可以将这个域声明为protected</p>
<p>谨慎使用protected属性，A类中的属性，方法被B类调用，那么如果改动A类，就必须通知B类，违反了OOP提倡的数据封装原则</p>
<p>private:仅对本类可见</p>
<p>public:对所有类可见</p>
<p>protected:对包和所有子类可见</p>
<p>默认(没有修饰符):对本包可见</p>
<h2 id="Object-所有类的父类"><a href="#Object-所有类的父类" class="headerlink" title="Object:所有类的父类"></a>Object:所有类的父类</h2><p>只有基本类型，例如数值，字符和布尔类型的值不是对象所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee[] staff &#x3D; new Employee[10];</span><br><span class="line">obj &#x3D; staff; &#x2F;&#x2F; OK</span><br><span class="line">obj &#x3D; new int[10]; &#x2F;&#x2F;ok</span><br></pre></td></tr></table></figure>

<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>Object类中的equals方法用于检测一个对象是否等于另外一个对象，这个方法将判断两个对象是否具有相同的引用</p>
<h3 id="equals与-的区别"><a href="#equals与-的区别" class="headerlink" title="equals与==的区别"></a>equals与==的区别</h3><p>不同的数据类型的equals方法是不同的</p>
<p>equals方法对于字符串来说是比较内容的，而对于非字符串来说是比较的是地址。String类中重新定义了equals这个方法，比较的是值而不是地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString &#x3D; (String)anObject;</span><br><span class="line">            int n &#x3D; value.length;</span><br><span class="line">            if (n &#x3D;&#x3D; anotherString.value.length) &#123;</span><br><span class="line">                char v1[] &#x3D; value;</span><br><span class="line">                char v2[] &#x3D; anotherString.value;</span><br><span class="line">                int i &#x3D; 0;</span><br><span class="line">                while (n-- !&#x3D; 0) &#123;</span><br><span class="line">                    if (v1[i] !&#x3D; v2[i])</span><br><span class="line">                        return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>==也是比较对象在内存中的首地址</p>
<h4 id="对于字符串变量来说"><a href="#对于字符串变量来说" class="headerlink" title="对于字符串变量来说"></a>对于字符串变量来说</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1,s2,s3 &#x3D; &quot;abc&quot;, s4 &#x3D;&quot;abc&quot; ;</span><br><span class="line">s1 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">s2 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;是false,两个变量的内存地址不一样，也就是说它们指向的对象不 一样，</span><br><span class="line">System.out.println(s1&#x3D;&#x3D;s2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;是true两个变量的所包含的内容是abc，故相等。</span><br><span class="line">System.out.println(s1.equals(s2));</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer s1 &#x3D; new StringBuffer(&quot;a&quot;);</span><br><span class="line">StringBuffer s2 &#x3D; new StringBuffer(&quot;a&quot;);</span><br><span class="line">&#x2F;&#x2F;StringBuffer类中没有重新定义equals这个方法，因此这个方法就来自Object类，用来比较地址，而不是值</span><br><span class="line">System.out.println(&quot;s1.equals(s2):&quot;+(s1.equals(s2)));&#x2F;&#x2F;结果为false</span><br></pre></td></tr></table></figure>

<p>Object中的equals方法是用==实现的，比较的是地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对于非字符串变量来说-对象"><a href="#对于非字符串变量来说-对象" class="headerlink" title="对于非字符串变量来说(对象)"></a>对于非字符串变量来说(对象)</h4><p>==和equals方法的作用是相同的，都是用来比较对象在堆内存的首地址，即用来比较引用变量是否指向同一个对象(比较对象，==和equals都是比较地址)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A a &#x3D; new A();</span><br><span class="line">B b &#x3D; new B();</span><br><span class="line">A aa &#x3D; new A();</span><br><span class="line">System.out.println(aa&#x3D;&#x3D;a);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(a.equals(aa));&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<h4 id="比较时的注意事项"><a href="#比较时的注意事项" class="headerlink" title="比较时的注意事项"></a>比较时的注意事项</h4><ul>
<li>字面量声明和new声明是不同的,前者存放在字符串常量池中，可以反复被字面量引用；后者就是一个对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 &#x3D; &quot;abc&quot;;&#x2F;&#x2F;字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span><br><span class="line">String s2 &#x3D; new String(&quot;abc&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是基础类型比较，那么只能用==来比较(自己理解的只创建一次，后面再声明直接引用)，不能用equals,基础的类型例如int,short是没有实现equals方法的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 3; </span><br><span class="line">int b &#x3D; 4; </span><br><span class="line">int c &#x3D; 3; </span><br><span class="line">System.out.println(a &#x3D;&#x3D; b);&#x2F;&#x2F;结果是false </span><br><span class="line">System.out.println(a &#x3D;&#x3D; c);&#x2F;&#x2F;结果是true </span><br><span class="line">System.out.println(a.equals(c));&#x2F;&#x2F;错误，编译不能通过，equals方法</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Java的基础包装类，例如String,Integer等的equals都是重写过的，用于比较值是否相等，==比较地址。与对象类不同，基础包装类相等值的引用指向的是同一地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;d1，d2指向的是同一个内存地址</span><br><span class="line">Integer d1 &#x3D; 0;</span><br><span class="line">Integer d2 &#x3D; 0;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h3><p>Java语言规范要求equals方法具有以下特征：</p>
<ol>
<li><p>自反性：对于任何非空引用x,x.equals(x)应该返回true</p>
</li>
<li><p>对称性：对于任何引用x和y,当且仅当y.equals(x)返回true,x.equals(y)也应该返回true</p>
</li>
<li><p>传递性：对于任何引用x,y,z，如果x.equals(y) 返回true， y.equals(z) 返回 true, x.equals(z) 也应该返回 true </p>
</li>
<li><p>一致性： 如果x和y引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。 </p>
</li>
<li><p>对于任意非空引用 x, x.equals(null) 应该返回false </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a &#x3D; new A();</span><br><span class="line">        B b &#x3D; new B();</span><br><span class="line">        &#x2F;&#x2F;父类对象不属于子类</span><br><span class="line">        System.out.println(a instanceof B);&#x2F;&#x2F;false</span><br><span class="line">        &#x2F;&#x2F;子类对象属于父类</span><br><span class="line">        System.out.println(b instanceof A);&#x2F;&#x2F;true</span><br><span class="line">        &#x2F;&#x2F;equals比较对象，值，&#x3D;&#x3D;比较位置</span><br><span class="line">        System.out.println(a.equals(b));&#x2F;&#x2F;false</span><br><span class="line">        System.out.println(a&#x3D;&#x3D;b);&#x2F;&#x2F;false</span><br><span class="line">        &#x2F;&#x2F;getClass获取的是类全名</span><br><span class="line">        System.out.println(a.getClass());&#x2F;&#x2F;class com.ls.java.A</span><br><span class="line">        System.out.println(b.getClass());&#x2F;&#x2F;class com.ls.java.B</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测</li>
<li>如果由父类决定相等的概念，那么就可以使用instanceof进行检测，这样可以在不同子类的对象之间进行相等的比较</li>
</ul>
<h4 id="编写一个完美equals的建议"><a href="#编写一个完美equals的建议" class="headerlink" title="编写一个完美equals的建议"></a>编写一个完美equals的建议</h4><p>1.显示参数命名为otherObject,稍后需要将他转换成另一个叫做other的变量</p>
<p>2.检测this与otherObject是否引用同一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (this &#x3D;&#x3D; otherObject) return true;</span><br></pre></td></tr></table></figure>

<p>3.检测otherObject是否为null,如果为null,返回false,这项检测很有必要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (otherObject &#x3D;&#x3D; null) return false;</span><br></pre></td></tr></table></figure>

<p>4.比较this与otherObject是否属于同一个类，如果equals的语义在每个子类中有所改变，就使用getClass检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(getClass() !&#x3D; otherObject.getCIass()) return false;</span><br></pre></td></tr></table></figure>

<p>如果所有的子类都拥有统一的语义，就使用instanceof检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!(otherObject instanceof ClassName)) return false;</span><br></pre></td></tr></table></figure>

<p>5.将otherObject转换为相应的类类型变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName other &#x3D; (ClassName) otherObject</span><br></pre></td></tr></table></figure>

<p>6.现在开始对所有需要比较的域进行比较了，使用==比较基本类型域，使用equals比较对象域，如果所有域都匹配，就返回true,否则返回false</p>
<p>如果是普通的没有重写equals的类对象，其实使用的仍然是父类Object的==来进行比较的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return fieldl &#x3D;&#x3D; other.field1</span><br><span class="line">&amp;&amp; Objects.equa1s(fie1d2, other.field2)</span><br><span class="line">&amp;&amp; ...;</span><br></pre></td></tr></table></figure>

<p>如果子类中重新定义equals,就要在其中包含调用super.equals(other)</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>对于数组类型的的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等</p>
<h5 id="实现equals方法的一种常见的错误"><a href="#实现equals方法的一种常见的错误" class="headerlink" title="实现equals方法的一种常见的错误"></a>实现equals方法的一种常见的错误</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Employee</span><br><span class="line">&#123;</span><br><span class="line">    public boolean equals(Employee other)</span><br><span class="line">    &#123;</span><br><span class="line">        return other !&#x3D; null</span><br><span class="line">            &amp;&amp; getClass() &#x3D;&#x3D; other.getClass()</span><br><span class="line">            &amp;&amp; Objects.equals(name , other.name)</span><br><span class="line">            &amp;&amp; salary &#x3D;&#x3D; other.salary</span><br><span class="line">            &amp;&amp; Objects.equals(hireDay, other.hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法声明的显示参数类型是Employee,其结果并没有覆盖Object类的equals方法，而是定义了一个完全无关的方法，覆盖Object中的equals方法时，参数必须是Object类型的</p>
<p>为了避免发生类型错误，可以使用@Override对覆盖父类的方法进行标记</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">©Override </span><br><span class="line">public boolean equals(Object other)</span><br></pre></td></tr></table></figure>

<p>如果出现了错误，并且正在定义一份新方法，编译器就会给出错误报告。例如，假设将下面的声明添加到Employee类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Employee other)</span><br></pre></td></tr></table></figure>

<p>就会看到一个错误报告，这是因为这个方法并没有覆盖父类Object中的任何方法</p>
<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p>散列码hashCode是由对象导出的一个整形值，散列码是没有规律的，如果x,y是两个不同的对象，那么二者的hashCode基本上不会相同,同一个对象那个的散列码是不会变化的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;String对象的hashCode()方法</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">     int h &#x3D; hash;</span><br><span class="line">        if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">            char val[] &#x3D; value;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; value.length; i++) &#123;</span><br><span class="line">                h &#x3D; 31 * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash &#x3D; h;</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>由于hashCode方法定义在Object类中，因为每个对象都有一个默认的散列码，Object类中的hashCode方法(native)的默认值是目标对象的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; &quot;Ok&quot;;&#x2F;&#x2F;2556</span><br><span class="line">StringBuilder sb &#x3D; new StringBuilder(s);&#x2F;&#x2F;20526976</span><br><span class="line">String t &#x3D; new String(&quot;Ok&quot;);&#x2F;&#x2F;2556</span><br><span class="line">StringBuilder tb &#x3D; new StringBuilder(t);&#x2F;&#x2F;20527144</span><br></pre></td></tr></table></figure>

<p>字符串s与t拥有相同的散列码，是因为字符串的散列码是由内容导出的，字符串内容相同，哪怕不是一个对象，其hashCode值也是相等的</p>
<p>字符串缓冲sb与tb却有着不同的散列码，是因为在StringBuilder类中没有定义hashcode方法，它的散列码是由Object类中的默认hashcode方法导出的对象存储地址</p>
<h4 id="hashCode方法必须与equals方法保持一致"><a href="#hashCode方法必须与equals方法保持一致" class="headerlink" title="hashCode方法必须与equals方法保持一致"></a>hashCode方法必须与equals方法保持一致</h4><p>如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中</p>
<p>Equals与hashCode的定义必须一致，如果x.equals(y)返回true,那么x.hashCode就必须与y.hashCode()具有相同的值，例如，如果定义Employee.equals比较雇员的ID,那么hashCode方法就需要单散列ID,而不是雇员的姓名或存储地址</p>
<p>如果存在数组类型的域，那么可以使用静态的Arrays.hashCode方法计算一个散列码，这个散列码由数组元素的散列码组成</p>
<h4 id="重写hashCode方法"><a href="#重写hashCode方法" class="headerlink" title="重写hashCode方法"></a>重写hashCode方法</h4><p>hashCode方法应该返回一个整形数值，并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Employee</span><br><span class="line">&#123;</span><br><span class="line">    public int hashCode()</span><br><span class="line">    &#123;</span><br><span class="line">        return 7 * name.hashCode()</span><br><span class="line">        + 11 * new Double(salary).hashCode()</span><br><span class="line">        + 13 * hireDay.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题一：null调用hashCode方法会报空指针异常</p>
<p>问题二：hashCode中还创建了大量对象</p>
<p>可以通过如下方式进行创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode()</span><br><span class="line">&#123;</span><br><span class="line">    return 7 * Objects.hashCode(name)</span><br><span class="line">    + 11 * Double.hashCode(salary)</span><br><span class="line">    + 13 * Objects.hashCode(hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode()</span><br><span class="line">&#123;</span><br><span class="line">	return Objects,hash(name, salary, hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>不同的类的toString方法存在差异，toString的写法有很多 </p>
<p>常用方法</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/016.png"  alt="Java核心卷——基础知识"></p>
<p>更好的方法</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/017.png"  alt="Java核心卷——基础知识"></p>
<p>设计子类时也可以将子类域的描述添加进行，父类的toString方法可以调用</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/018.png"  alt="Java核心卷——基础知识"></p>
<p>只要对象与一个字符串通过操作符+连接起来，Java编译就会自动地调用toString方法，以便获得这个对象的字符串描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point p &#x3D; new Point(10, 20);</span><br><span class="line">String message &#x3D; &quot;The current position is &quot; + p;</span><br><span class="line">&#x2F;&#x2F; automatically invokes p.toString()</span><br></pre></td></tr></table></figure>

<p>println方法就会直接地调用toString方法</p>
<p>Object定义了toString方法，用来打印对象所属的类名和散列码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;PrintStream类的设计者没有覆盖toString方法</span><br><span class="line">System.out.println(System.out)</span><br></pre></td></tr></table></figure>

<h4 id="数组的toString方法"><a href="#数组的toString方法" class="headerlink" title="数组的toString方法"></a>数组的toString方法</h4><p>数组继承了object类的toString方法，数组类型将按照旧的格式打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;[I表示a时一个整形数组</span><br><span class="line">int[] a &#x3D; &#123;1,23,3&#125;;</span><br><span class="line">System.out.println(a);</span><br><span class="line">----打印结果----------</span><br><span class="line">[I@100fc185</span><br></pre></td></tr></table></figure>

<p>修正的方法Arrays.toString</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] a &#x3D; &#123;1,23,3&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">----打印结果----------</span><br><span class="line">[1, 23, 3]</span><br></pre></td></tr></table></figure>

<p>如果要打印多维数组需要用 Arrays.deepToString </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[][] a &#x3D; &#123;&#123;1,23,3&#125;,&#123;3,5&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));&#x2F;&#x2F;[[I@100fc185, [I@643b1d11]</span><br><span class="line">------------------------------</span><br><span class="line">int[][] a &#x3D; &#123;&#123;1,23,3&#125;,&#123;3,5&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.deepToString(a));&#x2F;&#x2F;[[1, 23, 3], [3, 5]]</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>Java语言允许运行时确定数组的大小，但是一旦确定了数组的大小，改变它就不太容易了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int actualSize &#x3D; 6;</span><br><span class="line">Employee[] staff &#x3D; new Employee[actualSize];</span><br></pre></td></tr></table></figure>

<p>解决这个问题最简单的方法是使用Java中另外一个被称为ArrayList的类，在添加或删除元素时，具有自动调节数组容量的功能</p>
<p>ArrayList是一个采用类型参数的泛型类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">&#x2F;&#x2F;java7后可以省去右边的参数类型</span><br><span class="line">ArrayList&lt;Employee&gt; staff &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>ArrayList内部维护了一个数组，当数组用尽时，ArrayList将会自动创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中</p>
<p>设置ArrayList内部数组大小的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">staff.ensureCapacity(lOO);</span><br><span class="line">ArrayList&lt;Employee&gt; staff &#x3D; new ArrayListo(lOO);</span><br></pre></td></tr></table></figure>

<p>一旦能够确认 ArrayList的大小不再发生，就可以调用trimToSize方法，这个方法将存储区域的大小调整为当前元素所需要的存储空间数目。垃圾回收器将回收多余的存储空间</p>
<p>一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该在确认不会添加任何元素时，再调用trimToSize</p>
<h4 id="访问ArrayList元素"><a href="#访问ArrayList元素" class="headerlink" title="访问ArrayList元素"></a>访问ArrayList元素</h4><p>数组列表自动扩展容量的便利增加了访问元素语法的复杂程度</p>
<p>使用add方法为数组添加元素，而不要使用set方法，它只能替换数组中已经存在的元素内存</p>
<h4 id="一举两得的方法"><a href="#一举两得的方法" class="headerlink" title="一举两得的方法"></a>一举两得的方法</h4><p>既可以灵活地扩展数组，又可以方便地访问数组元素</p>
<p>1.创建一个ArrayList，并添加所有的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;X&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">while (. . .)</span><br><span class="line">&#123;</span><br><span class="line">    x &#x3D; ...;</span><br><span class="line">    list.add(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用toArray方法将数组元素拷贝到一个数组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X[] a &#x3D; new XPtst.size()];</span><br><span class="line">list.toArray(a);</span><br></pre></td></tr></table></figure>

<h3 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h3><p>所有的基本类型都有一个与之对应的类(包装器)</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/019.png"  alt="Java核心卷——基础知识"></p>
<p>String是一个类，不属于基本类型，对象包装器类是不可变的，一旦构造不可更改，同时包装器类也是final,因此不能定义它们的子类</p>
<p>Integer,Long,Float,Double,Short,Byte,Character,Void,Boolean都是包装器类，其中前六个类派生于公共的抽象父类Number</p>
<p>ArrayList尖括号中的类型参数不允许是基本类型，必须是包装类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; a  &#x3D; new ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<p>由于每个值分别包装在对象中，所以ArrayList<Integer>的效率远远低于int[]数组，因此只能用它构造小型数组</Integer></p>
<h4 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h4><p>list.add(3)会自动转换为list.add (Integer.value0f(3)); ，这个操作就是自动装箱</p>
<p> int n = list.get(i)会自动转换为 int n = list.get(i).intValue(); ，这个操作就是自动拆箱</p>
<p>算数表达式中也能够自动地装箱和拆箱，编译器将自动地插入一条对象拆箱的指令，然后进行自增计算，最后再将结果装箱(Integer不能++操作，int才可以)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n &#x3D; 3;</span><br><span class="line">n++;</span><br></pre></td></tr></table></figure>

<p>包装器类引用可以为null，所以自动装箱有可能会抛出一个NullPointerException</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n &#x3D; null;</span><br><span class="line">System.out.printing(2 * n); &#x2F;&#x2F; Throws NullPointerException</span><br></pre></td></tr></table></figure>

<p>如果在一个条件表达式中混合使用Integer和Double类型，Integer值就会拆箱，提升为double,再装箱为Double</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer n &#x3D; 1;</span><br><span class="line">Double x &#x3D; 2.0;</span><br><span class="line">System.out.println(true ? n : x); &#x2F;&#x2F; Prints 1.0</span><br></pre></td></tr></table></figure>

<p>装箱和拆箱是编译器认可的，而不是虚拟机，编译器在生成字节码时，插入必要的方法调用，虚拟机只是执行这些字节码</p>
<p>包装类中内置了许多常用的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; Integer.parselnt(s);</span><br></pre></td></tr></table></figure>

<h3 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(&quot;%d&quot;, n);</span><br><span class="line">System.out.printf(&quot;%d %s&quot;,n, &quot;widgets&quot;);</span><br><span class="line">------上面两种参数的方法调用的是同一个函数---------------</span><br><span class="line">public class PrintStream&#123;</span><br><span class="line">    public PrintStream printf(@NotNull String fmt , Object... args) &#123; </span><br><span class="line">    return format(fmt, args); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object…args表示这个方法可以接受任意数量的对象，fmt除外.printf方法接收两个参数，一个是格式字符串，另一个是Object[]数组，方法实现时主要是对数组进行操作</p>
<p>允许将一个数组传递给可变参数方法的最后一个参数,可以直接将数组作为可变参数传入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(&quot;%d %s&quot;,new Object[] &#123; new Integer(l), &quot;widgets&quot; &#125; );</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">public static void main(String...args)&#x2F;&#x2F;两种main方法参数都是合法的</span><br></pre></td></tr></table></figure>

<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public enum Size &#123; SMALL(&quot;S&quot;), MEDIUM(&quot;M&quot;), LARGE(&quot;L&quot;), EXTRA_LARGE(&quot;XL&quot;);&#125;;</span><br></pre></td></tr></table></figure>

<p>这个声明定义的类型是一个类，有四个实例，因此在比较两个枚举类型的值时，不需要调用equals，直接使用==就可以了</p>
<h4 id="toString，valueOf，values"><a href="#toString，valueOf，values" class="headerlink" title="toString，valueOf，values"></a>toString，valueOf，values</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;toString方法可以返回枚举常量名</span><br><span class="line">Size.SMALL.toString();&#x2F;&#x2F;SMALL</span><br><span class="line">&#x2F;&#x2F;toString的逆方法是静态方法valueOf，可以将常量名转换成枚举实例</span><br><span class="line">Size s &#x3D; Enum.valueOf(Size.class, &quot;SMALL&quot;);</span><br><span class="line">&#x2F;&#x2F;每个枚举类型都有一个静态的values方法，将返回一个包含全部枚举值的数值</span><br><span class="line">Size[] values &#x3D; Size.values();</span><br><span class="line">ordinal方法返回enum声明中枚举常量的位置，位置从0开始计数</span><br><span class="line">Size.MEDIUM.ordinal()&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>

<h4 id="枚举类构造函数"><a href="#枚举类构造函数" class="headerlink" title="枚举类构造函数"></a>枚举类构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public enum Size &#123;</span><br><span class="line">    small(&quot;s&quot;),</span><br><span class="line">    medial(&quot;m&quot;),</span><br><span class="line">    large(&quot;l&quot;),</span><br><span class="line">    big(&quot;b&quot;);</span><br><span class="line">    String canshu;</span><br><span class="line">    Size(String s)&#123;</span><br><span class="line">        this.canshu &#x3D; s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----调用-----------------------------------</span><br><span class="line">System.out.println(Size.big.canshu);&#x2F;&#x2F;b</span><br></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>能够分析类能力的程序称为反射</p>
<ol>
<li>在运行时分析类的能力</li>
<li>在运行时查看对象，例如，编写一个toString方法供所有类使用</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象</li>
</ol>
<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行</p>
<ul>
<li>Object类中的getClass()方法将会返回一个Class类型的实例。如果类在一个包里，包的名字也作为类名的一部分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(e.getClass().getName() + &quot; &quot; + e.getNameO);&#x2F;&#x2F;Employee Harry Hacker</span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过静态方法forName获得类名对应的Class对象。这个方法只有在className是类名或接口名时才能够执行，否则forName方法将会抛出一个checked exception(已检查异常)，无论何时使用这个方法，都应该提供一个异常处理器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String dassName &#x3D; &quot;java.util.Random&quot;;</span><br><span class="line">Class cl &#x3D; Cl ass.forName(dassName);</span><br></pre></td></tr></table></figure>

<p>程序启动时，main方法先被加载，之后它需要的类再被加载，所需类的所需类再被加载。对于大型应用程序而言，这将会消耗很多时间。在确保包含main方法的类没有显示地引用其他的类的前提下，显示一个启动画面，通过Class.forName手工地加载其他的类</p>
<ul>
<li>通过T.class获取Class类对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1l &#x3D; Random.class; &#x2F;&#x2F; if you import java.util</span><br><span class="line">Class cl2 &#x3D; int.class;</span><br><span class="line">Class cl3 &#x3D; Double[].class;</span><br></pre></td></tr></table></figure>

<p>一个Class类对象实际上表示的是一个类型，而这个类型未必一定是一种类，例如int.class也是一个Class而类型的对象</p>
<p>Class类实际上是一个泛型类，例如Employee.class的类型是Class<Employee></Employee></p>
<p>由于历史原因，getName方法在应用于数组类型的时候会返回一个很奇怪的名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Double[].class.getName() 返回[Ljava.lang.Double</span><br><span class="line">int[].class.getName( ) 返回[I</span><br></pre></td></tr></table></figure>

<p>虚拟机为每个类型管理一个Class对象，因此，可以利用==运算符比较两个类对象是否属于同一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(e.getClass()&#x3D;&#x3D;Employee.class)</span><br></pre></td></tr></table></figure>

<p>newInstance()可以动态地创建一个类的实例,创建一个与e具有相同类型的实例，newInstance方法调用默认的构造器(没有参数的构造器)初始化新创建的对象，如果这个类没有默认的构造器，就会抛出一个异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.getClass().newlnstance();</span><br></pre></td></tr></table></figure>

<p>将forName与newInstance配合使用，可以根据存储在字符串中的类名创建一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; &quot;java.util.Random&quot;;</span><br><span class="line">Object m &#x3D; Class.forName(s).newlnstance();</span><br></pre></td></tr></table></figure>

<p> 如果需要以这种方式向希望按名称创建的类的构造器提供参数， 就不要使用上面那条语句，而必须使用 Constructor 类中的 newlnstance 方法。 </p>
<h4 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h4><p>检查类的结构</p>
<p>java.lang.reflect包中有三个类Field,Method,Constructor分别用于描述类的域，方法和构造器</p>
<p>这三个类都有一个叫做getName的方法，用于返回项目的名称。Field类有一个getType方法，用来返回描述域所属类型的Class对象；</p>
<p>Method和Constructor类有能够报告参数类型的方法，Method类还有一个可以报告返回类型的方法</p>
<p>这三个类还有一个叫做getModifiers的方法，它将返回一个整形数值，用不同的位开关描述public,static这样的修饰符使用状况</p>
<p>可以利用java.lang.reflect包中的Modifier类的静态方法分析getModifiers返回的整形数值。例如可以使用Modifier类中的isPublic，isPrivate,isFinal判断方法或构造器是否是public,private，final</p>
<p>Class类中的getFields，getMethods,getConstructors方法将分别返回类提供的public域，方法，构造器数组，其中包括父类的公有成员</p>
<p> Class 类的 getDeclareFields、 getDeclareMethods 和 getDeclaredConstructors 方法将分别返回类中声明的全部域、 方法和构 造器， 其中包括私有和受保护成员，但不包括父类的成员 </p>
<h4 id="在运行时使用反射分析对象"><a href="#在运行时使用反射分析对象" class="headerlink" title="在运行时使用反射分析对象"></a>在运行时使用反射分析对象</h4><p>利用反射机制可以查看在编译时还不清楚的对象域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A a &#x3D; new A();</span><br><span class="line">System.out.println(a.getClass());</span><br><span class="line">Field f &#x3D; a.getClass().getDeclaredField(&quot;name&quot;);</span><br><span class="line">System.out.println(f);</span><br><span class="line">System.out.println(f.get(a));</span><br><span class="line">---------------------------------------------------</span><br><span class="line">class com.gzw.system.config.A</span><br><span class="line">public int com.gzw.system.config.A.a</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>这段代码存在一个问题，name如果是一个私有域，get方法将会爬出一个 IllegalAccessException ,除非拥有访问权限，否则Java安全机制只允许查看对象有那些域，而不允许读取它们的值</p>
<p>反射机制的默认行为受限于Java的访问控制，如果一个Java程序没有受到安全管理器的控制，就可以覆盖访问控制，为了达到这个目的，需要调用Field,Method,Constructor对象的setAccessible方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.setAtcessible(true);</span><br></pre></td></tr></table></figure>

<p>setAccessible方法是AccessibleObject类中的一个方法，它是Field,Method,Constructor类的公共父类。这个特性是为了调试，持久存储和相似机制提供的</p>
<p>get方法还有一个问题，name域是一个String,因此把它作为Object返回是没问题的，但是对于double类型的不是对象的salary域就无法正常使用get方法了。要想解决这个问题，可以使用Field类中getDouble方法,也可以调用get方法，此时反射机制将会自动地将这个域值打包到相应的对象包装器中</p>
<h4 id="使用反射编写泛型数组代码"><a href="#使用反射编写泛型数组代码" class="headerlink" title="使用反射编写泛型数组代码"></a>使用反射编写泛型数组代码</h4><p>java.lang.reflect包中的Array类允许动态地创建数组。将这个特性应用到Array类中的copyOf方法实现中，这个方法可以用于扩展已经填满的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee() a &#x3D; new Employee[100];</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; array is full</span><br><span class="line">a &#x3D; Arrays.copyOf(a, 2 * a.length);</span><br></pre></td></tr></table></figure>

<h5 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h5><p>通过badCopyOf这个方法存在一个问题，那就是返回的数组是Object类型的，一个Object数组不能转换为雇员数组。Java数组会记住每个元素的类型，将一个Employee[]临时地转换成Object[]数组，然后再把它转换回来是可以的，但一个从开始就是Object[]的数组却永远不能转换成Employee[]数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Object[] badCopyOf(Object[] a,int newLength)&#123;</span><br><span class="line">        Object[] newArray &#x3D; new Object[newLength];</span><br><span class="line">        System.arraycopy(a,0,newArray,0,Math.min(a.length,newLength));</span><br><span class="line">        return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组，需要使用java.lang.reflect包中Array类中的一些方法，其中最关键的是Array类中的静态方法newInstance,它能构造新数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object newArray &#x3D; Array.newlnstance(componentType , newLength);</span><br></pre></td></tr></table></figure>

<p>正确的写法，这个CopyOf方法可以用来扩展任意类型的数组，而不仅仅是对象对象数组，返回的Object可以转换成目标对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Object goodCopyOf(Object a, int newLength)&#123;</span><br><span class="line">        Class cl &#x3D; a.getClass();</span><br><span class="line">        if(!cl.isArray()) &#123;return null ;&#125;</span><br><span class="line">        Class componentType &#x3D; cl.getComponentType();</span><br><span class="line">        int length &#x3D; Array.getLength(a);</span><br><span class="line">        Object newArray &#x3D; Array.newInstance(componentType, newLength);</span><br><span class="line">        System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));</span><br><span class="line">        return newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能够实现上述操作，应该将goodCopyOf的参数声明位Object类型，而不要声明为对象型数组Object[]。整形数组类型int[]可以被转换成Object，但不能转换成对象数组</p>
<h3 id="调用任意方法？？？"><a href="#调用任意方法？？？" class="headerlink" title="调用任意方法？？？"></a>调用任意方法？？？</h3><p>Java没有提供方法指针，即将一个方法的存储地址传给另外一个方法，以便第二个方法能够随后调用它。方法指针是很危险的，并且常常带来隐患，Java提供的接口是一种更好的解决方法。除此以外，反射机制允许你调用任意方法</p>
<p>在Method类中有一个invoke方法，它允许调用包装在当前Method对象中的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object invoke(Object obj, Object... args)</span><br></pre></td></tr></table></figure>

<p>第一个参数是隐式参数，其余的对象提供了显式参数。对于静态方法，第一个参数可以被忽略，即可以设置为null，例如假设用ml代表Employee类的getName方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String n &#x3D; (String)ml.invoke(harry);</span><br></pre></td></tr></table></figure>

<p>如果返回类型是基本类型，invoke方法会返回其包装器类型，例如，假设m2表示Employee类的getSalary方法，那么返回的对象实际上是一个Double,必须相应地完成类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double s &#x3D; (Double) m2,invoke(harry);</span><br></pre></td></tr></table></figure>

<p>可以通过getMethod方法获取方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method getMethod(String name, Class... parameterTypes)</span><br></pre></td></tr></table></figure>

<p>如何获得Employee类的getName方法和raiseSalary方法的方法指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method ml &#x3D; Employee.class.getMethod(&quot;getName&quot;);</span><br><span class="line">Method m2 &#x3D; Employee.class.getMethod(&quot;raiseSalary&quot;, double.class);</span><br></pre></td></tr></table></figure>

<p>invoke的参数和返回值必须是Object类型的，这就意味着必须进行多次的类型转换，这样做会导致许多意外的错误</p>
<p>使用反射获得方法指针的代码比仅仅直接调用方法明显慢一些，建议仅在必要的时候才使用Method对象，最好使用接口以及lambda表达式</p>
<h2 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h2><ul>
<li>将公共操作和域放在父类</li>
<li>不要使用受保护的域，protected在一个包内都是可以被访问的，破坏了封装性</li>
<li>使用继承实现is-a关系</li>
<li>除非所有继承的方法都有意义，否则不要使用继承</li>
<li>在覆盖方法时，不要改变预期的行为</li>
<li>使用多态，而非类型信息,下面这种形式的代码应该考虑使用多态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (x is of type1)</span><br><span class="line">action1(x);</span><br><span class="line">else if (x is of type2)</span><br><span class="line">action2(x);</span><br></pre></td></tr></table></figure>

<ul>
<li>不要过多地使用多态，反射机制使得人们可以通过运行时查看域和方法，让人们编写出更具有通用性的程序，对于编写系统程序有用，不适用于编写应用程序，反射是很脆弱的，编译器很难发现相应的错误，只有在运行时才能发现错误并导致异常</li>
</ul>
<h1 id="接口，lambda表达式于内部类"><a href="#接口，lambda表达式于内部类" class="headerlink" title="接口，lambda表达式于内部类"></a>接口，lambda表达式于内部类</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义</p>
<p>Arrays类中的sort方法承诺可以对对象数组进行排序，但是要求满足下列条件</p>
<ul>
<li>对象所属类必须实现Comparable接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt;&#123;</span><br><span class="line">	int compareTo(Object other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>任何实现Comparable接口的类都需要包含compareTo方法</li>
</ul>
<p>接口中的所有方法自动地属于public，在接口中声明方法时，不必提供关键字，不过在实现接口的时候，必须把方法声明为public,否则，编译器将认为这个方法的访问属性是包可见的</p>
<p>接口中不能实现方法，不能出现实例，但是可以定义常量。可以将接口看作是没有实例的抽象类</p>
<p>不能构造接口的对象，但能声明接口的变量，接口变量必须引用实现了接口的类对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; new Comparable(. . .); &#x2F;&#x2F; ERROR</span><br><span class="line">Comparable x; &#x2F;&#x2F; OK</span><br><span class="line">x &#x3D; new Employee(. . .); &#x2F;&#x2F; OK provided Employee implements Comparable</span><br></pre></td></tr></table></figure>

<p>可以使用instance检查一个对象是否实现了某个特定的接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(anObject instanceof Comparable) &#123; . . . &#125;</span><br></pre></td></tr></table></figure>

<p>接口是可以被扩展继承的，接口中不能包含实力域或静态方法，但却可以包含常量，常量可以被实现类调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Powered extends Moveable&#123;</span><br><span class="line">	double milesPerCallon();</span><br><span class="line">	double SPEED.</span><br><span class="line">	LIHIT &#x3D; 95; &#x2F;&#x2F; a public static final constant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中的方法都自动地被设置为public，接口中的域将被自动设为public static final。但是Java语言不建议使用多余的关键字</p>
<h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p>接口是用于扩展类的约束，抽象类则是表示通用属性。并且Java是单继承的，抽象类有局限</p>
<p>接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性</p>
<p>静态方法</p>
<p>Java SE8中，允许在接口中增加静态方法，这有违将接口作为抽象规范的初衷，通常的做法是将静态方法放在伴随类中，接口中写静态方法可以减少伴随类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Path&#123;</span><br><span class="line">	public static Path get(String first, String... more) &#123;</span><br><span class="line">		return Fi1eSystems.getDefault().getPath(first, more);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来，实现get方法的Paths类就不必存在了，不过重构整个Java库是不太可能的</p>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>可以给接口方法提供一个默认实现，必须用default修饰符标记这样一个方法，设置default的接口方法就不用再被实现了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt;&#123;</span><br><span class="line">	default int compareTo(T other) &#123; return 0; &#125;</span><br><span class="line">	&#x2F;&#x2F; By default, all elements are the same</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java API中，很多接口都有相应的伴随类，这个伴随类中实现了相应接口的部分或所有方法， 如 Collection/AbstractCollection 或 MouseListener/MouseAdapter ,在Java8中，这个技术已经过时了，现在可以直接在接口中实现方法</p>
<h3 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h3><p>如果先在一个接口中将一个方法定义为默认方法，然后又在父类或者另外一个接口中定义了同样的方法，Java会怎样处理二义性</p>
<p>父类优先，如果父类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略</p>
<p>接口冲突，如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法(无论是否是默认方法)，那么就会报出一个编译错误，让程序员来解决这个二义性</p>
<p>一个类扩展了一个父类，同时实现了一个接口，并从父类和接口继承了相同的方法，这种情况下，只会考虑父类方法，接口的所有默认方法都会被忽略，即类优先原则，可以保证为一个接口增加默认方法，这对于有这个默认方法之前能正常工作的代码不会有任何影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Student extends Person implements Named &#123; . . . &#125;&#x2F;&#x2F;Person和Named中有重名的方法</span><br></pre></td></tr></table></figure>

<p>不要让一个接口默认的方法重新定义Object类中的某个方法。由于类优先原则，这些接口中定义的方法会直接被Object中的方法所覆盖，起不到作用</p>
<h2 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h2><h3 id="对象的克隆"><a href="#对象的克隆" class="headerlink" title="对象的克隆"></a>对象的克隆</h3><p>引用一个对象创建副本，任何一个对象的变化都会影响到另外一个对象。如果希望是复制的新对象只是初始状态与复制对象相同，复制之后二者各自有自己的状态，就要使用copy方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee original &#x3D; new Employee(&quot;John Public&quot;, 50000);</span><br><span class="line">Employee copy &#x3D; original;</span><br><span class="line">&#x2F;&#x2F;复制对象</span><br><span class="line">Employee copy &#x3D; original.clone();</span><br></pre></td></tr></table></figure>

<p>clone方法是一个protected方法，你的代码不能直接调用这个方法，只有Employee类可以克隆Employee对象，如果对象包含子对象的引用，拷贝域就会就会得到相同子对象的另一个引用，这样一来，原对象的克隆的对象仍然会共享一些信息</p>
<p>Cloneable接口出现与接口的正常使用没有关系，但是如果一个对象请求克隆，但是没有实现这个接口，就会生成一个受查异常，它唯一的作用就是允许在类型查询中使用instanceof,建议自己的程序中不要使用标记接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(obj instanceof Cloneable) . . .</span><br></pre></td></tr></table></figure>

<p>如果在一个对象上调用clone,但是这个对象的类并没有实现Cloneable接口，Object类的clone方法就会抛出一个CloneNotSupportedException</p>
<p>必须当心子类的克隆，一旦Employee类定义了clone方法，任何人都可以用它来克隆Manager对象</p>
<p>所有数组类型都有一个public的clone方法，而不是protected，可以用这个方法建立一个新的数组，包含原数组所有元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] luckyNumbers &#x3D; &#123; 2, 3, 5, 7, 11, 13 &#125;;</span><br><span class="line">int[] cloned &#x3D; luckyNumbers.clone();</span><br><span class="line">cloned[5] &#x3D; 12; &#x2F;&#x2F; doesn&#39;t change luckyNumbers[5]</span><br></pre></td></tr></table></figure>

<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><h3 id="为什么要引入lambda表达式"><a href="#为什么要引入lambda表达式" class="headerlink" title="为什么要引入lambda表达式"></a>为什么要引入lambda表达式</h3><p>lambda表达式是一个可传递的代码块，可以在以后执行一次或者多次。到目前为止，在Java中传递一个代码段并不容易，不能直接传递代码段，只能构造一个包含所需代码的类对象</p>
<h3 id="lambda表达式式的语法"><a href="#lambda表达式式的语法" class="headerlink" title="lambda表达式式的语法"></a>lambda表达式式的语法</h3><p>传入代码来检查一个字符串是否比另一个字符串短</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line">-&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure>

<p>lambda表达式就是一个代码块，以及必须传入代码的变量规范，lambda表达式形式：参数，箭头以及一些表达式，如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在{}中，并包含显示的return语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		if (first.length() &lt; second.length()) return -1;</span><br><span class="line">		else if (first.length() &gt; second.length()) return 1;</span><br><span class="line">		else return 0;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123; for (int i &#x3D; 100;i &gt;&#x3D; 0;i ) System.out.println(i); &#125;</span><br></pre></td></tr></table></figure>

<p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型,即编译器可以推导出first和second必然是字符串，因为这个lambda表达式将赋给一个字符串比较器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp &#x3D; (first, second) &#x2F;&#x2F; Same as (String first, String second)</span><br><span class="line">-&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure>

<p>如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActionListener listener &#x3D; event -&gt;</span><br><span class="line">System.out.println(&quot;The time is &quot; + new Date()&quot;);</span><br><span class="line">&#x2F;&#x2F; Instead of (event) -&gt; . . . or (ActionEvent event) -&gt; . . .</span><br></pre></td></tr></table></figure>

<p>无需指定lambda表达式的返回类型，lambda表达式的返回类型总是会由上下文推导得出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure>

<p>如果一个lambda表达式只是在某些分支返回一个值，而在另一些分支不返回值，这是不合法的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(int x)-&gt; &#123; if(x &gt;&#x3D; 0) return 1; &#125;&#x2F;&#x2F;不合法</span><br></pre></td></tr></table></figure>

<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Java中已经有很多封装代码块的接口，如ActionListener或Comparator，lambda表达式与这些接口是兼容的</p>
<p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口就是函数式接口</p>
<p>Arrays.sort()方法的第二个参数需要一个Comparator实例，Comparator就是只有一个方法的接口，所以可以提供一个lambda表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words,(first, second) -&gt; first.length() - second.length()) ;</span><br></pre></td></tr></table></figure>

<p>最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lambda表达式可以传递到函数式接口，lambda表达式可以转换成接口，这一点让lambda表达式很有吸引力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Timer t &#x3D; new Timer(1000, event -&gt;</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(&quot;At the tone, the time is &quot; + new DateO);</span><br><span class="line">	Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lambda表达式所能做的也只是能转换为函数式接口，甚至不能将表达式赋给Object变量，Object不是一个函数式接口</p>
<p>java.util.function包中定义了很多非常常用的函数式接口，其中BiFunction&lt;T,U,R&gt;描述了参数类型为T和U而且返回类型为R的函数，可以把我们的字符串比较lambda表达式保存在这个类型变量中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;String, String, Integer&gt; comp &#x3D; (first, second) -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure>

<p>没有方法会想接受一个BiFunction，需要为它建立一个特定的函数式接口，java.util.function包中有一个尤其有用的接口Predicate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Predicate&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	boolean test(T t);&#x2F;&#x2F; Additional default and static methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList类有一个removeIf方法，它的参数就是一个Predicate，这个接口专门用来传递lambda表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.removelf(e -&gt; e &#x3D;&#x3D; null);&#x2F;&#x2F;从一个数组列表中删除所有的null值</span><br></pre></td></tr></table></figure>

<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>已经有现成的方法可以完成你想要传递到其他代码的某个动作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timer t &#x3D; new Timer(1000, event -&gt; System.out.println(event)):</span><br></pre></td></tr></table></figure>

<p>System.out::println是一个方法的引用，等价于 x 一&gt; System.out.println(x) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timer t &#x3D; new Timer(1000, System.out::println);</span><br></pre></td></tr></table></figure>

<p>如果想要对字符串排序，而不考虑字母的大小写，可以传递以下方法表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(strings，String::conpareToIgnoreCase)</span><br></pre></td></tr></table></figure>

<p>以上的例子可以看出，要用::操作符分割方法名与对象或类名，主要有以下三种情况：</p>
<ol>
<li>object::instanceMethod </li>
<li>Class::staticMethod </li>
<li>Class::instanceMethod </li>
</ol>
<p>前两种情况，方法引用等价于提供方法参数的lambda表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out::println 等价于 x -&gt; System.out.println(x)</span><br><span class="line">Math::pow 等价于（x，y) -&gt;Math.pow(x, y)</span><br></pre></td></tr></table></figure>

<p>对于第三种情况，第一个参数会成为方法的目标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::compareToIgnoreCase 等同于 (x, y) -&gt; x.compareToIgnoreCase(y)</span><br></pre></td></tr></table></figure>

<p>可以在方法引用中使用this参数，同样使用super也是合法的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this::equals 等同于 x -&gt; this.equals(x)</span><br></pre></td></tr></table></figure>

<h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器与方法引用类似，只不过方法名为new，map方法会为各个列表元素调用Person(String)构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names &#x3D; . . .;</span><br><span class="line">Stream&lt;Person&gt; stream &#x3D; names.stream().map(Person::new);</span><br><span class="line">List&lt;Person&gt; people &#x3D; stream.col1ect(Col1ectors.toList());</span><br></pre></td></tr></table></figure>

<p>可以用数组类型建立构造器引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[]::new等价与x -&gt; new int[x]</span><br></pre></td></tr></table></figure>

<p>Java无法构造泛型类型T的数组，数组构造器引用克服了这个问题，例如,假设需要一个Person对象数组，Stream接口有一个toArray方法可以返回Object数组，但是用户希望得到的是Person数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] people &#x3D; stream.toArray();</span><br></pre></td></tr></table></figure>

<p>运用构造器引用的方法就可以构造出目标类型的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] people &#x3D; stream.toArray(Person[]::new):</span><br></pre></td></tr></table></figure>

<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>通常我们会希望能够在lambda表达式中访问外围方法或类中的变量,repeatMessage方法被调用后很久lambda表达式才会被运行，而那时这个参数变量已经不存在了，如何保留text变量？需要在方法内部保存这个自由变量的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void repeatMessage(String text, int del ay)</span><br><span class="line">&#123;</span><br><span class="line">	ActionListener listener &#x3D; event -&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(text):</span><br><span class="line">		Toolkit.getDefaultToolkitO.beep():</span><br><span class="line">	&#125;;</span><br><span class="line">	new Timer(delay, listener).start();</span><br><span class="line">&#125;</span><br><span class="line">----------------调用------------------------------</span><br><span class="line">repeatMessage(&quot;Hello&quot;, 1000); &#x2F;&#x2F; Prints Hello every 1,000 milliseconds</span><br></pre></td></tr></table></figure>

<p>lambda有三个部分</p>
<ol>
<li>一个代码块</li>
<li>参数</li>
<li>自由变量的值，这是指非参数而且不在代码中定义的变量</li>
</ol>
<p>可以把lambda表达式转换为包含一个方法的对象，这样自由变量的值就会复制到这个对象的实例变量中</p>
<p>代码块以及自由变量有一个术语叫做闭包</p>
<p>lambda表达式可以捕获外围作用域中变量的值，要确保所捕获的值是明确定义的，只能引用值不会发生改变的变量，下面的做法是不合法的，这个限制的主要原因是，如果在lambda表达式中改变变量，并发执行多个操作时是不安全的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void countDown(int start, int delay)</span><br><span class="line">&#123;</span><br><span class="line">	ActionListener listener &#x3D; event -&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		start ; &#x2F;&#x2F; Error: Can&#39;t mutate captured variable</span><br><span class="line">		System.out.println(start);</span><br><span class="line">	&#125;；</span><br><span class="line">	new Timer(del ay, listener),start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在lambda表达式中引用变量，而这个变量可能在外部发生改变，这也是不合法的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void repeat(String text, int count)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; count; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ActionListener listener &#x3D; event -&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print1n(i + &quot;: &quot; + text);&#x2F;&#x2F; Error: Cannot refer to changing i</span><br><span class="line">		&#125;;</span><br><span class="line">		new Timer(1000, listener).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lambda表达式中捕获的变量必须实际上是最终变量，这个变量初始化之后就不会再为它赋新值</p>
<p>lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Path first &#x3D; Paths.get(&quot;&#x2F;usr&#x2F;bin&quot;);</span><br><span class="line">Comparator&lt;String&gt; comp &#x3D;</span><br><span class="line">	(first, second) -&gt; first.length() - second.length();</span><br><span class="line">&#x2F;&#x2F;Error: Variable first already defined</span><br></pre></td></tr></table></figure>

<p>在lambda中使用this关键字，是指创建这个lambda表达式的方法的this参数,表达式this.toString()会调用Application对象的toString方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Application()</span><br><span class="line">&#123;</span><br><span class="line">	public void init()</span><br><span class="line">	&#123;</span><br><span class="line">		ActionListener listener &#x3D; event -&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(this.toString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类是定义在另外一个类中的类，使用内部类的原因如下</p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据</li>
<li>内部类可以对同一个包中的其他类隐藏起来</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷</li>
</ol>
<h3 id="使用内部类访问对象状态"><a href="#使用内部类访问对象状态" class="headerlink" title="使用内部类访问对象状态"></a>使用内部类访问对象状态</h3><p>构造一个语言时钟时需要提供两个参数：发布通告的间隔和开关铃声的标志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TalkingClock</span><br><span class="line">&#123;</span><br><span class="line">	private int interval:</span><br><span class="line">	private boolean beep;</span><br><span class="line">	public TalkingClock(int interval, boolean beep) &#123; . . . &#125;</span><br><span class="line">	public void start0 &#123; . . . &#125;</span><br><span class="line">	&#x2F;&#x2F; an inner class</span><br><span class="line">	public class TimePrinter implements ActionListener</span><br><span class="line">	&#123;</span><br><span class="line">        public void actionPerformed(ActionEvent event)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(&quot;At the tone, the time is &quot; + new date();)</span><br><span class="line">			if (beep) Toolkit.getDefaultToolkit().beep()；</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimePrinter内部类没有实例域或者名为beep的变量，取而代之的是beep引用了创建TimePrinter的TalkingClock对象的域。一个方法可以引用调用这个方法的对象数据域，内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域</p>
<p>内部类的对象总是有一个隐式引用，它指向了创建它的外部类对象，这个引用在内部类定义中是不可见的，我们将外围类对象的引用成为outer，于是actionPerformed方法等价于下列形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void actionPerformed(ActionEvent event)&#123;</span><br><span class="line">	System.out.println(&quot;At the tone, the time is &quot; + new Date());</span><br><span class="line">	if (outer.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外围类的引用在构造器中设置，编译器修改了所有的内部类的构造器，添加了一个外围类引用的参数，因为TimePrinter类没有定义构造器，所以编译器为这个类生成了一个默认的构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public TimePrinter(TalkingGock clock)&#123;</span><br><span class="line">	outer &#x3D; clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimePrinter类可以声明为私有的，这样只有TalkingClock的方法才能够构造TimePrinter对象。只有内部类可以是私有类，而常规类只可以具有包可见性或公有可见性</p>
<h3 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h3><p>可以像下面这样调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void actionPerformed(ActionEvent event)&#123;</span><br><span class="line">	if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用内部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TalkingClock jabberer &#x3D; new Ta1kingClock(1000, true);</span><br><span class="line">TalkingClock.TimePrinter listener &#x3D; jabberer.new TimePrinter();</span><br></pre></td></tr></table></figure>

<p>我们希望一个静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例，如果这个域不是final，它可能就不是唯一的，所以内部类中声明的所有静态域对象都必须是final</p>
<p>内部类不能有static方法，有静态方法，那么内部类就只能访问外围类的静态域和方法</p>
<h3 id="内部类是否有用，必要和安全？？？"><a href="#内部类是否有用，必要和安全？？？" class="headerlink" title="内部类是否有用，必要和安全？？？"></a>内部类是否有用，必要和安全？？？</h3><p>内部类是一种编译器现象，与虚拟机无关，编译器将会把内部类翻译成$分割外部类名与内部类名的常规类文件，而虚拟机对此一无所知，例如在TalkingClock类内部的TimePrinter类将被翻译为TalkingClock$TimePrinter.class</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部类不能用 public或private访问说明符进行声明，它的作用域被限定在声明这个局部类的块中</p>
<p>局部类有一个优势，即对外部世界可以完全地隐藏起来，即使TalkingClock类中的其他代码也不能访问它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在方法中定义内部类就是局部内部类</span><br><span class="line">public void start()</span><br><span class="line">&#123;</span><br><span class="line">	class TimePrinter implements ActionListener</span><br><span class="line">	&#123;</span><br><span class="line">		public void actionPerformed(ActionEvent event)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(&quot;At the tone, the tone is &quot; + new Date())；</span><br><span class="line">			if (beep) Toolkit.getDefaultToolkit().beep():</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ActionListener listener &#x3D; new TimePrinter();</span><br><span class="line">	Timer t &#x3D; new Timer(interva1, listener);</span><br><span class="line">	t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>将局部内部类的使用加深一步，如果只创建这个类的一个对象，就不必命名了，这种类被成为匿名内部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void start(int interval,boolean beep)</span><br><span class="line">&#123;</span><br><span class="line">	ActionListener listener &#x3D; new ActionListener()</span><br><span class="line">	&#123;</span><br><span class="line">		public void actionPerformed(ActionEvent event)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(&quot;At the tone, the tone is &quot; + new Date())；</span><br><span class="line">			if (beep) Toolkit.getDefaultToolkit().beep():</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	Timer t &#x3D; new Timer(interva1, listener);</span><br><span class="line">	t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个实现ActionListener接口的类的新对象，需要实现的方法actionPerformed定义在括号{}内，通常的语法格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明对象的同时也带上了内部类</span><br><span class="line">new SuperType(construction parameters)</span><br><span class="line">&#123;</span><br><span class="line">	inner class methods and data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器，取而代之的是，将构造器参数传递给父类构造器。尤其是在内部类实现接口的时候，不能有任何构造参数，还要像下面这样提供一组括号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person queen &#x3D; new Person(&quot;Mary&quot;);&#x2F;&#x2F; a Person object</span><br><span class="line">Person count &#x3D; new Person(&quot;Dracula&quot;) &#123; . . .&#125;; &#x2F;&#x2F; an object of an inner class extending Person</span><br></pre></td></tr></table></figure>

<p>使用lambda表达式优于使用匿名内部类来做事件监听器和其他回调，前者要简洁得多</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void sta「t(int interval, boolean beep)</span><br><span class="line">&#123;</span><br><span class="line">	Timer t &#x3D; new Timer(interval, event -&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		....</span><br><span class="line">	&#125;);</span><br><span class="line">	t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双括号初始化构造一个数组列表，并将它传递到一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; friends &#x3D; new ArrayList();</span><br><span class="line">friends,add(&quot;Harry&quot;);</span><br><span class="line">friends,add(&quot;Tony&quot;);</span><br><span class="line">invite(friends);</span><br><span class="line">--------------------匿名内部类写法--------------------------------</span><br><span class="line">invite(new ArrayList&lt;String&gt;() &#123;&#123; add(&quot;Harry&quot;); add(&quot;Tony&quot;); &#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>注意这里的双括号，外层括号建立了ArrayList的一个匿名子类，内层括号则是一个对象构造块</p>
<p>建立一个与父类大体相似(但不完全相同)的匿名子类通常会很方便。不过对于equals方法要特别当心，对匿名内部类进行测试时会失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (getClass() !&#x3D; other.getClass()) return false;</span><br></pre></td></tr></table></figure>

<p>生成日志或者调试信息时，通常希望包含当前类的类名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.err.println(&quot;Something awful happened in &quot; + getClass());</span><br></pre></td></tr></table></figure>

<p>不过这对于静态方法不奏效，调用getClass时调用的是this.getClass()，而静态方法没有this,所以应该使用以下表达式。new Object(){}会建立Object的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Object()&#123;&#125;.getCIass().getEndosingClass() &#x2F;&#x2F; gets class of static method</span><br></pre></td></tr></table></figure>

<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>有时候使用内部类只是为了把一个类隐藏在另一个类的内部，并不需要内部类引用外围类对象，为此，可以将内部类声明为static,以便取消产生的引用</p>
<p>典型例子：计算数组中最大值与最小值的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double min &#x3D; Double.POSITIVE_INFINITY;</span><br><span class="line">double max &#x3D; Double.NECATIVE.</span><br><span class="line">INFINITY;</span><br><span class="line">for (double v : values)</span><br><span class="line">&#123;</span><br><span class="line">	if (min &gt; v) min &#x3D; v;</span><br><span class="line">	if (max &lt; v) max &#x3D; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法必须返回两个数值，为此，可以定义一个包含两个值的类pair</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Pair</span><br><span class="line">&#123;</span><br><span class="line">	private double first;</span><br><span class="line">	private double second;</span><br><span class="line">	public Pair(double f, double s)</span><br><span class="line">	&#123;</span><br><span class="line">		first &#x3D; f;</span><br><span class="line">		second &#x3D; s;</span><br><span class="line">	&#125;</span><br><span class="line">	public double getFirst() &#123; return first; &#125;</span><br><span class="line">	public double getSecond() &#123; return second; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>minmax方法可以返回一个pair类型的对象，Pair是一个十分大众化的名字，在大型项目中，可能存在多个Pair类，为了避免名字冲突，可以将Pair定义为ArrayAlg的内部公有类，此后通过ArrayAlg.Pair访问它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayAlg.Pair p &#x3D; ArrayAlg.minmax(d);</span><br></pre></td></tr></table></figure>

<p>因为Pair对象中不需要引用任何其他的对象，可以将这个内部类声明为static</p>
<p>声明在接口中的内部类自动成为static和public类</p>
<h2 id="代理？？？"><a href="#代理？？？" class="headerlink" title="代理？？？"></a>代理？？？</h2><p>利用代理可以创建一个试下了一组给定接口的新类，这种功能只有在编译时无法却确定需要哪个接口时才有必要使用</p>
<h3 id="何时使用代理"><a href="#何时使用代理" class="headerlink" title="何时使用代理"></a>何时使用代理</h3><p>假设有一个表示接口的Class对象(有可能只包含一个接口)，它的确切类型在编译时无法知道。要想构造一个实现这些接口的类，就需要使用newInstance方法或反射找出这个类的构造器，但是这不能实例化一个接口，需要在程序处于运行状态时定义一个新类</p>
<p>为了解决这个问题，有些程序将会生成代码，将这些代码放置在一个文件夹中，调用编译器，然后再加载结果类文件，这样做会很慢，并且需要将编译器与程序放在一起，而代理机制则是一种更好的解决方案。代理类可以在运行时创建全新的类，这样的代理类能够实现指定的接口，且具有下列方法：</p>
<ol>
<li>指定接口所需要的全部方法</li>
<li>Object类中的全部方法，例如toString,equals等</li>
</ol>
<p>不能在运行时定义这些方法的新代码，而是要提供给一个调用处理器，调用处理器是实现了InvocationHandler接口的类对象，在这个接口中只有一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object invoke(Object proxy, Method method, Object[] args)</span><br></pre></td></tr></table></figure>

<p>无论何时调用代理对象的方法，调用处理器的invoke方法都会被调用，并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式</p>
<h3 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h3><p>要像创建一个代理对象，需要使用Proxy类的newProxyInstance方法，这三个方法有三个参数</p>
<ol>
<li>一个类加载器</li>
<li>一个Class对象数组，用null表示使用默认的类加载器</li>
<li>一个调用处理器</li>
</ol>
<h1 id="异常，断言和日志"><a href="#异常，断言和日志" class="headerlink" title="异常，断言和日志"></a>异常，断言和日志</h1><p>发生问题时应该保证以下几点：</p>
<ol>
<li>向用户通告错误</li>
<li>保存所有的工作结果</li>
<li>允许用户以妥善的形式退出程序</li>
</ol>
<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/020.png"  alt="Java核心卷——基础知识"></p>
<p>所有的异常都是由Throwable继承而来，但在下一层立即分解成两个分支：Error和Exception</p>
<p>Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误，应用程序不应该抛出这样的错误</p>
<p>Exception层次结构分为两个分支：一个分支派生于RuntimeException;另一个分支包含其他异常，划分两个分支的规则是：由程序错误导致的异常RuntimeException；而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常</p>
<h3 id="RuntimeException异常"><a href="#RuntimeException异常" class="headerlink" title="RuntimeException异常"></a>RuntimeException异常</h3><p>1.错误的类型转换</p>
<p>2.数组访问越界</p>
<p>3.访问null指针</p>
<h3 id="IO异常"><a href="#IO异常" class="headerlink" title="IO异常"></a>IO异常</h3><p>1.试图在文件尾部后面读取数据</p>
<p>2.试图打开一个不存在的文件</p>
<p>3.试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在</p>
<p>如果出现RuntimeException异常，那么一定是开发者应该解决的问题。应该通过检查数组下标是否越界来避免ArrayIndexOutOfBoundsException异常；应该通过在使用变量之前检测是否为null来杜绝NullPointerException异常的发生</p>
<p>派生于Error类或RuntimeException类的所有异常称为非受查异常，所有其他的异常称为受查异常，编译器将核查是否为所有的受查异常提供了异常处理器</p>
<p>RuntimeException这个名字容易让人混淆，实际上现在讨论的所有错误都发生在运行时</p>
<h2 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a>声明受查异常</h2><p>一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误，例如一段读取文件的代码知道有可能读取的文件不存在或者内容为空，因此，试图处理文件信息的代码就需要通知编译器可能会抛出IOException类的异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Fi1eInputStream(String name) throws FileNotFoundException</span><br></pre></td></tr></table></figure>

<p>编写方法时，不必将所有可能抛出的异常都进行声明，至于什么时候需要在方法中用throws子句声明异常，需要记住下面四种情况时应该抛出异常：</p>
<ul>
<li><p>调用一个抛出受查异常的方法，例如FileInputStream构造器</p>
</li>
<li><p>程序运行过程中发现错误，并且利用throw语句抛出一个受查异常</p>
</li>
<li><p>程序出现错误，例如a[-1]=0会抛出一个ArrayIndexOutOfBoundsException这样的非受查异常</p>
</li>
<li><p>Java虚拟机和运行时库出现的内部错误</p>
</li>
</ul>
<p>前两种情况必须告诉调用这个方法的程序员有可能抛出异常，因为任何一个抛出异常的方法都有可能是一个死亡陷阱，如果没有处理器捕获这个异常，当前执行的线程就会结束。对于那些可能被他人使用的Java方法，应该根据异常规范在方法的首部声明这个方法可能抛出的异常</p>
<p>不需要声明Java的内部错误，即从Error继承的错误，任何程序代码都具有抛出那些异常的潜能，而我们对其没有任何控制能力</p>
<p>同样也不应该声明从RuntimeException继承的那些非受查异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void drawImage(int i) throws ArraylndexOutOfBoundsException &#x2F;&#x2F; bad style</span><br></pre></td></tr></table></figure>

<p>error和RunTimeException都是非受查错误，是不需要抛出异常的，这些异常本生就具有抛出异常的能力，需要人为抛出异常的是受查异常，也就是从IOException中衍生出的异常</p>
<p>一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制，要么就应该避免发生，如果方法没有声明所有可能发生的受查异常，编译器就会发出一个错误消息</p>
<p>如果在子类中覆盖了一个父类方法，子类方法中声明的受查异常不能比父类方法中声明的异常更通用，也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常。如果父类没有抛出任何受查异常，子类也不能抛出任何受查异常</p>
<p>如果类中的一个方法声明将会抛出一个异常，而这个异常是某个特定类的实例时，则这个方法就有可能抛出一个这个类的异常，或者这个类的任意一个子类的异常</p>
<h3 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h3><p>对于一个已经存在的异常类，将其抛出非常容易</p>
<ul>
<li><p>找到一个合适的异常类</p>
</li>
<li><p>创建这个类的一个对象</p>
</li>
<li><p>将对象抛出</p>
</li>
</ul>
<p>一旦方法抛出异常，这个方法就不可能返回到调用者，也就是说，不必为返回的默认值或错误代码担忧</p>
<h3 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h3><p>定义一个派生于Exception的类，或者派生于Exception子类的类，习惯上定义的类应该包含两个构造器，一个是默认的构造器；另一个是带有详细描述信息的构造器(父类的Throwable的tostring方法将会打印这些详细信息，在调式的时候非常有用)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class FileFormatException extends IOException&#123;</span><br><span class="line">	public FileFormatExceptionO &#123;&#125;</span><br><span class="line">	public FileFormatException(String gripe)</span><br><span class="line">	&#123;</span><br><span class="line">		super(gripe);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>发生异常而不进行捕获会导致程序终止执行，并在控制台答打印出异常信息，其中包括异常的类型和堆栈的内容</p>
<p>要想捕获一个异常，必须设置try/catch语句块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	more code</span><br><span class="line">&#125;</span><br><span class="line">catch (ExceptionType e)</span><br><span class="line">&#123;</span><br><span class="line">	handlerfor this type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在try语句块中的任何代码抛出了一个catch子句中说明的异常类，那么程序将跳过try语句块的其余代码，程序将执行catch子句中的处理器代码</p>
<p>如果在try语句块中的代码没有抛出任何异常，那么程序将跳过catch子句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void read(String filename)</span><br><span class="line">&#123;</span><br><span class="line">	try</span><br><span class="line">	&#123;</span><br><span class="line">		InputStream in &#x3D; new Filei叩utStream(filename);</span><br><span class="line">		int b;</span><br><span class="line">		while ((b &#x3D; in.read()3 !&#x3D; -1)</span><br><span class="line">		&#123;</span><br><span class="line">			process input</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException exception)</span><br><span class="line">	&#123;</span><br><span class="line">		exception.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好的选择是什么都不做，将这个异常传递给调用者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void read(String filename) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">	InputStream in &#x3D; new Filel叩utStream(filename);</span><br><span class="line">	int b;</span><br><span class="line">	while ((b &#x3D; in.read() !&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		process input</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常进行传递</p>
<p>如果编写一个覆盖父类的方法，而这个方法又没有抛出异常，那么这个方法就必须捕获方法代码中出现的每一个受查异常，不允许向上抛出，即不允许子类的throws说明符中出现超过父类方法所列出的异常类范围</p>
<h3 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	code that might throwexceptions</span><br><span class="line">&#125;</span><br><span class="line">catch (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">	emergencyactionfor missingfiles</span><br><span class="line">&#125;</span><br><span class="line">catch (UnknownHostException e)</span><br><span class="line">&#123;</span><br><span class="line">	emergency actionfor unknown hosts</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">	emergencyactionfor all other I&#x2F;O problems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过异常对象获取异常信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.getMessage();&#x2F;&#x2F;获取异常信息</span><br><span class="line">e.getClass().getName();&#x2F;&#x2F;得到异常对象的实际类型</span><br></pre></td></tr></table></figure>

<p>同一个catch子句中可以捕获多个异常类型。对应缺少文件和未知主机异常的动作是一样的，可以合并catch子句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	code that might throw exceptions</span><br><span class="line">&#125;</span><br><span class="line">catch (FileNotFoundException | UnknownHostException e)</span><br><span class="line">&#123;</span><br><span class="line">    emergency action for missing files and unknown hosts</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">	emergency action for all other I&#x2F;O problems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕获多个异常时，异常变量隐含为final变量，例如不能再以下子句体中为e赋不同的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch (FileNotFoundException | UnknownHostException e) &#123; . . . &#125;</span><br></pre></td></tr></table></figure>

<h3 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h3><p>在catch子句中可以抛出一个异常，这样做的目的是改变异常的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	access the database</span><br><span class="line">&#125;</span><br><span class="line">catch (SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">	throw new ServletException(&quot;database error: &quot; + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServletException用带有异常信息文本的构造器来构造。有以一种更好的处理方法，将原始异常设置为新异常的原因</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	access the database</span><br><span class="line">&#125;</span><br><span class="line">catch (SQLException e)</span><br><span class="line">	Throwable se &#x3D; new ServletException (&quot;database error&quot;);</span><br><span class="line">	se.initCause(e);</span><br><span class="line">	throw se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当捕获到异常的时，就可以使用下面这条语句重新得到原始异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Throwable e &#x3D; se.getCause();</span><br></pre></td></tr></table></figure>

<p>强烈建议使用这种包装技术，这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节</p>
<p>如果在一个方法中发生了一个受查异常，而不允许抛出它，那么包装技术就十分有用，我们可以捕获这个受查异常，并将它包装成一个运行时异常</p>
<p>如果只想记录一个异常，再将它重新抛出，而不做任何改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	access the database</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">	logger.log(level, message, e);</span><br><span class="line">	throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h3><p>不管是否有异常被捕获，finally子句中的代码都被执行，主要用于资源的释放</p>
<p>强烈建议解耦合try/catch和try/finally语句块，可以提高代码的清晰度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">InputStrean in &#x3D; . . .;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	try</span><br><span class="line">	&#123;</span><br><span class="line">		code that might throwexceptions</span><br><span class="line">	&#125;</span><br><span class="line">	finally</span><br><span class="line">	&#123;</span><br><span class="line">		in.dose();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">	show error message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内层try语句块的职责就是确保关闭输入流，外层的try语句块的职责是确保报告出现的错误，这样设计方式不仅清楚，而且还可以报告finally子句中出现的错误</p>
<p>当finally子句包含return语句时，将会出现一种意想不到的结果，假设利用return语句从try语句块中退出，在方法返回之前，finally子句的内容将被执行。如果finally子句中也有一个return子句，这个返回值将会覆盖原始的返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;最终方法放回值是0</span><br><span class="line">public static int f(int n)</span><br><span class="line">&#123;</span><br><span class="line">	try</span><br><span class="line">	&#123;</span><br><span class="line">		int r &#x3D; n * n;</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line">	finally</span><br><span class="line">	&#123;</span><br><span class="line">		if (n &#x3D; 2) return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带资源的try语句"><a href="#带资源的try语句" class="headerlink" title="带资源的try语句"></a>带资源的try语句</h3><p>Java7为实现了AutoCloseable接口的资源实现了一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void close() throws Exception</span><br></pre></td></tr></table></figure>

<p>还有一个Closeable接口，这是AutoCloseable的子接口，也包含了close方法，这个方法声明为抛出一个IOException</p>
<p>带资源的try语句的最简形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try (Resource res &#x3D; . . .)</span><br><span class="line">&#123;</span><br><span class="line">	work with res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try块退出时，会自动调用res.close()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (Scanner in &#x3D; new Scanner(new FileInputStream(&quot;&#x2F;usr&#x2F;share&#x2F;dict&#x2F;words&quot;)), &quot;UTF-8&quot;)</span><br><span class="line">&#123;</span><br><span class="line">	while (in.hasNext())</span><br><span class="line">	System.out.println(in.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个块正常退出时，或者存在一个异常时，都会调用in.close()方法，就好像使用了finally块一样</p>
<h3 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h3><h4 id="异常处理不能代替简单的测试"><a href="#异常处理不能代替简单的测试" class="headerlink" title="异常处理不能代替简单的测试"></a>异常处理不能代替简单的测试</h4><p>异常处理会花费时间，所以只在异常情况下使用异常机制</p>
<h4 id="不要过分地细分异常"><a href="#不要过分地细分异常" class="headerlink" title="不要过分地细分异常"></a>不要过分地细分异常</h4><p>不要一行代码一个异常处理</p>
<h4 id="利用异常层次结构"><a href="#利用异常层次结构" class="headerlink" title="利用异常层次结构"></a>利用异常层次结构</h4><p>不要只抛出RuntimeException异常，应该寻找更加适当的子类或创建自己的异常类</p>
<p>不要只捕获Throwable异常，否则，会使程序代码难读，难以维护</p>
<p>考虑受查异常与非受查异常的区别，已检查异常本来就很庞大，不要为逻辑错误抛出这些异常，例如反射库的做法就不正确，调用者经常需要捕获那些早已知道不可能发生的异常</p>
<p>将一种异常转换成另一种更加合适的异常时不要犹豫</p>
<h4 id="不要压制异常"><a href="#不要压制异常" class="headerlink" title="不要压制异常"></a>不要压制异常</h4><h4 id="在检测错误时，严格要比放任好"><a href="#在检测错误时，严格要比放任好" class="headerlink" title="在检测错误时，严格要比放任好"></a>在检测错误时，严格要比放任好</h4><h4 id="不要羞于传递异常"><a href="#不要羞于传递异常" class="headerlink" title="不要羞于传递异常"></a>不要羞于传递异常</h4><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检测语句会被自动地移走</p>
<p> Java语言引入关键字assert</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert 条件;</span><br><span class="line">assert 条件:表达式;</span><br></pre></td></tr></table></figure>

<p>如果条件返回false,则会抛出一个AssertionError异常，表达式将被传入AssertionError的构造器，并转换成一个消息字符串</p>
<h1 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h1><h2 id="为什么要使用泛型程序设计"><a href="#为什么要使用泛型程序设计" class="headerlink" title="为什么要使用泛型程序设计"></a>为什么要使用泛型程序设计</h2><p>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如一个ArrayList类可以聚集任何类型的对象</p>
<h3 id="类型参数的好处"><a href="#类型参数的好处" class="headerlink" title="类型参数的好处"></a>类型参数的好处</h3><p>在Java中增加泛型类之前，泛型程序设计是用继承来实现的，ArrayList类只维护一个Object引用的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList &#x2F;&#x2F; before generic classes</span><br><span class="line">&#123;</span><br><span class="line">	private Object[] elementData;</span><br><span class="line">	....</span><br><span class="line">	public Object get(int i) &#123; . . , &#125;</span><br><span class="line">	public void add(Object o) &#123; . . . &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当获取一个值时必须进行强制类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList files &#x3D; new ArrayList();</span><br><span class="line">String filename &#x3D; (String) files.get(0);</span><br></pre></td></tr></table></figure>

<p>没有错误检查，可以向数组列表中添加任何类的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files.add(new File(&quot;. ..&quot;));</span><br></pre></td></tr></table></figure>

<p>将get的结果强制类型转换为String类型，会产生一个错误</p>
<p>泛型提供了一个更好的解决方案，参数类型</p>
<h2 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h2><p>一个泛型类就是具有一个或多个类型变量的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Pair&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	private T first;</span><br><span class="line">	private T second;</span><br><span class="line">	public Pair() &#123; first &#x3D; null ; second &#x3D; null ; &#125;</span><br><span class="line">	public Pair(T first, T second) &#123;this.first &#x3D; first; this.second &#x3D; second; &#125;</span><br><span class="line">	public T getFirst() &#123; return first; &#125;</span><br><span class="line">	public T getSecond() &#123; return second; &#125;</span><br><span class="line">	public void setFirst(T newValue) &#123; first &#x3D; newValue; &#125;</span><br><span class="line">	public void setSecond(T newValue) &#123; second &#x3D; newValue; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型类可以有多个类型变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Pair&lt;T, U&gt; &#123; . . . &#125;</span><br></pre></td></tr></table></figure>

<p>使用变量E表示集合的元素类型，K和V分别表示表的关键字与值的类型，T表示任意类型(U和S也可以使用)，泛型类可以看作普通类的工厂</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ArrayAlg</span><br><span class="line">&#123;</span><br><span class="line">	public static &lt;T&gt; T getMiddle(T... a)</span><br><span class="line">	&#123;</span><br><span class="line">		return a[a.length&#x2F;2];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型方法可以定义在普通类中，也可以定义在泛型类中，类型变量放在修饰符的后面，返回类型的前面</p>
<p>调用泛型方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String middle &#x3D; ArrayAlg.&lt;String&gt;getMiddle(&quot;]ohn&quot;, &quot;Q.&quot;, &quot;Public&quot;);</span><br></pre></td></tr></table></figure>

<p>方法调用可以省略String类型参数，编译器能够根据String[]与泛型类型T[]进行匹配，推断出T一定是String</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String middle &#x3D; ArrayAlg.getMiddle(&quot;]ohn&quot;, &quot;Q.&quot;, &quot;Public&quot;);</span><br></pre></td></tr></table></figure>

<p>编译器将会自动打包参数为1个Double和2个Integer对象，而后寻找这些类的共同类型，找到2个这样的父类型：Number和Comparable接口，其本身也是一个泛型类型，在这种情况下，可以采取的补救措施就是将所有的参数写成double</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double middle &#x3D; ArrayAlg.getMiddle(3.14, 1729, 0);</span><br></pre></td></tr></table></figure>

<p>查看编译器对一个泛型方法调用最终推断出那种类型：有目的地引入一个错误，并研究所产生的错误信息。可以将结果赋给Object,Serialiable或Comparable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayAlg.getMiddle(&quot;Hello&quot;,0,null)</span><br><span class="line">---------------------------------------------</span><br><span class="line">found:</span><br><span class="line">java.1ang.0bject&amp;java.io.Serializable&amp;java.lang.Comparable&lt;? extends</span><br><span class="line">java.1ang.0bject&amp;java.io.Serializable&amp;java•1ang.Comparabl e&lt;?&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ArrayAIg</span><br><span class="line">&#123;</span><br><span class="line">	public static &lt;T&gt; T min(T[] a) &#x2F;&#x2F; &lt;T&gt;的作用是限定返回值，T是返回值类型</span><br><span class="line">	&#123;</span><br><span class="line">		if (a &#x3D;&#x3D; null || a.length &#x3D;&#x3D; 0) return null ;</span><br><span class="line">		T smallest &#x3D; a[0];</span><br><span class="line">		for (int i &#x3D; 1; i &lt; a.length; i ++)</span><br><span class="line">			if (smallest.compareTo(a[i]) &gt; 0) smallest &#x3D; a[i];</span><br><span class="line">		return smallest;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>smallest的类型是T,这意味着它可以是任何一个类的对象，怎么确信T所属的类有compareTo方法呐？解决办法就是将T限制为实现了Comparable接口的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&gt; T min(T[] a) . . .</span><br></pre></td></tr></table></figure>

<p>为什么使用extends而不是使用implements，毕竟Comparable是一个接口。extends表示T应该是绑定类型的子类型，T和绑定类型可以是类，也可以是接口，选择关键字extends的原因是更接近子类的概念，设计者不打算再添加一个新的关键字</p>
<p>一个类型变量或通配符可以有多个限定，限定类型用&amp;分隔，可以根据需要拥有多个接口父类型，但限定中至多有一个类，如果用一个类作为限定，它必须是限定列表中的第一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends Comparable &amp; Serializable</span><br></pre></td></tr></table></figure>

<p>虚拟机没有泛型类型对象，所有对象都属于普通类</p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>无论何时定义一个泛型类型，都自动提供了一个相应的原始类型，原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型，无限定的变量用Object</p>
<p>Pair<T>的原始类型如下</T></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Pair</span><br><span class="line">&#123;</span><br><span class="line">	private Object first;</span><br><span class="line">	private Object second;</span><br><span class="line">	public Pair(Object first, Object second)</span><br><span class="line">	&#123;</span><br><span class="line">		this,first &#x3D; first;</span><br><span class="line">		this.second &#x3D; second;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Object getFirst() &#123; return first; &#125;</span><br><span class="line">	public Object getSecond() &#123; return second; &#125;</span><br><span class="line">	public void setFirst(Object newValue) &#123; first &#x3D; newValue; &#125;</span><br><span class="line">	public void setSecond(Object newValue) &#123; second &#x3D; newValue; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为T是一个无限定的变量，所以直接用Object替换，结果是一个普通的类，就好像泛型引入之前那样，在程序中可以包含不同类型的Pair,例如Pair<String>或Pair<LocalDate>，而擦除类型后就变成了原始的Pair类型了</LocalDate></String></p>
<p>原始类型用第一个限定的类型变量来替换，如果没有给定限定就用Object替换。例如，类Pair<T>中的类型变量没有显式的限定，因此，原始类型用Object替换T,假定声明一个不同的类型</T></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Interval &lt;T extends Comparable &amp; Serializabl&gt;implements Serializable</span><br><span class="line">&#123;</span><br><span class="line">	private T lower;</span><br><span class="line">	private T upper;</span><br><span class="line">	public Interval (T first, T second)</span><br><span class="line">	&#123;</span><br><span class="line">		if (first.compareTo(second) &lt;&#x3D; 0) &#123; lower &#x3D; first; upper &#x3D; second; &#125;</span><br><span class="line">		else &#123; lower &#x3D; second; upper &#x3D; first; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始类型Interval</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Interval implements Serializable</span><br><span class="line">&#123;</span><br><span class="line">	private Comparable lower;</span><br><span class="line">	private Coiparable upper;</span><br><span class="line">	public Interval (Coiparable first, Comparable second) &#123; . . . &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h2><p>当程序调用泛型方法时，如果擦除返回类型，编译器将插入强制类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies &#x3D; ...?</span><br><span class="line">Employee buddy &#x3D; buddies.getFirst();</span><br></pre></td></tr></table></figure>

<p>擦除getFirst的返回类型后将返回Object类型，编译器自动插入Employee的强制类型转，编译器把这个方法调用翻译为两条虚拟机指令</p>
<ol>
<li>对原始方法Pair.getFirst的调用</li>
<li>对返回的Object类型强制转换为Employee类型</li>
</ol>
<h2 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&gt;T min(T[] a)</span><br></pre></td></tr></table></figure>

<p>一个完整的方法族，而擦除类型之后，只剩下一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Comparable min(Comparable[] a)</span><br></pre></td></tr></table></figure>

<p>类型参数T已经被擦除了，只留下了限定类型Comparable</p>
<h2 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h2><h3 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h3><p>没有Pair<double>，只有Pair<Double>。原因是类型擦除，擦除之后，Pair类含有Object类型的域，而Object不能存储double值</Double></double></p>
<p>这样做与Java语言中基本类型的独立状态相一致，这并不是一个致命缺陷——只有8种基本类型，当包装器类型不能接受替换时，可以使用独立的类和方法处理它们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static Pair&lt;Double&gt; d &#x3D; new Pair&lt;&gt;();&#x2F;&#x2F;right</span><br><span class="line">static Pair&lt;double&gt; d &#x3D; new Pair&lt;&gt;();&#x2F;&#x2F;error</span><br></pre></td></tr></table></figure>

<h3 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h3><p>虚拟机中的对象总有一个特定的非泛型类型，因此所有的类型查询只产生原始类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (a instanceof Pair&lt;String&gt;) &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure>

<p>实际上仅仅测试a是否是任意类型的一个Pair，下面的测试同样如此</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (a instanceof Pair&lt;T&gt;) &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure>

<p>或强制类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p &#x3D; (Pair&lt;String&gt;) a; &#x2F;&#x2F; Warning-can only test that a is a Pair</span><br></pre></td></tr></table></figure>

<p>为了提醒这一风险，试图查询一个对象是否属于某个泛型类型时，倘若使用instanceof会得到一个编译器错误，如果使用强制类型转换会得到一个警告，同样的道理，getClass方法总是返回原始类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static Pair&lt;String&gt; s &#x3D; new Pair&lt;&gt;();</span><br><span class="line">static Pair&lt;Double&gt; d &#x3D; new Pair&lt;&gt;();</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     System.out.println(s.getClass());</span><br><span class="line">     System.out.println(d.getClass());</span><br><span class="line">&#125;</span><br><span class="line">-------------打印结果------------------------------------</span><br><span class="line">class com.gzw.system.cons.Pair</span><br><span class="line">class com.gzw.system.cons.Pair</span><br></pre></td></tr></table></figure>

<h3 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h3><p>Java不支持泛型类型数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table &#x3D; new Pair&lt;String&gt;[10]; &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure>

<p>擦除之后，table的类型是Pair[],可以把他转换为Object[],数组会记住它的元素类型，如果试图存储其他类型的元素，就会抛出一个ArrayStoreException异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] objarray &#x3D; table;</span><br><span class="line">objarray[0] &#x3D; &quot;Hello&quot;; &#x2F;&#x2F; Error component type is Pair</span><br></pre></td></tr></table></figure>

<p>对于泛型类型，擦除会使这种机制无效，能够通过数组存储检测，不过仍会导致一个类型错误，出个原因，不允许创建参数化类型的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objarray[0] &#x3D; new Pair&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>

<p>只是不允许创建这些数组，而声明类型为Pair<String>[]的变量仍是合法的，不过不能用new Pair<String>[10]初始化这个变量</String></String></p>
<p>可以声明通配类型的数组，然后进行类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table &#x3D; (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10];</span><br></pre></td></tr></table></figure>

<p>结果将是不安全的，如果在table[0]中存储一个Pair<employee>,然后对table[0].getFirst()调用一个String方法，会得到一个ClassCastException异常</employee></p>
<p>如果需要收集参数化类型对象，只有一种安全而有效的方法，使用ArrayList:ArrayList&lt;Pair<String>&gt;</String></p>
<h3 id="Varargs警告"><a href="#Varargs警告" class="headerlink" title="Varargs警告"></a>Varargs警告</h3><p>向参数个数可变的方法传递一个泛型类型的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void addAll(Collection&lt;T&gt; coll, T... ts)</span><br><span class="line">&#123;</span><br><span class="line">	for (t : ts) coll.add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用这个方法，Java虚拟机必须建立一个Pair<String>数组，这就违反了前面的规则，不过规则有所放松，只会得到一个警告而不是错误</String></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Col1ection&lt;Pair&lt;String&gt;&gt; table &#x3D; . . .;</span><br><span class="line">Pair&lt;String&gt; pairl &#x3D; ...;</span><br><span class="line">Pair&lt;String&gt; pair2 &#x3D; ...;</span><br><span class="line">addAll(table, pairl, pair2);</span><br></pre></td></tr></table></figure>

<p>可以采用两种方法来抑制这个警告，一种方法是为包含addAll调用的方法增加注解@SuppressWarnings(“unchecked”),或者还可以用@SafeVarargs直接标注addAll方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@SafeVarargs</span><br><span class="line">public static &lt;T&gt; void addAll(Collection&lt;T&gt; coll, T... ts)</span><br></pre></td></tr></table></figure>

<p>使用@SafeVarargs会存在一些风险</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@SafeVarargs static &lt;E&gt; E[] array(E... array) &#123; return array; &#125;</span><br><span class="line">Pair&lt;String&gt;[] table &#x3D; array(pair1,pair2);</span><br><span class="line">Object[] objarray &#x3D; table;</span><br><span class="line">objarray[0] &#x3D; new Pair&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>

<p>能顺利运行而不会出现ArrayStoreException异常(因为数组存储只会检查擦除的类型)，但在处理tabel[0]时你会在别处得到一个异常</p>
<h3 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h3><p>不能使用像new T(),new T[],T.class这样的表达式中的类型变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Pair() &#123; first &#x3D; new T(); second &#x3D; new T(); &#125; &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure>

<p>让调用者提供一个构造器表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p &#x3D; Pair.makePair(String::new);</span><br></pre></td></tr></table></figure>

<p>makePair方法接收一个Supplier<T>，这是一个函数式接口，表示一个无参数而且返回类型为T的函数</T></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Pair&lt;T&gt; makePair(Supplier&lt;T&gt; constr)</span><br><span class="line">&#123;</span><br><span class="line">	return new Pair&lt;&gt;(constr.get(). constr.get())；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较传统的解决方法是通过反射调用Class.newInstance方法来构造泛型对象，遗憾的是细节有点复杂，不能调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first &#x3D; T.class.newInstance(); &#x2F;&#x2F; Error</span><br></pre></td></tr></table></figure>

<p>表达式T.class是不合法的，因为它会擦除为Object.class，必须设计一个API以便得到一个Class对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static&lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl)</span><br><span class="line">&#123;</span><br><span class="line">	try &#123; </span><br><span class="line">	return new Pair()(cl.newInstance(),cl.newInstance();) </span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123; return null;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Pair&lt;String&gt; p &#x3D; Pair.makePair(String.class);</span><br></pre></td></tr></table></figure>

<p>Class类本身是泛型，String.class是一个Class<String>的实例，因此，makePair方法能够推断出pair的类型</String></p>
<h3 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h3><h3 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h3><p>不能在静态域或方法中引用类型变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">	private static T singleInstance; &#x2F;&#x2F; Error</span><br><span class="line">	public static T getSingleInstance() &#x2F;&#x2F; Error</span><br><span class="line">	&#123;</span><br><span class="line">		if (singleinstance &#x3D;&#x3D; null) construct new instance of T</span><br><span class="line">		return singleInstance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h3><h3 id="可以消除对受查异常的检查"><a href="#可以消除对受查异常的检查" class="headerlink" title="可以消除对受查异常的检查"></a>可以消除对受查异常的检查</h3><h3 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h3><h2 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h2><p>8.8.2-9.1暂时跳过</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><h3 id="将集合的接口与实现分离"><a href="#将集合的接口与实现分离" class="headerlink" title="将集合的接口与实现分离"></a>将集合的接口与实现分离</h3><p>与现代的数据结构类库的常见情况一样，Java集合类库也将接口与实现分离</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查找队列中元素的个数，按照先进先出的规则检索对象时就应该使用队列</p>
<p>队列接口的最简形式大概如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; &#x2F;&#x2F; a simplified form of the interface in the standard library</span><br><span class="line">&#123;</span><br><span class="line">	void add(E element);</span><br><span class="line">	E remove();</span><br><span class="line">	int size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列通常有两种实现方式：一种是使用循环数组，一种是使用链表</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/021.png"  alt="Java核心卷——基础知识"></p>
<p>每一个实现都可以通过一个实现了Queue接口的类表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class CircularArrayQueue&lt;E&gt; implements Queue&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>如果需要一个循环数组队列，就可以使用ArrayDeque类，如果需要一个链表队列，就直接使用LinkedList类，这个类实现了Queue接口</p>
<p>当在程序中使用队列时，一旦构建了集合就不需要知道究竟使用了那种实现，因此，只有在构建集合对象时，使用具体的类才有意义，可以使用接口类型存放集合的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane &#x3D; new CircularArrayQueue&lt;&gt;(100);</span><br><span class="line">expressLane.add(new Customer(&quot;Harry&quot;));</span><br></pre></td></tr></table></figure>

<p>循环数组是一个有界集合，即容量优先，如果程序中要收集的对象数量没有上限，就最好使用链表来实现</p>
<p>Abstract开头的类，例如AbstractQueue，这些类是为类库实现者设计的，如果想要实现自己的队列类，会发现扩展AbstractQueue类要比实现Queue接口中的所有方法轻松得多</p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>集合类的基本接口Collection,这个接口有两个基本方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">	boolean add(E element);</span><br><span class="line">	Iterator&lt;E&gt; iterator();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add方法用于向集合中添加元素，添加元素确实改变了集合就返回true,如果集合没有发生变化就返回false,例如，如果试图向集合中添加一个对象，而这个对象在集合中已经存在，这个添加请求就没有实效，因为集合中不允许有重复的对象</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>Iterator接口包含四个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">	E next();</span><br><span class="line">	boolean hasNext();</span><br><span class="line">	void remove();</span><br><span class="line">	default void forEachRemaining(Consumer&lt;? super E&gt; action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反复调用next方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾，next方法将会抛出一个NoSuchElementException,因此，需要在调用next方法之前调用hasNext方法，如果迭代器对象还有多个可供访问的元素，就返回true,如果想要查看集合中的所有元素，就请求一个迭代器，并在hasNext返回true时反复地调用next方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c &#x3D; . . .;</span><br><span class="line">Iterator&lt;String&gt; iter &#x3D; c.iterator();</span><br><span class="line">while(iter.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">	String element &#x3D; iter.next();</span><br><span class="line">	do something with element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用for each循环可以更加简练地表示同样的循环操作，编译器简单地将for each循环编译为带迭代器的循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (String element : c)</span><br><span class="line">&#123;</span><br><span class="line">	do something with element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for each循环可以与任何实现了Iterable接口的对象一起工作</p>
<p>Collection接口扩展了Iterable接口，因此，对于标准类库中的任何集合都可以使用for each循环</p>
<p>在Java8中，甚至不用写循环，可以调用forEachRemaining方法并提供一个lambda表达式，将对迭代器的每一个元素调用这个表达式，知道没有元素为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator.forEachRemaining(element -&gt; do something with element);</span><br></pre></td></tr></table></figure>

<p>元素被访问的顺序取决于集合类型，如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次，索引加一。然而，如果访问HashSet中的元素，每个元素将会按照某种随机的次序出现，虽然可以确定在迭代的过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的顺序，这对于计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说，并不是什么问题</p>
<p>Iterator接口的next和hasNext方法与Enumeration接口的nextElement和hasMoreElements方法的作用一样。Java集合类库的设计者可以选择使用Enumeration接口，但是他们不喜欢这个接口累赘的方法名，于是引入了具有较短方法名的新接口</p>
<p>三种方式都可以对集合进行遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; as &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">as.add(&quot;123&quot;);</span><br><span class="line">as.add(&quot;456&quot;);</span><br><span class="line">Iterator&lt;String&gt; it&#x3D;as.iterator();</span><br><span class="line">--------------------调用方式---------------------------------</span><br><span class="line">while(it.hasNext()) &#123; System.out.println(it.next()); &#125;</span><br><span class="line"></span><br><span class="line">it.forEachRemaining(String-&gt;System.out.print(String+&quot; &quot;));</span><br><span class="line"></span><br><span class="line">for (String a:as) &#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该将Java迭代器认为是位于两个元素之间，当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用</p>
<p>可以将Iterator.next与InputStream.read看是等效的，从数据流中读取一个字节，就会自动地消化掉这个字节，下一次调用read将会消耗并返回输入的下一个字节</p>
<p>Iterator接口的remove方法将会删除上次调用next方法时返回的元素。</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/022.png"  alt="Java核心卷——基础知识"></p>
<p>如何删除字符串集合中第一个元素的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it &#x3D; c.iterator();</span><br><span class="line">it.next(); &#x2F;&#x2F; skip over the first element</span><br><span class="line">it. remove(); &#x2F;&#x2F; now remove it</span><br></pre></td></tr></table></figure>

<p>next方法和remove方法的调用具有互相依赖性，如果调用remove之前没有调用next将是不合法的，会抛出一个illegalStateException异常</p>
<h3 id="泛型实用方法"><a href="#泛型实用方法" class="headerlink" title="泛型实用方法"></a>泛型实用方法</h3><p>Collection与Iterator都是泛型接口，可以编写任何集合类型的实用方法，下面是一个检测任意集合是否包含指定元素的泛型方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static&lt;E&gt; boolean contains(Collection&lt;E&gt; c, Object obj)</span><br><span class="line">&#123;</span><br><span class="line">	for (E element : c)</span><br><span class="line">	if (element,equals(obj))</span><br><span class="line">		return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Collection接口声明了很多有用的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int size()</span><br><span class="line">boolean isEmpty()</span><br><span class="line">boolean contains(Object obj)</span><br><span class="line">boolean containsAl1 (Col1ection&lt;?&gt; c)</span><br><span class="line">boolean equals(Object other)</span><br><span class="line">boolean addAll (Collection&lt;? extends E&gt; from)</span><br><span class="line">boolean remove (Object obj)</span><br><span class="line">boolean removeAl1 (Col1ection&lt;?&gt; c)</span><br><span class="line">void cl ear()</span><br><span class="line">boolean retainAl1 (Col1ection&lt;?&gt; c)</span><br><span class="line">Object口 toArray()</span><br><span class="line">&lt;T&gt; T[] toArray(T[] arrayToFill)</span><br></pre></td></tr></table></figure>

<p>实现Collection接口的每一个类都要提供如此多的例行方法是一件很烦人的事情，Java提供了一个类AbstractCollection,它将基础方法size和iterator抽象化了，但是提供了大量的例行方法</p>
<h3 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h3><p>Java框架为不同类型的集合定义了大量接口</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/023.png"  alt="Java核心卷——基础知识"></p>
<p>集合有两个基本的接口：Collection和Map</p>
<p>List是一个有序集合，元素会增加到容器中的特定位置，可以采用方式访问：使用迭代器访问，或者使用一个整数索引来访问，后一种方法称为随机访问，因为这样可以按任意顺序访问元素，与之不同，使用迭代器访问时，必须顺序地访问元素</p>
<p>List接口定义了多个用于随机访问的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void add(int index, E element)</span><br><span class="line">void remove(int index)</span><br><span class="line">E get(int index)</span><br><span class="line">E set(int index, E element)</span><br></pre></td></tr></table></figure>

<p>ListIterator接口是Iterator的一个子接口，它定义了一个方法用于在迭代器位置前面增加一个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void add(E element)</span><br></pre></td></tr></table></figure>

<p>链表尽管也是有序得，但是随机访问很慢，所以最好使用迭代器来遍历</p>
<p>数组支持得有序集合可以用整数索引来访问</p>
<p>Set接口等同于Collection接口，不过其方法的行为有更严谨的定义，set的add方法不允许增加重复的元素，要适当地定义集的equals方法：只要两个set包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode方法的定义要保证包含相同元素的量个set会得到相同的散列码</p>
<p>既让方法签名一样，为什么还要建立一个单独的接口呐？从概念上讲，并不是所有的Collection都是Set，建立一个Set接口可以让程序员编写只接受Set的方法</p>
<p>Sorted和SortedMap会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法</p>
<h2 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h2><p>Java库中的具体集合(不包括线程安全集合)</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/024.png"  alt="Java核心卷——基础知识"></p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/025.png"  alt="Java核心卷——基础知识"></p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>数组和数组列表ArrayList有一个弱点，就是从数组的中间位置删除/添加一个元素要付出很大的代价，原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动</p>
<p>链表解决了这个问题，尽管数组在连续的存储位置上存放对象引用，但链表却讲每个对象存放在独立的节点中，每个节点还存放着序列中下一个节点的引用，在Java程序设计语言中，所有链表实际上都是双向链表，即每个节点还存放着指向前驱节点的引用</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/026.png"  alt="Java核心卷——基础知识"></p>
<p>从链表中间删除一个元素是一个很轻松的操作，更新被删除元素附近的链接即可</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/027.png"  alt="Java核心卷——基础知识"></p>
<h4 id="LinkedList链表集合"><a href="#LinkedList链表集合" class="headerlink" title="LinkedList链表集合"></a>LinkedList链表集合</h4><p>先添加三个元素，再将第二个元素删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff &#x3D; new LinkedList&lt;&gt;(); &#x2F;&#x2F; LinkedList implements List</span><br><span class="line">staff.add(&quot;Amy&quot;);</span><br><span class="line">staff.add(&quot;Bob&quot;);</span><br><span class="line">staff,add(&quot;Carl&quot;);</span><br><span class="line">Iterator iter &#x3D; staff.iterator();</span><br><span class="line">String first &#x3D; iter.next();&#x2F;&#x2F; visit first element</span><br><span class="line">String second &#x3D; iter.next();&#x2F;&#x2F;visit second element</span><br><span class="line">iter.remove(); &#x2F;&#x2F; remove last visited elemen</span><br></pre></td></tr></table></figure>

<p>链表是一个有序集合，每个对象的位置十分重要，LinkedList.add方法将对象添加到链表的尾部，但是，常常需要将元素添加到链表的中间，由于迭代器是描述集合中位置的，所以这种依赖于位置的add方法将由迭代器负责，只有对自然有序的集合使用迭代器添加元素才有实际意义，set类型中的元素完全无序，Inerator接口中就没有add方法，相反地，集合类库提供了子接口ListIterator，其中包含add方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">	void add(E element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与Collection.add不同，这个方法不返回boolean类型的值，它假定添加操作总会改变链表</p>
<p>ListIterator是List接口中定义的方法</p>
<p>ListIterator接口有两个方法，可以用来反向遍历链表,与next方法一样，previous方法返回越过的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E previous()</span><br><span class="line">boolean hasPrevious()</span><br></pre></td></tr></table></figure>

<p>LinkedList类的listIterator方法返回一个实现了ListIterator接口的迭代器对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; iter &#x3D; staff.listlterator();</span><br></pre></td></tr></table></figure>

<p>Add方法在迭代器位置之前添加了一个新对象，下面的代码将越过链表中的第一个元素，并在第二个元素之前添加Juliet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">staff.add(&quot;Amy&quot;);</span><br><span class="line">staff.add(&quot;Bob&quot;);</span><br><span class="line">staff.add(&quot;Carl&quot;);</span><br><span class="line">ListIterator&lt;String&gt; iter &#x3D; staff.listlterator();</span><br><span class="line">iter.next();&#x2F;&#x2F; skip past first element</span><br><span class="line">iter.add(&quot;Juliet&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/028.png"  alt="Java核心卷——基础知识"></p>
<p>如果多次调用add方法，将按照提供的次序把元素添加到链表中，它们被依次添加到迭代器当前位置之前</p>
<p>当用一个刚刚由Iterator方法返回，并且指向链表表头的迭代器调用add操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时(即hasNext返回false),添加的元素将变成列表的新表尾</p>
<p>如果链表有n个元素，则有n+1个位置可以添加新元素</p>
<p>add方法只依赖于迭代器的位置，而remove方法依赖于迭代器的状态。可以连续add元素，但是不能连续调用两次remove</p>
<p>set方法用一个新元素取代调用next或previous方法返回的上一个元素，下面的代码将用一个新值取代链表的第一个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; iter &#x3D; list.listlterator();</span><br><span class="line">String oldValue &#x3D; iter.next(); &#x2F;&#x2F; returns first element</span><br><span class="line">iter.set(newValue); &#x2F;&#x2F; sets first element to newValue</span><br></pre></td></tr></table></figure>

<p>当某个迭代器修改集合时，另一个迭代器对其进行遍历，会出现混乱。例如一个迭代器指向另一个迭代器刚刚删除的元素前面，现在这个迭代器就是无效的，如果迭代器检测到这个异常，就会抛出一个ConcurrentModificationException异常。为了避免发生并发修改异常，请遵循下述简单规则：</p>
<ul>
<li><p>可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表，另外，再单独附加一个既能读又能写的迭代器</p>
</li>
<li><p>集合可以跟踪改写操作(诸如添加或删除)的次数，每个迭代器都维护一个独立的计数值，在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作数值一致，如果不一致，抛出一个ConcurrentModificationException异常</p>
</li>
</ul>
<p>对于并发修改列表的检测有一个奇怪的例外，链表只负责跟踪对列表的结构性修改，例如，添加元素，删除元素。set方法不被视为结构性修改，可以将多个迭代器附加给一个链表，所有的迭代器都调用set方法对现有节点的内容进行修改</p>
<p>Collection接口中声明了许多用于对链表操作的有用方法，其中大部分方法都是在LinkedList类的父类AbstractCollection中实现的，例如toString方法调用了所有元素的toString，并产生了一个很长的格式为[A,B,C]的字符串</p>
<p>链表不支持快速随机访问，如果要查看链表中第n个元素，就必须从头开始，越过n-1个元素。在需要采用整数索引访问元素时，通常不选用链表，不过LinkedList类还是提供了一个用来访问某个特定元素的get方法。get方法做了微小的优化：如果索引大于size()/2就从列表尾部开始搜索元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list &#x3D; ...;</span><br><span class="line">String obj &#x3D; list.get(n);</span><br></pre></td></tr></table></figure>

<p>绝对不应该使用这种让人误解的随机访问方法来遍历链表，下面这段代码的效率极低,每次查找一个元素都要从列表的头部重新开始搜索，LinkedList对象根本不做任何缓存位置信息的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; list.size(); i++)</span><br><span class="line">do something with list.get(i);</span><br></pre></td></tr></table></figure>

<p>列表迭代器接口还有一个方法，可以告之当前位置的索引。由于Java迭代器指向两个元素之间的位置，所以可以同时产生两个索引：nextIndex方法返回下一次调用next方法时返回元素的整数索引;previousIndex方法返回下一次调用previous方法时返回元素的整数索引，当然，这个索引值比nextIndex返回的索引值小1。因为迭代器保持当前位置的计数值，所以这两个方法的效率很高</p>
<p>如果有一个整数索引n,list.listIterator(n)将返回一个迭代器，这个迭代器指向索引为n的元素前面的位置，也就是说，调用next与调用list.get(n)会产生同一个元素，只是获得这个迭代器的效率很低</p>
<p>如果链表只有很少几个元素，就完全没有必要为get方法和set方法的开销而烦恼</p>
<p>使用链表的唯一理由就是尽可能地减少在列表中间插入或者删除元素所付出的代价,如果列表只有少数几个元素，就完全可以使用数组实现的ArrayList</p>
<p>建议避免使用以整数索引表示链表中位置的所有方法，如果需要对集合进行随机访问，就使用数组或者ArrayList，而不要使用链表</p>
<h3 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h3><p>List接口用于描述一个有序集合，并且集合中每个元素的位置十分重要</p>
<p>ArrayList封装了一个动态再分配的对象数组</p>
<p>Vector类同样也是动态封装了一个对象数组，为什么要用ArrayList取代Vector？<br>Vector类的所有方法都是同步的，可以由两个线程安全地访问同一个Vector对象，但是如果由一个线程访问Vector，代码要在同步操作上耗费大量的时间，而ArrayList方法不是同步的，因此，建议在不需要同步时使用ArrayList,而不要使用Vector</p>
<h3 id="散列集"><a href="#散列集" class="headerlink" title="散列集"></a>散列集</h3><p>散列表hashtable可以快速地查找所需要的对象，缺点是无法控制元素出现的次序，它们将按照有利于其操作目的的原则组织数据</p>
<p>散列表为每个对象计算一个整数，称为散列码，散列码是由对象的实例域产生的一个整数，具有不同数据域的对象将产生不同的散列码</p>
<p>如果自定义类，就要负责实现这个类的hashCode方法，自己实现的hashCode方法应该与equals方法兼容，即a,equals(b)为true,a与b必须具有相同的散列码</p>
<p>散列码的计算只与要散列的对象状态有关，与散列表中的其他对象无关</p>
<p>Java中，散列表用链表数组ArrayList实现，每个列表被称为桶，要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余</p>
<p>要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引，例如某个对象的散列码是76268，并且有128个桶，对象应该保存在第108号桶中(76268除以128余108)，这时如果桶中没有元素，直接将元素插入到桶中就可以了，当然，有时候会遇到桶被占满的情况，这也是不可避免的，这种现象被称为散列冲突。这时需要用新对象与桶中的所有对象进行比较，查看这个对象是否已经存在，如果散列码是合理且随机分布的，桶中的数目也足够大，发生冲突需要比较的次数就会很少</p>
<p>Java8后，桶满时会从链表变为平衡二叉树，如果选择的散列函数不当，会产生很多冲突，或者如果有恶意代码试图在散列表中填充多个有相同散列码的值，这样就能提高性能</p>
<p>如果想要更多地控制散列表的运行性能，就要指定一个初始的桶数，桶数是指用于收集具有相同散列值的桶的数目。入宫要插入到散列表中的元素太多，就会增加冲突的可能性，降低运行性能</p>
<p>如果大概知道最终会有多少个元素要插入到散列表中，就可以设置桶数，通常将桶数设置为预计元素个数的75%-150%。最好将桶数设置为一个素数，以防键的聚集。标准类库使用的桶数是2的幂，默认值为16</p>
<p>如果散列表太满就需要再散列，创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表，装填因子决定何时对散列表进行再散列，0.75是比较合适的值</p>
<p>散列表可以实现set类型，set是没有重复元素的元素集合，set的add方法首先在集中查找要添加的对象，如果不存在，就将这个对象添加进去</p>
<p>Java集合提供了一个HashSet类，它实现了基于散列表的集，可以用add方法添加元素，contains方法已经被重新定义，用来快速地查看是否某个元素已经出现在集中，它只在某个桶中查找元素，而不必查看集合中的所有元素</p>
<p>散列集迭代器将依次访问所有的桶，由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的，只是不关心集合中元素顺序时才应该使用JHashSet</p>
<p>在更改集中的元素时要格外小心，如果元素的散列码发生改变，元素在数据结构中的位置也会发生变化</p>
<h3 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h3><p>TreeSet类与散列集十分类似但有所改进，树集是一个有序集合，可以以任意顺序将元素插入到集合中，在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SortedSet&lt;String&gt; sorter &#x3D; new TreeSet&lt;&gt;(); &#x2F;&#x2F; TreeSet implements SortedSet</span><br><span class="line">sorter.add(&quot;Bob&quot;);</span><br><span class="line">sorter.add(&quot;Amy&quot;);</span><br><span class="line">sorter.add(&quot;Carl&quot;);</span><br><span class="line">for (String s : sorter) System.println(s);&#x2F;&#x2F;Amy Bob Carl</span><br></pre></td></tr></table></figure>

<p>排序是用树结构完成的，当前使用的是红黑树，每次将一个元素添加到树中，都被放置在正确的排序位置上，因此迭代器总是以排好序的顺序访问每个元素</p>
<p>将一个元素添加到树中要比添加到散列表中慢，但是与检查数组或链表中的重复元素相比还是快很多</p>
<p>要使用树集，必须能够比较元素，元素必须实现Comparable接口，或者构造集时必须提供一个Comparator</p>
<p>如果使用TreeSet就需要提供Comparator<Rectangle>，如何比较两个矩形呐？树的排序必须是全序，也就是说，任意两个元素必须是可比的，并且只有在两个元素相等时结果才为0</Rectangle></p>
<h3 id="队列与双端队列"><a href="#队列与双端队列" class="headerlink" title="队列与双端队列"></a>队列与双端队列</h3><p>队列可以让人们有效地在尾部添加一个元素，在头部删除一个元素</p>
<p>有两个端头的队列，即双端队列，可以有效地在头部和尾部同时添加或删除元素，不支持在队列中间添加元素</p>
<p>Java6中引入了Deque接口，并由ArrayDeque和LinkedList类实现，这两个类都提供了双端队列，而且在必要时可以增加队列的长度</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先级队列中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索，无论何时调用remove方法，总会获得当前优先级队列中最小的元素。然而优先级队列并没有对所有的元素进行排序，如果用迭代的方式处理这些元素，并不需要对他们进行排序。优先级队列使用一个优雅且高效的数据结构——堆</p>
<p>堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序</p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>要想查看一个元素，需要有要查找元素的精确副本，这不是一种非常通用的查找方式。通常情况下我们知道键的信息想要查找与之对应的元素。映射数据结构就是为此设计的，映射用来存放键值对，如果提供了键，就能够查找到值</p>
<h3 id="基本映射操作"><a href="#基本映射操作" class="headerlink" title="基本映射操作"></a>基本映射操作</h3><p>Java类库为映射提供了两个通用的实现：HashMap和TreeMap，这两个类都实现了Map接口</p>
<p>散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键关联的值不能进行散列或比较</p>
<p>散列映射稍微快一点，如果不需要按照顺序访问键，就最好选择散列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Employee&gt; staff &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; HashMap implements Map</span><br><span class="line">Employee harry &#x3D; new Employee(&quot;Harry Hacker&quot;);</span><br><span class="line">staff.put(&quot;987-98-9996&quot;, harry);</span><br></pre></td></tr></table></figure>

<p>检索对象,如果在映射中没有与给定键对应的信息，get将返回null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String id &#x3D; &quot;987-98-9996&quot;;</span><br><span class="line">e &#x3D; staff.get(id);&#x2F;&#x2F; gets harry</span><br></pre></td></tr></table></figure>

<p>null返回值可能并不方便，需要一个好的默认值，用作映射中不存在的键，使用getOrDefault方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; scores &#x3D; ...;</span><br><span class="line">int score &#x3D; scores.get(id, 0); &#x2F;&#x2F; Gets 0 if the id is not present</span><br></pre></td></tr></table></figure>

<p>键必须是唯一的，如果对同一个键两次调用put方法，第二个值会覆盖第一个值，put将返回用这个键参数存储的上一个值</p>
<p>remove方法用于从映射中删除给定键对应的元素</p>
<p>迭代处理映射的键和值，最容易的方法是使用foreach方法，可以提供一个接受键和值的lambda表达式，映射中的每一项会依序调用这个表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores.forEach((k, v) -&gt;</span><br><span class="line">System.out.println(&quot;key&#x3D;&quot; + k + &quot;, value&#x3D;&quot; + v));</span><br></pre></td></tr></table></figure>

<h3 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h3><p>使用映射统计一个单词在文件中出现的频度，看到一个单词时，我们将计数器增1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.put(word, counts.get(word)+ 1);</span><br></pre></td></tr></table></figure>

<p>第一次看到word时，get会返回null,因此会出现一个NullPointerException异常，作为一个简单的补救，可以使用getOrDefault方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts,put(word, counts.getOrDefault(word, 0)+ 1);</span><br></pre></td></tr></table></figure>

<p>另一种方法是首先调用putIfAbsent方法，只有当键原先存在时才会放入一个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counts.putlfAbsent(word, 0);</span><br><span class="line">counts.put(word, counts.get(word)+ 1); &#x2F;&#x2F; Now we know that get will succeed</span><br></pre></td></tr></table></figure>

<p>merge方法可以简化这个常见操作，如果键原先不存在，下面的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.merge(word, 1, Integer::sum);</span><br></pre></td></tr></table></figure>

<p>将把word与1关联，否则使用Integer::sum函数组合原值和1</p>
<h3 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h3><p>集合框架不认为映射本身是一个集合(其他数据结构框架认为映射是一个键值对集合，或者是由键索引的值集合)，不过可以得到映射视图——这是实现了Collection接口或某个子接口的对象</p>
<p>键集合，值集合，键值对集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;K&gt; keySet()</span><br><span class="line">Collection&lt;V&gt; values()</span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt; entrySet()</span><br></pre></td></tr></table></figure>

<p>上面三个方法会分别返回三个视图，keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象，Set接口扩展了Collection接口，因此可以像使用集合一样使用keySet</p>
<p>可以枚举一个映射的所有键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keys &#x3D; map.keySet();</span><br><span class="line">for (String key : keys)</span><br><span class="line">&#123;</span><br><span class="line">	do something with key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想同时查看键和值，可以通过枚举条目来避免查找值，可以使用以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(Map.Entry&lt;String, Employee〉entry : staff.entrySet())</span><br><span class="line">&#123;</span><br><span class="line">	String k &#x3D; entry.getKey();</span><br><span class="line">	Employee v &#x3D; entry.getValue();</span><br><span class="line">	do something with k, v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在键集视图上调用迭代器的remove方法，实际上会从映射中删除这个键和与它关联的值。不过不能像键集视图添加元素，如果增加一个键而没有同时增加值也是没有任何意义的。如果试图调用add方法，会抛出一个UnsupportedOperationException,条目集视图有同样的限制，尽管理论上增加一个新的键值对好像是有意义的</p>
<h3 id="弱散列映射"><a href="#弱散列映射" class="headerlink" title="弱散列映射"></a>弱散列映射</h3><p>如果有一个值，对应的键已经不再使用了，假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了，垃圾回收器无法删除它，这是为什么呐？</p>
<p>垃圾回收器跟踪活动的对象，只要映射对象是活动的，其中的所有桶也是活动的，它们就不能被回收，因此需要由程序员负责从长期存活的映射表中删除那些无用的值，或者使用WeakHashMap完成这件事情，当对键的唯一引用来自散列条目时，这一数据结构将与垃圾收集器系统工作一起删除键值对</p>
<p>WeakHashMap使用弱引用保存键，WeakReference对象将引用保存到另外一个对象中，如果垃圾收集器发现某个特定的对象已经没有他人引用了，就将其回收。</p>
<p>如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中，WeakHashMap将周期性地检查队列，以便找出新添加的弱引用，一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来，于是WeakHashMao将删除对应的条目</p>
<h3 id="链接散列集与映射"><a href="#链接散列集与映射" class="headerlink" title="链接散列集与映射"></a>链接散列集与映射</h3><p>LinkedHashSet和LinkedHashMap类用来记住插入元素项的顺序，这样就可以避免在散列表中的项从表面上看是随机排列的，当条目插入到表中时，就会并入到双向链表中</p>
<p><img src="/" class="lazyload" data-src="/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/029.png"  alt="Java核心卷——基础知识"></p>
<p>映射表插入的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Employee〉staff &#x3D; new LinkedHashMap&lt;&gt;();</span><br><span class="line">staff.put(&quot;144-25-5464&quot;, new Employee(&quot;Amy Lee&quot;));</span><br><span class="line">staff.put(&quot;567-24-2546&quot;, new Employee(&quot;Harry Hacker&quot;));</span><br><span class="line">staff.put(&quot;157-62-7935&quot;, new Employee(&quot;Gary Cooper&quot;));</span><br><span class="line">staff.put(&quot;456-62-5527&quot;, new Employee(&quot;Francesca Cruz&quot;)；</span><br></pre></td></tr></table></figure>

<p>然后，staff.keySet().iterator()以下面的次序枚举值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">144-25-5464</span><br><span class="line">567-24-2546</span><br><span class="line">157-62-7935</span><br><span class="line">456-62-5527</span><br></pre></td></tr></table></figure>

<p>并且staff.values().iterator()以下列顺序枚举这些值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Amy Lee</span><br><span class="line">Harry Hacker</span><br><span class="line">Gary Cooper</span><br><span class="line">Francesca Cruz</span><br></pre></td></tr></table></figure>

<p>链接散列映射LinkedHashMap将用访问顺序，而不是插入顺序对映射条目进行迭代，每次调用get或put，收到影响的条目将从当前的位置删除，并放到条目链表的尾部？？？？</p>
<h3 id="枚举集和映射"><a href="#枚举集和映射" class="headerlink" title="枚举集和映射"></a>枚举集和映射</h3><p>EnumSet是一个枚举类型元素集的高效实现，由于枚举类型只有有限个实例，所以EnumSet内部用位序列实现，如果对应的值在集中，则相应的位被置为1</p>
<p>EnumSet类没有公共的构造器类，可以使用静态工厂方法构造这个集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always &#x3D; EnumSet.allOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; never &#x3D; EnumSet.noneOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; workday &#x3D; EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);</span><br><span class="line">EnumSet&lt;Weekday&gt; mwf &#x3D; EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);</span><br></pre></td></tr></table></figure>

<p>可以使用Set接口的常用方法来修改EnumSet，EnumMap是一个键类型为枚举类型的映射，它可以直接且高效地用一个值数组实现，在使用时需要在构造器中指定键类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnumMap&lt;Weekday, Employee&gt; personlnCharge &#x3D; new EnumMapo(Weekday.class);</span><br></pre></td></tr></table></figure>

<p>在EnumSet的API文档中，将会看到E extends Enum<E>这样奇怪的类型参数，它的意思是E是一个枚举类型，所有的枚举类型都扩展于泛型Enum类，例如Weekday扩展Enum<Weekday></Weekday></E></p>
<h3 id="标识散列映射"><a href="#标识散列映射" class="headerlink" title="标识散列映射"></a>标识散列映射</h3><p>类IdentityHashMap有特殊的作用，这个类中，键的散列值不是用hashCode函数计算的，而是用System.identityHashCode方法计算的，这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式，而且，在对两个对象进行比较时，IdentityHashMap类使用==，而不是使用equals</p>
<p>不同的键对象，即使内容相同，也被视为是不同的对象，在实现对象遍历算法时，这个类非常有用，可以用来跟踪每个对象的遍历状况</p>
<h2 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h2><p>通过使用视图可以获得其他的实现了Collection接口和Map接口的对象，映射类的keySet方法就是一个这样的示例</p>
<p>keySet并不是创建了一个新集，keySet方法返回一个实现Set接口的类对象，这个类的方法对原映射进行操作，这种集合称为视图</p>
<h3 id="轻量级集合包装器"><a href="#轻量级集合包装器" class="headerlink" title="轻量级集合包装器"></a>轻量级集合包装器</h3><p>Arrays类的静态方法asList将返回一个包装了普通Java数组的List包装器，这个方法可以将数组传递给一个期望得到列表或集合的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Card[] cardDeck &#x3D; new Card[52];</span><br><span class="line">List&lt;Card&gt; cardList &#x3D; Arrays.asList(cardDeck):</span><br></pre></td></tr></table></figure>

<p>返回的对象不是ArrayList，它是一个视图对象，带有访问底层数组的get和set方法。改变数组大小的所有方法(迭代器相关的add和remove方法)都会抛出一个Unsupported OperationException异常</p>
<p>aList方法可以接收可变数目的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names &#x3D; Arrays.asList(&quot;Amy&quot; , &quot;Bob&quot;, &quot;Carl &quot;);</span><br></pre></td></tr></table></figure>

<p>这个方法调用将返回一个实现了List接口的不可修改的对象，并给人一种包含n个元素，每个元素都像是一个anObject的感觉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; settings &#x3D; Collections.nCopies(100, &quot;DEFAULT&quot;);</span><br></pre></td></tr></table></figure>

<p>创建一个包含100个字符串的List，每个串都被设置为DEFAULT</p>
<p>Collections类包含了很多实用方法，这些方法的参数和返回值都是集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; deepThoughts &#x3D; Col1ections.emptySet();</span><br></pre></td></tr></table></figure>

<h3 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h3><p>可以为很多集合建立子范围视图，假设有一个列表staff，想从中取出第10个到第19个元素，可以使用subList方法来获得一个列表的子范围视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List group2 &#x3D; staff.subList(10, 20);</span><br></pre></td></tr></table></figure>

<p>第一个索引包含在内，第二个索引则不包含在内，这与String类的substring操作中的参数情况相同</p>
<p>可以将任何操作应用于子范围，并且能够自动地反应整个列表的情况，可以删除整个子范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group2.clear(); &#x2F;&#x2F; staff reduction</span><br></pre></td></tr></table></figure>

<p>对于有序集和映射，可以使用排序顺序而不是元素位置建立子范围，SortedSet接口声明了三个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SortedSet&lt; E&gt; subSet(E from, E to)</span><br><span class="line">SortedSet&lt; E&gt; headSet(E to)</span><br><span class="line">SortedSet&lt; E&gt; tailSet(E from)</span><br></pre></td></tr></table></figure>

<p>这些方法将返回大于等于from且小于to的所有元素子集</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h3><p>Collections类中的sort方法可以对实现了List接口的集合进行排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">Collections.sort(staff);</span><br></pre></td></tr></table></figure>

<p>这个方法假定列表元素实现了Comparable接口，如果想要采用其他方式对列表进行排序，可以使用List接口的Sort方法并传入一个Comparator对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary));</span><br></pre></td></tr></table></figure>

<p>如果想按照降序对列表进行排序，可以使用静态方法Collections.reverseOrder(),这个方法将返回一个比较器，比较器则返回b.compareTo(a)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.sort(Comparator.reverseOrder())</span><br></pre></td></tr></table></figure>

<p>算法这部分先跳过了</p>
<h1 id="部署Java应用程序"><a href="#部署Java应用程序" class="headerlink" title="部署Java应用程序"></a>部署Java应用程序</h1><h2 id="JAR文件"><a href="#JAR文件" class="headerlink" title="JAR文件"></a>JAR文件</h2><p>在应用程序进行打包时，使用者一定希望仅提供给其一个单独的文件，而不是一个含有大量类文件的目录，Java归档(JAR)文件就是为此目的实现的，一个JAR文件既可以包含类文件，也可以包含诸如图像和声音这些其他类型的文件。此外JAR文件是压缩的，使用的是ZIP压缩格式</p>
<p>pack200是一种较通常的ZIP压缩算法更加有效的压缩类文件的方式</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">李上</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">http://yoursite.com/2020/05/07/Java%E6%A0%B8%E5%BF%83%E5%8D%B7%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">定不辱使命</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post_share"><div class="social-share" data-image="/img/sharding-jdbc.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/09/mysql/"><img class="prev_cover lazyload" data-src="/img/mysql.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL学习笔记</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/28/juc/"><img class="next_cover lazyload" data-src="/img/juc.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC(java.util.concurrent)学习笔记</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 李上</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>