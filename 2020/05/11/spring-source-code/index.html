<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring源码分析 | 定不辱使命</title><meta name="description" content="Spring源码分析"><meta name="author" content="李上"><meta name="copyright" content="李上"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring源码分析"><meta name="twitter:description" content="Spring源码分析"><meta name="twitter:image" content="http://yoursite.com/img/springcode.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Spring源码分析"><meta property="og:url" content="http://yoursite.com/2020/05/11/spring-source-code/"><meta property="og:site_name" content="定不辱使命"><meta property="og:description" content="Spring源码分析"><meta property="og:image" content="http://yoursite.com/img/springcode.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/05/11/spring-source-code/"><link rel="prev" title="Dubbo入门学习" href="http://yoursite.com/2020/05/13/dubbo/"><link rel="next" title="MySQL学习笔记" href="http://yoursite.com/2020/05/09/mysql/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IOC"><span class="toc-number">1.</span> <span class="toc-text">IOC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-number">1.1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory简介"><span class="toc-number">1.2.</span> <span class="toc-text">BeanFactory简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动过程分析"><span class="toc-number">1.3.</span> <span class="toc-text">启动过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建Bean容器前的准备工作"><span class="toc-number">1.3.1.</span> <span class="toc-text">创建Bean容器前的准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建Bean容器，加载并注册Bean"><span class="toc-number">1.3.2.</span> <span class="toc-text">创建Bean容器，加载并注册Bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinition接口定义"><span class="toc-number">1.3.3.</span> <span class="toc-text">BeanDefinition接口定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#customizeBeanFactory"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">customizeBeanFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载Bean-loadBeanDefinitions"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">加载Bean:loadBeanDefinitions</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#doRegisterBeanDefinitions"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">doRegisterBeanDefinitions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#processBeanDefinition"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">processBeanDefinition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#注册Bean"><span class="toc-number">1.3.3.2.3.</span> <span class="toc-text">注册Bean</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean容器实例化完成后"><span class="toc-number">1.3.4.</span> <span class="toc-text">Bean容器实例化完成后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#准备Bean容器：prepareBeanFactory"><span class="toc-number">1.3.5.</span> <span class="toc-text">准备Bean容器：prepareBeanFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化所有的singleton-beans"><span class="toc-number">1.3.6.</span> <span class="toc-text">初始化所有的singleton beans</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#preInstantiateSingletons"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">preInstantiateSingletons</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getBean"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">getBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建Bean"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">创建Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建Bean实例"><span class="toc-number">1.3.6.3.1.</span> <span class="toc-text">创建Bean实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bean属性注入"><span class="toc-number">1.3.6.3.2.</span> <span class="toc-text">bean属性注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#initializeBean"><span class="toc-number">1.3.6.3.3.</span> <span class="toc-text">initializeBean</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附录"><span class="toc-number">2.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#id和name"><span class="toc-number">2.1.</span> <span class="toc-text">id和name</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置是否允许bean覆盖，是否允许循环依赖"><span class="toc-number">2.2.</span> <span class="toc-text">配置是否允许bean覆盖，是否允许循环依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#profile"><span class="toc-number">2.3.</span> <span class="toc-text">profile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂模式生成Bean"><span class="toc-number">2.4.</span> <span class="toc-text">工厂模式生成Bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FactoryBean"><span class="toc-number">2.5.</span> <span class="toc-text">FactoryBean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化Bean的回调"><span class="toc-number">2.6.</span> <span class="toc-text">初始化Bean的回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#销毁Bean的回调"><span class="toc-number">2.7.</span> <span class="toc-text">销毁Bean的回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConversionService"><span class="toc-number">2.8.</span> <span class="toc-text">ConversionService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean继承"><span class="toc-number">2.9.</span> <span class="toc-text">Bean继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法注入"><span class="toc-number">2.10.</span> <span class="toc-text">方法注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lookup-method"><span class="toc-number">2.10.1.</span> <span class="toc-text">lookup-method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replaced-method"><span class="toc-number">2.10.2.</span> <span class="toc-text">replaced-method</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanPostProcessor"><span class="toc-number">2.11.</span> <span class="toc-text">BeanPostProcessor</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/springcode.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">定不辱使命</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Spring源码分析</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-11 17:39:32"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-11</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-21 14:31:39"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-08-21</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最基本的启动Spring容器的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext context &#x3D; new        ClassPathXmlApplicationContext(&quot;classpath:applicationfile.xml&quot;);                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上以下依赖，就可以利用配置文件来启动一个Spring容器了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.3.11.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>不提倡不知道要添加什么依赖，然后把Spring的所有相关的东西都加进来的方式</p>
<p>spring-context会自动将spring-core,spring-beans,spring-aop,spring-expression这几个基础jar包带进来</p>
<p>除了ClassPathXmlApplicationContext以外，也可以有其他方式来创建ApplicationContext，先来看看大体的继承结构</p>
<p><img src="/" class="lazyload" data-src="/2020/05/11/spring-source-code/001.png"  alt="spring-source-code"></p>
<p>Spring为了适应各种使用场景，提供的各个接口都可能有很多的实现类，对于我们来说，就是揪着一个完整的分支看完</p>
<p>可以看到 ClassPathXmlApplicationContext  兜兜转转了好久才到 ApplicationContext接口，同样的，使用 绿颜色的 FileSystemXmlApplicationContext 和 AnnotationConfigApplicationContext 这两个类也可以创建ApplicationContext</p>
<p>FileSystemXmlApplicationContext的构造函数需要一个xml配置文件在系统中的路径，其他和ClassPathXmlApplicationContext基本一样</p>
<p>AnnotationConfigApplicationContext 是基于注解来使用的，不需要配置文件，采用Java配置类和各种注解来配置，是比较简单的方式</p>
<p>本文使用 ClassPathXmlApplicationContext进行分析，先来一个例子看看怎么实例化ApplicationContext </p>
<p>定义一个接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageService &#123;</span><br><span class="line">    String getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义接口实现类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MessageServiceImpl implements MessageService &#123;</span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return &quot;hello world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，在resources目录新建一个配置文件，通常叫application.xml或application-xxx.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;beans xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot; default-autowire&#x3D;&quot;byName&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;bean id&#x3D;&quot;messageService&quot; class&#x3D;&quot;com.javadoop.example.MessageServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>然后就可以跑起来了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 用我们的配置文件来启动一个 ApplicationContext</span><br><span class="line">        ApplicationContext context &#x3D; new      ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;);</span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;context 启动成功&quot;);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span><br><span class="line">        MessageService messageService &#x3D; context.getBean(MessageService.class);</span><br><span class="line">        &#x2F;&#x2F; 这句将输出: hello world</span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎样通过配置文件来启动Spring的ApplicationContext？这是接下来分析IOC的核心了， ApplicationContext 启动过程中，会负责创建实例Bean，往各个Bean中注入依赖等</p>
<h2 id="BeanFactory简介"><a href="#BeanFactory简介" class="headerlink" title="BeanFactory简介"></a>BeanFactory简介</h2><p> ApplicationContext其实就是shi一个BeanFactory,下图是BeanFactory接口相关的主要的继承结构</p>
<p><img src="/" class="lazyload" data-src="/2020/05/11/spring-source-code/002.png"  alt="spring-source-code"></p>
<ol>
<li>ApplicationContext继承了ListableBeanFactory，这个Listable的意思是通过这个接口可以获取多个Bean,最顶层BeanFactory接口的方法都是获取单个Bean的</li>
<li>ApplicationContext继承了HierarchicalBeanFactory ， Hierarchical单词本身已经能说明问题了，也就是说可以在应用中起多个BeanFactory，然后可以将各个BeanFactory设置为父子关系</li>
<li>AutowireCapableBeanFactory就是用来自动装配Bean用的，但是ApplicationContext并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合， ApplicationContext接口中定义了一个 getAutowireCapableBeanFactory()方法</li>
<li>ConfigurableListableBeanFactory也是一个特殊的接口，特殊之处在于它继承了第二层所有的三个接口，而ApplicationContext没有</li>
</ol>
<h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2><p>第一步，从ClassPathXmlApplicationContext的构造方法说起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext &#123;</span><br><span class="line">  private Resource[] configResources;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span><br><span class="line">  public ClassPathXmlApplicationContext(ApplicationContext parent) &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</span><br><span class="line">      throws BeansException &#123;</span><br><span class="line"> </span><br><span class="line">    super(parent);</span><br><span class="line">    &#x2F;&#x2F; 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    if (refresh) &#123;</span><br><span class="line">      refresh(); &#x2F;&#x2F; 核心方法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplicationContext 建立起来以后，其实是可以通过调用refresh()这个方法重建的，这样会将原来的 ApplicationContext销毁，然后再重新执行一次初始化操作</p>
<p>refresh()方法里面调用了很多的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   &#x2F;&#x2F; 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class="line">      prepareRefresh();</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class="line">      &#x2F;&#x2F; 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class="line">      &#x2F;&#x2F; 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class="line">      &#x2F;&#x2F; 这块待会会展开说</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"> </span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class="line">         &#x2F;&#x2F; 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class="line">         &#x2F;&#x2F; 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         &#x2F;&#x2F; 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class="line">         &#x2F;&#x2F; 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class="line">         &#x2F;&#x2F; 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class="line">         initMessageSource();</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 从方法名就可以知道，典型的模板方法(钩子方法)，</span><br><span class="line">         &#x2F;&#x2F; 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class="line">         onRefresh();</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class="line">         registerListeners();</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 重点，重点，重点</span><br><span class="line">         &#x2F;&#x2F; 初始化所有的 singleton beans</span><br><span class="line">         &#x2F;&#x2F;（lazy-init 的除外）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 最后，广播事件，ApplicationContext 初始化完成</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                  &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         &#x2F;&#x2F; 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class="line">         destroyBeans();</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; Reset &#39;active&#39; flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 把异常往外抛</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      finally &#123;</span><br><span class="line">         &#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we</span><br><span class="line">         &#x2F;&#x2F; might not ever need metadata for singleton beans anymore...</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面开始一步步来肢解这个refresh()方法</p>
<h3 id="创建Bean容器前的准备工作"><a href="#创建Bean容器前的准备工作" class="headerlink" title="创建Bean容器前的准备工作"></a>创建Bean容器前的准备工作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void prepareRefresh() &#123;</span><br><span class="line">   &#x2F;&#x2F; 记录启动时间，</span><br><span class="line">   &#x2F;&#x2F; 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span><br><span class="line">   this.startupDate &#x3D; System.currentTimeMillis();</span><br><span class="line">   this.closed.set(false);</span><br><span class="line">   this.active.set(true);</span><br><span class="line"> </span><br><span class="line">   if (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(&quot;Refreshing &quot; + this);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Initialize any placeholder property sources in the context environment</span><br><span class="line">   initPropertySources();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 校验 xml 配置文件</span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"> </span><br><span class="line">   this.earlyApplicationEvents &#x3D; new LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Bean容器，加载并注册Bean"><a href="#创建Bean容器，加载并注册Bean" class="headerlink" title="创建Bean容器，加载并注册Bean"></a>创建Bean容器，加载并注册Bean</h3><p>这个方法是全文最重要的部分之一，这里将会初始化BeanFactory,加载Bean,注册Bean等等，当然这步结束，Bean并没有完成初始化</p>
<p> AbstractApplicationContext.java </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">   &#x2F;&#x2F; 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 返回刚刚创建的 BeanFactory</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory &#x3D; getBeanFactory();</span><br><span class="line">   if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> AbstractRefreshableApplicationContext.java 120 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">   &#x2F;&#x2F; 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span><br><span class="line">   &#x2F;&#x2F; 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span><br><span class="line">   &#x2F;&#x2F; ApplicationContext 是否有 BeanFactory</span><br><span class="line">   if (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span><br><span class="line">      DefaultListableBeanFactory beanFactory &#x3D; createBeanFactory();</span><br><span class="line">      &#x2F;&#x2F; 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 下面这两个方法很重要，别跟丢了，具体细节之后说</span><br><span class="line">      &#x2F;&#x2F; 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 加载 Bean 到 BeanFactory 中</span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">         this.beanFactory &#x3D; beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (IOException ex) &#123;</span><br><span class="line">      throw new ApplicationContextException(&quot;I&#x2F;O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ApplicationContext继承自BeanFactory，但是它不应该被理解为BeanFactory的实现类，而是说其内部持有一个实例化的BeanFactory( DefaultListableBeanFactory ),以后所有的BeanFactory相关的操作其实是给这个实例来处理的</p>
<p>为什么要实例化DefaultListableBeanFactory？ </p>
<p>ConfigurableListableBeanFactory只有一个实现类 DefaultListableBeanFactory ，而且实现类DefaultListableBeanFactory还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路，所以DefaultListableBeanFactory基本上是最牛的BeanFactory，这也是为什么会使用这个类来实例化的原因</p>
<p>BeanFactory是Bean容器，那么Bean又是什么呐？我们需要先了解BeanDefinition</p>
<p>这里的BeanDefinition就是SPring的Bean，我们自定义的各个Bean其实会转换成一个个BeanDefinition存在于Spring的BeanFactory中，Bean在代码层面上是BeanDefinition的实例</p>
<p>BeanDefinition中保存了Bean的信息，比如这个Bean指向哪个类，是否是单例的，是否懒加载，这个Bean依赖了那些Bean等等</p>
<h3 id="BeanDefinition接口定义"><a href="#BeanDefinition接口定义" class="headerlink" title="BeanDefinition接口定义"></a>BeanDefinition接口定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 我们可以看到，默认只提供 sington 和 prototype 两种，</span><br><span class="line">   &#x2F;&#x2F; 很多读者都知道还有 request, session, globalSession, application, websocket 这几种，</span><br><span class="line">   &#x2F;&#x2F; 不过，它们属于基于 web 的扩展。</span><br><span class="line">   String SCOPE_SINGLETON &#x3D; ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   String SCOPE_PROTOTYPE &#x3D; ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 比较不重要，直接跳过吧</span><br><span class="line">   int ROLE_APPLICATION &#x3D; 0;</span><br><span class="line">   int ROLE_SUPPORT &#x3D; 1;</span><br><span class="line">   int ROLE_INFRASTRUCTURE &#x3D; 2;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录介绍</span><br><span class="line">   void setParentName(String parentName);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 获取父 Bean</span><br><span class="line">   String getParentName();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 设置 Bean 的类名称</span><br><span class="line">   void setBeanClassName(String beanClassName);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 获取 Bean 的类名称</span><br><span class="line">   String getBeanClassName();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 设置 bean 的 scope</span><br><span class="line">   void setScope(String scope);</span><br><span class="line"> </span><br><span class="line">   String getScope();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 设置是否懒加载</span><br><span class="line">   void setLazyInit(boolean lazyInit);</span><br><span class="line"> </span><br><span class="line">   boolean isLazyInit();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span><br><span class="line">   &#x2F;&#x2F; 是 depends-on&#x3D;&quot;&quot; 属性设置的值。</span><br><span class="line">   void setDependsOn(String... dependsOn);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 返回该 Bean 的所有依赖</span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span><br><span class="line">   &#x2F;&#x2F; 如果根据名称注入，即使这边设置了 false，也是可以的</span><br><span class="line">   void setAutowireCandidate(boolean autowireCandidate);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 该 Bean 是否可以注入到其他 Bean 中</span><br><span class="line">   boolean isAutowireCandidate();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span><br><span class="line">   void setPrimary(boolean primary);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 是否是 primary 的</span><br><span class="line">   boolean isPrimary();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span><br><span class="line">   void setFactoryBeanName(String factoryBeanName);</span><br><span class="line">   &#x2F;&#x2F; 获取工厂名称</span><br><span class="line">   String getFactoryBeanName();</span><br><span class="line">   &#x2F;&#x2F; 指定工厂类中的 工厂方法名称</span><br><span class="line">   void setFactoryMethodName(String factoryMethodName);</span><br><span class="line">   &#x2F;&#x2F; 获取工厂类中的 工厂方法名称</span><br><span class="line">   String getFactoryMethodName();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 构造器参数</span><br><span class="line">   ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span><br><span class="line">   MutablePropertyValues getPropertyValues();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 是否 singleton</span><br><span class="line">   boolean isSingleton();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 是否 prototype</span><br><span class="line">   boolean isPrototype();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 如果这个 Bean 原生是抽象类，那么不能实例化</span><br><span class="line">   boolean isAbstract();</span><br><span class="line"> </span><br><span class="line">   int getRole();</span><br><span class="line">   String getDescription();</span><br><span class="line">   String getResourceDescription();</span><br><span class="line">   BeanDefinition getOriginatingBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里接口虽然那么多，但是没有类似getInstance()这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例去哪里了？后面会讲到</p>
<p>再看refreshBeanFactory()方法中的剩余部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br></pre></td></tr></table></figure>

<h4 id="customizeBeanFactory"><a href="#customizeBeanFactory" class="headerlink" title="customizeBeanFactory"></a>customizeBeanFactory</h4><p>customizeBeanFactory(beanFactory)比较简单，就是配置是否允许BeanDefinition覆盖，是否允许循环引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class="line">   if (this.allowBeanDefinitionOverriding !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 是否允许 Bean 定义覆盖</span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   if (this.allowCircularReferences !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 是否允许 Bean 间的循环依赖</span><br><span class="line">      beanFactory.setAllowCircularReferences(this.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinition的覆盖问题</p>
<p>配置文件中定义bean时使用了相同的id或name,默认情况下，allowBeanDefinitionOverriding属性为Null,如果在同一个配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖</p>
<p>循环引用</p>
<p>A依赖B,B依赖A;或者A依赖B,B依赖C,而C依赖A</p>
<p>默认情况下，Spring允许循环依赖，当然如果在A中的构造方法中依赖B，在B的构造方法中依赖A是不行的</p>
<h4 id="加载Bean-loadBeanDefinitions"><a href="#加载Bean-loadBeanDefinitions" class="headerlink" title="加载Bean:loadBeanDefinitions"></a>加载Bean:loadBeanDefinitions</h4><p>这个方法将根据配置，加载各个Bean，然后放到BeanFactory中。读取配置的操作在XmlBeanDefinitionReader中，其负责加载配置，解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*&#x2F;</span><br><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">   &#x2F;&#x2F; 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader &#x3D; new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Configure the bean definition reader with this context&#39;s</span><br><span class="line">   &#x2F;&#x2F; resource loading environment.</span><br><span class="line">   beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span><br><span class="line">   &#x2F;&#x2F; 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   &#x2F;&#x2F; 重点来了，继续往下</span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是这个类，接下来用刚刚初始化的Reader开始来加载xml配置，这块代码不是很重要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">   Resource[] configResources &#x3D; getConfigResources();</span><br><span class="line">   if (configResources !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 往下看</span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] configLocations &#x3D; getConfigLocations();</span><br><span class="line">   if (configLocations !&#x3D; null) &#123;</span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(resources, &quot;Resource array must not be null&quot;);</span><br><span class="line">   int counter &#x3D; 0;</span><br><span class="line">   &#x2F;&#x2F; 注意这里是个 for 循环，也就是每个文件是一个 resource</span><br><span class="line">   for (Resource resource : resources) &#123;</span><br><span class="line">      &#x2F;&#x2F; 继续往下看</span><br><span class="line">      counter +&#x3D; loadBeanDefinitions(resource);</span><br><span class="line">   &#125;</span><br><span class="line">   return counter;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; XmlBeanDefinitionReader 303</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; XmlBeanDefinitionReader 314</span><br><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);</span><br><span class="line">   if (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 用一个 ThreadLocal 来存放所有的配置文件资源</span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources &#x3D; this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   if (currentResources &#x3D;&#x3D; null) &#123;</span><br><span class="line">      currentResources &#x3D; new HashSet&lt;EncodedResource&gt;(4);</span><br><span class="line">      this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   if (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      throw new BeanDefinitionStoreException(</span><br><span class="line">            &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   try &#123;</span><br><span class="line">      InputStream inputStream &#x3D; encodedResource.getResource().getInputStream();</span><br><span class="line">      try &#123;</span><br><span class="line">         InputSource inputSource &#x3D; new InputSource(inputStream);</span><br><span class="line">         if (encodedResource.getEncoding() !&#x3D; null) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F; 核心部分</span><br><span class="line">         return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      finally &#123;</span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (IOException ex) &#123;</span><br><span class="line">      throw new BeanDefinitionStoreException(</span><br><span class="line">            &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      if (currentResources.isEmpty()) &#123;</span><br><span class="line">         this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 还在这个文件中，第 388 行</span><br><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里就不看了</span><br><span class="line">      Document doc &#x3D; doLoadDocument(inputSource, resource);</span><br><span class="line">      &#x2F;&#x2F; 继续</span><br><span class="line">      return registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 还在这个文件中，第 505 行</span><br><span class="line">&#x2F;&#x2F; 返回从当前配置文件加载了多少数量的 Bean</span><br><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">   BeanDefinitionDocumentReader documentReader &#x3D; createBeanDefinitionDocumentReader();</span><br><span class="line">   int countBefore &#x3D; getRegistry().getBeanDefinitionCount();</span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; DefaultBeanDefinitionDocumentReader 90</span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class="line">   this.readerContext &#x3D; readerContext;</span><br><span class="line">   logger.debug(&quot;Loading bean definitions&quot;);</span><br><span class="line">   Element root &#x3D; doc.getDocumentElement();</span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过漫长的链路，一个配置文件终于转换为一颗DOM树，注意这里指的是其中一个配置文件，不是所有的，下面开始从根节点开始解析</p>
<h5 id="doRegisterBeanDefinitions"><a href="#doRegisterBeanDefinitions" class="headerlink" title="doRegisterBeanDefinitions"></a>doRegisterBeanDefinitions</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; default namespace 涉及到的就四个标签 &lt;import &#x2F;&gt;、&lt;alias &#x2F;&gt;、&lt;bean &#x2F;&gt; 和 &lt;beans &#x2F;&gt;，</span><br><span class="line">&#x2F;&#x2F; 其他的属于 custom 的</span><br><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      NodeList nl &#x3D; root.getChildNodes();</span><br><span class="line">      for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node &#x3D; nl.item(i);</span><br><span class="line">         if (node instanceof Element) &#123;</span><br><span class="line">            Element ele &#x3D; (Element) node;</span><br><span class="line">            if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了 </p>
<p>parseDefaultElement(ele, delegate)代表解析的节点是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import&#x2F;&gt;,&lt;alias&#x2F;&gt;,&lt;bean&#x2F;&gt;,&lt;beans&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>这四个标签之所以是default的，是因为它们是处于这个namespace下定义的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br></pre></td></tr></table></figure>

<p>第二行就是xmlns</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">          http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;</span><br><span class="line">       default-autowire&#x3D;&quot;byName&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>而对于其他标签，将进入到delegate.parseCustomElement(ele)这个分支，解析以下节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc &#x2F;&gt;、&lt;task &#x2F;&gt;、&lt;context &#x2F;&gt;、&lt;aop &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>这些属于扩展，如果需要使用上面这些非default标签，那么上面的xml头部的地方也要引入相应的namespace和.xsd文件的路径。同时代码中需要提供相应的parser来解析，如MvcNamespaceHandler，TaskNamespaceHandler,ContextNamespaceHandler,AopNamespaceHandler等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">      xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans </span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc   </span><br><span class="line">           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd  </span><br><span class="line">       &quot;</span><br><span class="line">      default-autowire&#x3D;&quot;byName&quot;&gt;</span><br></pre></td></tr></table></figure>

<p> 假如读者想分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location&#x3D;&quot;classpath:xx.properties&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>就应该到 ContextNamespaceHandler 中找答案 </p>
<p>再来看看处理default标签的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理 &lt;import &#x2F;&gt; 标签</span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理 &lt;alias &#x2F;&gt; 标签定义</span><br><span class="line">      &#x2F;&#x2F; &lt;alias name&#x3D;&quot;fromName&quot; alias&#x3D;&quot;toName&quot;&#x2F;&gt;</span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理 &lt;bean &#x2F;&gt; 标签定义，这也算是我们的重点吧</span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125;</span><br><span class="line">   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果碰到的是嵌套的 &lt;beans &#x2F;&gt; 标签，需要递归</span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挑出重点的bean标签来说</p>
<h5 id="processBeanDefinition"><a href="#processBeanDefinition" class="headerlink" title="processBeanDefinition"></a>processBeanDefinition</h5><p>下面是processBeanDefinition解析bean标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   &#x2F;&#x2F; 将 &lt;bean &#x2F;&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看</span><br><span class="line">   BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的</span><br><span class="line"> </span><br><span class="line">   if (bdHolder !&#x3D; null) &#123;</span><br><span class="line">      bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; Register the final decorated instance.</span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +</span><br><span class="line">               bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; Send registration event.</span><br><span class="line">      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着往下看，我们先看下bean标签中可以定义那些属性</p>
<p><img src="/" class="lazyload" data-src="/2020/05/11/spring-source-code/003.png"  alt="spring-source-code"></p>
<p>像下面这个样子进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exampleBean&quot; name&#x3D;&quot;name1, name2, name3&quot; class&#x3D;&quot;com.javadoop.ExampleBean&quot;</span><br><span class="line">      scope&#x3D;&quot;singleton&quot; lazy-init&#x3D;&quot;true&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;cleanup&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- 可以用下面三种形式指定构造参数 --&gt;</span><br><span class="line">  &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;constructor-arg name&#x3D;&quot;years&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!-- property 的几种情况 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;beanOne&quot;&gt;</span><br><span class="line">        &lt;ref bean&#x3D;&quot;anotherExampleBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;beanTwo&quot; ref&#x3D;&quot;yetAnotherBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;integerProperty&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>再接着往里看怎么解析bean元素，是怎么转换到BeanDefinitionHolder的</p>
<p> BeanDefinitionParserDelegate </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">    return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class="line">   String id &#x3D; ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">   String nameAttr &#x3D; ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"> </span><br><span class="line">   List&lt;String&gt; aliases &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 将 name 属性的定义按照 ”逗号、分号、空格“ 切分，形成一个别名列表数组，</span><br><span class="line">   &#x2F;&#x2F; 当然，如果你不定义的话，就是空的了</span><br><span class="line">   &#x2F;&#x2F; 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了</span><br><span class="line">   if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr &#x3D; StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   String beanName &#x3D; id;</span><br><span class="line">   &#x2F;&#x2F; 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span><br><span class="line">   if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName &#x3D; aliases.remove(0);</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(&quot;No XML &#39;id&#39; specified - using &#39;&quot; + beanName +</span><br><span class="line">               &quot;&#39; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   if (containingBean &#x3D;&#x3D; null) &#123;</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 根据 &lt;bean ...&gt;...&lt;&#x2F;bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span><br><span class="line">   &#x2F;&#x2F; 细节后面再说</span><br><span class="line">   AbstractBeanDefinition beanDefinition &#x3D; parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 到这里，整个 &lt;bean &#x2F;&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span><br><span class="line">   if (beanDefinition !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span><br><span class="line">      &#x2F;&#x2F; 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要</span><br><span class="line">      if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            if (containingBean !&#x3D; null) &#123;&#x2F;&#x2F; 按照我们的思路，这里 containingBean 是 null 的</span><br><span class="line">               beanName &#x3D; BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">               &#x2F;&#x2F; 如果我们不定义 id 和 name，那么我们引言里的那个例子：</span><br><span class="line">               &#x2F;&#x2F;   1. beanName 为：com.javadoop.example.MessageServiceImpl#0</span><br><span class="line">               &#x2F;&#x2F;   2. beanClassName 为：com.javadoop.example.MessageServiceImpl</span><br><span class="line"> </span><br><span class="line">               beanName &#x3D; this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line"> </span><br><span class="line">               String beanClassName &#x3D; beanDefinition.getBeanClassName();</span><br><span class="line">               if (beanClassName !&#x3D; null &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  &#x2F;&#x2F; 把 beanClassName 设置为 Bean 的别名</span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(&quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &quot; +</span><br><span class="line">                     &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            return null;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray &#x3D; StringUtils.toStringArray(aliases);</span><br><span class="line">      &#x2F;&#x2F; 返回 BeanDefinitionHolder</span><br><span class="line">      return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看怎么根据配置创建BeanDefinition</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">      Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class="line"> </span><br><span class="line">   this.parseState.push(new BeanEntry(beanName));</span><br><span class="line"> </span><br><span class="line">   String className &#x3D; null;</span><br><span class="line">   if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      className &#x3D; ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   try &#123;</span><br><span class="line">      String parent &#x3D; null;</span><br><span class="line">      if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">         parent &#x3D; ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span><br><span class="line">      AbstractBeanDefinition bd &#x3D; createBeanDefinition(className, parent);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span><br><span class="line">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"> </span><br><span class="line">      &#x2F;**</span><br><span class="line">       * 下面的一堆是解析 &lt;bean&gt;......&lt;&#x2F;bean&gt; 内部的子元素，</span><br><span class="line">       * 解析出来以后的信息都放到 bd 的属性中</span><br><span class="line">       *&#x2F;</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 解析 &lt;meta &#x2F;&gt;</span><br><span class="line">      parseMetaElements(ele, bd);</span><br><span class="line">      &#x2F;&#x2F; 解析 &lt;lookup-method &#x2F;&gt;</span><br><span class="line">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">      &#x2F;&#x2F; 解析 &lt;replaced-method &#x2F;&gt;</span><br><span class="line">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    &#x2F;&#x2F; 解析 &lt;constructor-arg &#x2F;&gt;</span><br><span class="line">      parseConstructorArgElements(ele, bd);</span><br><span class="line">      &#x2F;&#x2F; 解析 &lt;property &#x2F;&gt;</span><br><span class="line">      parsePropertyElements(ele, bd);</span><br><span class="line">      &#x2F;&#x2F; 解析 &lt;qualifier &#x2F;&gt;</span><br><span class="line">      parseQualifierElements(ele, bd);</span><br><span class="line"> </span><br><span class="line">      bd.setResource(this.readerContext.getResource());</span><br><span class="line">      bd.setSource(extractSource(ele));</span><br><span class="line"> </span><br><span class="line">      return bd;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (ClassNotFoundException ex) &#123;</span><br><span class="line">      error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (NoClassDefFoundError err) &#123;</span><br><span class="line">      error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   finally &#123;</span><br><span class="line">      this.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经完成了根据配置文件创建一个 BeanDefinitionHolder实例</p>
<p>回到解析<bean>的入口方法</bean></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">   &#x2F;&#x2F; 将 &lt;bean &#x2F;&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span><br><span class="line">   BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">   if (bdHolder !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果有自定义属性的话，进行相应的解析，先忽略</span><br><span class="line">      bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; 我们把这步叫做 注册Bean 吧</span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +</span><br><span class="line">               bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 注册完成后，发送事件，本文不展开说这个</span><br><span class="line">      getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里已经根据一个bean标签产生了一个BeanDefinitionHolder的实例，这个实例里面也就是一个BeanDefinition的实例和它的beanName,aliases这三个信息，注意我们的关注点始终在BeanDefinition上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BeanDefinitionHolder implements BeanMetadataElement &#123;</span><br><span class="line"> </span><br><span class="line">  private final BeanDefinition beanDefinition;</span><br><span class="line"> </span><br><span class="line">  private final String beanName;</span><br><span class="line"> </span><br><span class="line">  private final String[] aliases;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后准备注册这个BeanDefinition，最后，把这个注册事件发送出去</p>
<h5 id="注册Bean"><a href="#注册Bean" class="headerlink" title="注册Bean"></a>注册Bean</h5><p> BeanDefinitionReaderUtils 143 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanDefinition(</span><br><span class="line">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line"> </span><br><span class="line">   String beanName &#x3D; definitionHolder.getBeanName();</span><br><span class="line">   &#x2F;&#x2F; 注册这个 Bean</span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 如果还有别名的话，也要根据别名统统注册一遍，不然根据别名就找不到 Bean 了，这我们就不开心了</span><br><span class="line">   String[] aliases &#x3D; definitionHolder.getAliases();</span><br><span class="line">   if (aliases !&#x3D; null) &#123;</span><br><span class="line">      for (String alias : aliases) &#123;</span><br><span class="line">         &#x2F;&#x2F; alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span><br><span class="line">         &#x2F;&#x2F; 获取的时候，会先将 alias 转换为 beanName，然后再查找</span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别名注册的放一边，先看看怎么注册Bean</p>
<p> DefaultListableBeanFactory 793 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">      throws BeanDefinitionStoreException &#123;</span><br><span class="line"> </span><br><span class="line">   Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">   Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line"> </span><br><span class="line">   if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         throw new BeanDefinitionStoreException(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span><br><span class="line">   oldBeanDefinition &#x3D; this.beanDefinitionMap.get(beanName);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 处理重复名称的 Bean 定义的情况</span><br><span class="line">   if (oldBeanDefinition !&#x3D; null) &#123;</span><br><span class="line">      if (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果不允许覆盖的话，抛异常</span><br><span class="line">         throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()...</span><br><span class="line">      &#125;</span><br><span class="line">      else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         &#x2F;&#x2F; log...用框架定义的 Bean 覆盖用户自定义的 Bean </span><br><span class="line">      &#125;</span><br><span class="line">      else if (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">         &#x2F;&#x2F; log...用新的 Bean 覆盖旧的 Bean</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         &#x2F;&#x2F; log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 覆盖</span><br><span class="line">      this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; 判断是否已经有其他的 Bean 开始初始化了.</span><br><span class="line">      &#x2F;&#x2F; 注意，&quot;注册Bean&quot; 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span><br><span class="line">      &#x2F;&#x2F; 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span><br><span class="line">      if (hasBeanCreationStarted()) &#123;</span><br><span class="line">         &#x2F;&#x2F; Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">         synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">            this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions &#x3D; new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">            updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            this.beanDefinitionNames &#x3D; updatedDefinitions;</span><br><span class="line">            if (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons &#x3D; new LinkedHashSet&lt;String&gt;(this.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               this.manualSingletonNames &#x3D; updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         &#x2F;&#x2F; 最正常的应该是进到这里。</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span><br><span class="line">         this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         &#x2F;&#x2F; 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span><br><span class="line">         this.beanDefinitionNames.add(beanName);</span><br><span class="line">         &#x2F;&#x2F; 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span><br><span class="line">         &#x2F;&#x2F; 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span><br><span class="line">         &#x2F;&#x2F; 手动指的是通过调用以下方法注册的 bean ：</span><br><span class="line">         &#x2F;&#x2F;     registerSingleton(String beanName, Object singletonObject)</span><br><span class="line">         &#x2F;&#x2F;         这不是重点，解释只是为了不让大家疑惑。Spring 会在后面&quot;手动&quot;注册一些 Bean，如 &quot;environment&quot;、&quot;systemProperties&quot; 等 bean</span><br><span class="line">         this.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 这个不重要，在预初始化的时候会用到，不必管它。</span><br><span class="line">      this.frozenBeanDefinitionNames &#x3D; null;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   if (oldBeanDefinition !&#x3D; null || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里已经初始化了一个Bean容器，bean标签配置也相应的转换为一个个BeanDefinition，然后注册了各个BeanDefinition到注册中心，并且发送了注册事件</p>
<h3 id="Bean容器实例化完成后"><a href="#Bean容器实例化完成后" class="headerlink" title="Bean容器实例化完成后"></a>Bean容器实例化完成后</h3><p>回到refresh()方法，到现在才刚刚说完obtainFreshBeanFactory ()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">   &#x2F;&#x2F; 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span><br><span class="line">   synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span><br><span class="line">      prepareRefresh();</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span><br><span class="line">      &#x2F;&#x2F; 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span><br><span class="line">      &#x2F;&#x2F; 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span><br><span class="line">      ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span><br><span class="line">      &#x2F;&#x2F; 这块待会会展开说</span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"> </span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span><br><span class="line">         &#x2F;&#x2F; 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span><br><span class="line">         &#x2F;&#x2F; 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         &#x2F;&#x2F; 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span><br><span class="line">         &#x2F;&#x2F; 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span><br><span class="line">         &#x2F;&#x2F; 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span><br><span class="line">         initMessageSource();</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 从方法名就可以知道，典型的模板方法(钩子方法)，</span><br><span class="line">         &#x2F;&#x2F; 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span><br><span class="line">         onRefresh();</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span><br><span class="line">         registerListeners();</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 重点，重点，重点</span><br><span class="line">         &#x2F;&#x2F; 初始化所有的 singleton beans</span><br><span class="line">         &#x2F;&#x2F;（lazy-init 的除外）</span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 最后，广播事件，ApplicationContext 初始化完成</span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         if (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                  &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.</span><br><span class="line">         &#x2F;&#x2F; 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span><br><span class="line">         destroyBeans();</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; Reset &#39;active&#39; flag.</span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 把异常往外抛</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      finally &#123;</span><br><span class="line">         &#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we</span><br><span class="line">         &#x2F;&#x2F; might not ever need metadata for singleton beans anymore...</span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="准备Bean容器：prepareBeanFactory"><a href="#准备Bean容器：prepareBeanFactory" class="headerlink" title="准备Bean容器：prepareBeanFactory"></a>准备Bean容器：prepareBeanFactory</h3><p>简单介绍一下prepareBeanFactory(factory)方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Configure the factory&#39;s standard context characteristics,</span><br><span class="line"> * such as the context&#39;s ClassLoader and post-processors.</span><br><span class="line"> * @param beanFactory the BeanFactory to configure</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">   &#x2F;&#x2F; 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span><br><span class="line">   &#x2F;&#x2F; 这里设置为当前 ApplicationContext 的类加载器</span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">   &#x2F;&#x2F; 设置 BeanExpressionResolver</span><br><span class="line">   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#x2F;&#x2F; </span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 添加一个 BeanPostProcessor，这个 processor 比较简单，</span><br><span class="line">   &#x2F;&#x2F; 实现了 Aware 接口的几个特殊的 beans 在初始化的时候，这个 processor 负责回调</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span><br><span class="line">   &#x2F;&#x2F; Spring 会通过其他方式来处理这些依赖。</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"> </span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span><br><span class="line">    * 之前我们说过，&quot;当前 ApplicationContext 持有一个 BeanFactory&quot;，这里解释了第一行</span><br><span class="line">    * ApplicationContext 继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span><br><span class="line">    * 所以对于这几个，可以赋值为 this，注意 this 是一个 ApplicationContext</span><br><span class="line">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span><br><span class="line">    *&#x2F;</span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span><br><span class="line">   &#x2F;&#x2F; 那么将其添加到 listener 列表中，可以理解成：注册事件监听器</span><br><span class="line">   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Detect a LoadTimeWeaver and prepare for weaving, if found.</span><br><span class="line">   &#x2F;&#x2F; 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span><br><span class="line">   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      &#x2F;&#x2F; Set a temporary ClassLoader for type matching.</span><br><span class="line">      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 从下面几行代码我们可以知道，Spring 往往很 &quot;智能&quot; 就是因为它会帮我们默认注册一些有用的 bean，</span><br><span class="line">    * 我们也可以选择覆盖</span><br><span class="line">    *&#x2F;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 如果没有定义 &quot;environment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 如果没有定义 &quot;systemProperties&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 如果没有定义 &quot;systemEnvironment&quot; 这个 bean，那么 Spring 会 &quot;手动&quot; 注册一个</span><br><span class="line">   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这块代码中，Spring对一些特殊的bean进行了处理</p>
<h3 id="初始化所有的singleton-beans"><a href="#初始化所有的singleton-beans" class="headerlink" title="初始化所有的singleton beans"></a>初始化所有的singleton beans</h3><p> finishBeanFactoryInitialization(beanFactory)会负责初始化所有的singleton beans</p>
<p>后面的描述中会使用初始化或者预初始化来代表这个阶段，主要是Spring需要在这个阶段完成所有的singleton beans的实例化</p>
<p>到目前为止，BeanFactory已经创建完成，并且所有的实现了 BeanFactoryPostProcessor接口的Bean都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到执行了，所有实现了 BeanPostProcessor接口的Bean也都完成了初始化</p>
<p>剩下的就是初始化其他还没有被初始化的singleton beans了，我们都知道它们是单例的，如果没有设置懒加载，那么Spring会在接下来初始化所有的singleton beans</p>
<p>AbstractApplicationContext.java 834</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化剩余的 singleton beans</span><br><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span><br><span class="line">   &#x2F;&#x2F; 什么，看代码这里没有初始化 Bean 啊！</span><br><span class="line">   &#x2F;&#x2F; 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span><br><span class="line">   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Register a default embedded value resolver if no bean post-processor</span><br><span class="line">   &#x2F;&#x2F; (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">   &#x2F;&#x2F; at this point, primarily for resolution in annotation attribute values.</span><br><span class="line">   if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(new StringValueResolver() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public String resolveStringValue(String strVal) &#123;</span><br><span class="line">            return getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 先初始化 LoadTimeWeaverAware 类型的 Bean</span><br><span class="line">   &#x2F;&#x2F; 一般用于织入第三方模块，在 class 文件载入 JVM 的时候动态织入，这里不展开说</span><br><span class="line">   String[] weaverAwareNames &#x3D; beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">   for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Stop using the temporary ClassLoader for type matching.</span><br><span class="line">   beanFactory.setTempClassLoader(null);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span><br><span class="line">   &#x2F;&#x2F; 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 开始初始化剩下的</span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的最后一行往里看，又回到了DefaultListableBeanFactory 这个类了</p>
<h4 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons"></a>preInstantiateSingletons</h4><p>// DefaultListableBeanFactory 728</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">   if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">      this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   List&lt;String&gt; beanNames &#x3D; new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 触发所有的非懒加载的 singleton beans 的初始化操作</span><br><span class="line">   for (String beanName : beanNames) &#123;</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 合并父 Bean 中的配置，注意 &lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;&quot; parent&#x3D;&quot;&quot; &#x2F;&gt; 中的 parent，用的不多吧，</span><br><span class="line">      &#x2F;&#x2F; 考虑到这可能会影响大家的理解，我在附录中解释了一下 &quot;Bean 继承&quot;，请移步</span><br><span class="line">      RootBeanDefinition bd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 非抽象、非懒加载的 singletons。如果配置了 &#39;abstract &#x3D; true&#39;，那是不需要初始化的</span><br><span class="line">      if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">         &#x2F;&#x2F; 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)</span><br><span class="line">         if (isFactoryBean(beanName)) &#123;</span><br><span class="line">            &#x2F;&#x2F; FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急</span><br><span class="line">            final FactoryBean&lt;?&gt; factory &#x3D; (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            &#x2F;&#x2F; 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过</span><br><span class="line">            boolean isEagerInit;</span><br><span class="line">            if (System.getSecurityManager() !&#x3D; null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">               isEagerInit &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public Boolean run() &#123;</span><br><span class="line">                     return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">               isEagerInit &#x3D; (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">            &#125;</span><br><span class="line">            if (isEagerInit) &#123;</span><br><span class="line"> </span><br><span class="line">               getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            &#x2F;&#x2F; 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span><br><span class="line">   &#x2F;&#x2F; 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span><br><span class="line">   for (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance &#x3D; getSingleton(beanName);</span><br><span class="line">      if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">         final SmartInitializingSingleton smartSingleton &#x3D; (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public Object run() &#123;</span><br><span class="line">                  smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                  return null;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，就进入到getBean(beanName)方法了，这个方法经常用来从BeanFactory中获取一个Bean，而初始化的过程也封装到了这个方法里</p>
<h4 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h4><p> // AbstractBeanFactory 196 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getBean(String name) throws BeansException &#123;</span><br><span class="line">   return doGetBean(name, null, null, false);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span><br><span class="line">&#x2F;&#x2F; 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">protected &lt;T&gt; T doGetBean(</span><br><span class="line">      final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">      throws BeansException &#123;</span><br><span class="line">   &#x2F;&#x2F; 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span><br><span class="line">   &#x2F;&#x2F; 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span><br><span class="line">   final String beanName &#x3D; transformedBeanName(name);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 注意跟着这个，这个是返回值</span><br><span class="line">   Object bean; </span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 检查下是不是已经创建过了</span><br><span class="line">   Object sharedInstance &#x3D; getSingleton(beanName);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span><br><span class="line">   &#x2F;&#x2F; 所以 args 其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span><br><span class="line">   if (sharedInstance !&#x3D; null &amp;&amp; args &#x3D;&#x3D; null) &#123;</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">         if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.debug(&quot;...&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span><br><span class="line">      &#x2F;&#x2F; 如果是 FactoryBean 的话，返回它创建的那个实例对象</span><br><span class="line">      &#x2F;&#x2F; (FactoryBean 知识，读者若不清楚请移步附录)</span><br><span class="line">      bean &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   else &#123;</span><br><span class="line">      if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         &#x2F;&#x2F; 当前线程已经创建过了此 beanName 的 prototype 类型的 bean，那么抛异常</span><br><span class="line">         throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 检查一下这个 BeanDefinition 在容器中是否存在</span><br><span class="line">      BeanFactory parentBeanFactory &#x3D; getParentBeanFactory();</span><br><span class="line">      if (parentBeanFactory !&#x3D; null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span><br><span class="line">         String nameToLookup &#x3D; originalBeanName(name);</span><br><span class="line">         if (args !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 返回父容器的查询结果</span><br><span class="line">            return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">            &#x2F;&#x2F; No args -&gt; delegate to standard getBean method.</span><br><span class="line">            return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      if (!typeCheckOnly) &#123;</span><br><span class="line">         &#x2F;&#x2F; typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      &#x2F;*</span><br><span class="line">       * 稍稍总结一下：</span><br><span class="line">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span><br><span class="line">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span><br><span class="line">       *&#x2F;</span><br><span class="line">      try &#123;</span><br><span class="line">         final RootBeanDefinition mbd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 先初始化依赖的所有 Bean，这个很好理解。</span><br><span class="line">         &#x2F;&#x2F; 注意，这里的依赖指的是 depends-on 中定义的依赖</span><br><span class="line">         String[] dependsOn &#x3D; mbd.getDependsOn();</span><br><span class="line">         if (dependsOn !&#x3D; null) &#123;</span><br><span class="line">            for (String dep : dependsOn) &#123;</span><br><span class="line">               &#x2F;&#x2F; 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span><br><span class="line">               if (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               &#x2F;&#x2F; 注册一下依赖关系</span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               &#x2F;&#x2F; 先初始化被依赖项</span><br><span class="line">               getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 创建 singleton 的实例</span><br><span class="line">         if (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance &#x3D; getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public Object getObject() throws BeansException &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                     &#x2F;&#x2F; 执行创建 Bean，详情后面再说</span><br><span class="line">                     return createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  catch (BeansException ex) &#123;</span><br><span class="line">                     destroySingleton(beanName);</span><br><span class="line">                     throw ex;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean &#x3D; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 创建 prototype 的实例</span><br><span class="line">         else if (mbd.isPrototype()) &#123;</span><br><span class="line">            &#x2F;&#x2F; It&#39;s a prototype -&gt; create a new instance.</span><br><span class="line">            Object prototypeInstance &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               &#x2F;&#x2F; 执行创建 Bean</span><br><span class="line">               prototypeInstance &#x3D; createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean &#x3D; getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         &#x2F;&#x2F; 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span><br><span class="line">         else &#123;</span><br><span class="line">            String scopeName &#x3D; mbd.getScope();</span><br><span class="line">            final Scope scope &#x3D; this.scopes.get(scopeName);</span><br><span class="line">            if (scope &#x3D;&#x3D; null) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">               Object scopedInstance &#x3D; scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public Object getObject() throws BeansException &#123;</span><br><span class="line">                     beforePrototypeCreation(beanName);</span><br><span class="line">                     try &#123;</span><br><span class="line">                        &#x2F;&#x2F; 执行创建 Bean</span><br><span class="line">                        return createBean(beanName, mbd, args);</span><br><span class="line">                     &#125;</span><br><span class="line">                     finally &#123;</span><br><span class="line">                        afterPrototypeCreation(beanName);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean &#x3D; getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (IllegalStateException ex) &#123;</span><br><span class="line">               throw new BeanCreationException(beanName,</span><br><span class="line">                     &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +</span><br><span class="line">                     &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         throw ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span><br><span class="line">   if (requiredType !&#x3D; null &amp;&amp; bean !&#x3D; null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         return getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (TypeMismatchException ex) &#123;</span><br><span class="line">         if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来当然是分析createBean方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException;</span><br></pre></td></tr></table></figure>

<p>第三个参数args数组代表创建实例需要的参数，就是给构造方法用的参数，或者是工厂Bean的参数，不过要主要，在初始化阶段，args是null</p>
<p> AbstractAutowireCapableBeanFactory主要为了一下场景，采用@Autowired注解注入属性值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MessageServiceImpl implements MessageService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"> </span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return userService.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;messageService&quot; class&#x3D;&quot;com.javadoop.example.MessageServiceImpl&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p> AbstractAutowireCapableBeanFactory 447 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Central method of this class: creates a bean instance,</span><br><span class="line"> * populates the bean instance, applies post-processors, etc.</span><br><span class="line"> * @see #doCreateBean</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123;</span><br><span class="line">   if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   RootBeanDefinition mbdToUse &#x3D; mbd;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 确保 BeanDefinition 中的 Class 被加载</span><br><span class="line">   Class&lt;?&gt; resolvedClass &#x3D; resolveBeanClass(mbd, beanName);</span><br><span class="line">   if (resolvedClass !&#x3D; null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() !&#x3D; null) &#123;</span><br><span class="line">      mbdToUse &#x3D; new RootBeanDefinition(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method &#x2F;&gt; </span><br><span class="line">   &#x2F;&#x2F; 和 &lt;replaced-method &#x2F;&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。</span><br><span class="line">   &#x2F;&#x2F; 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看</span><br><span class="line">   try &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; 让 BeanPostProcessor 在这一步有机会返回代理，而不是 bean 实例，</span><br><span class="line">      &#x2F;&#x2F; 要彻底了解清楚这个，需要去看 InstantiationAwareBeanPostProcessor 接口，这里就不展开说了</span><br><span class="line">      Object bean &#x3D; resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      if (bean !&#x3D; null) &#123;</span><br><span class="line">         return bean; </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 重头戏，创建 bean</span><br><span class="line">   Object beanInstance &#x3D; doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">   if (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   return beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建Bean"><a href="#创建Bean" class="headerlink" title="创建Bean"></a>创建Bean</h4><p>往里看doCreateBean这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Actually create the specified bean. Pre-creation processing has already happened</span><br><span class="line"> * at this point, e.g. checking &#123;@code postProcessBeforeInstantiation&#125; callbacks.</span><br><span class="line"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span><br><span class="line"> * factory method, and autowiring a constructor.</span><br><span class="line"> * @param beanName the name of the bean</span><br><span class="line"> * @param mbd the merged bean definition for the bean</span><br><span class="line"> * @param args explicit arguments to use for constructor or factory method invocation</span><br><span class="line"> * @return a new instance of the bean</span><br><span class="line"> * @throws BeanCreationException if the bean could not be created</span><br><span class="line"> * @see #instantiateBean</span><br><span class="line"> * @see #instantiateUsingFactoryMethod</span><br><span class="line"> * @see #autowireConstructor</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</span><br><span class="line">      throws BeanCreationException &#123;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Instantiate the bean.</span><br><span class="line">   BeanWrapper instanceWrapper &#x3D; null;</span><br><span class="line">   if (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper &#x3D; this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   if (instanceWrapper &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span><br><span class="line">      instanceWrapper &#x3D; createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我描述成 &quot;bean 实例&quot;</span><br><span class="line">   final Object bean &#x3D; (instanceWrapper !&#x3D; null ? instanceWrapper.getWrappedInstance() : null);</span><br><span class="line">   &#x2F;&#x2F; 类型</span><br><span class="line">   Class&lt;?&gt; beanType &#x3D; (instanceWrapper !&#x3D; null ? instanceWrapper.getWrappedClass() : null);</span><br><span class="line">   mbd.resolvedTargetType &#x3D; beanType;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor</span><br><span class="line">   synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">      if (!mbd.postProcessed) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            &#x2F;&#x2F; MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的</span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  &quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">   &#x2F;&#x2F; even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">   &#x2F;&#x2F; 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧</span><br><span class="line">   boolean earlySingletonExposure &#x3D; (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   if (earlySingletonExposure) &#123;</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +</span><br><span class="line">               &quot;&#39; to allow for resolving potential circular references&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public Object getObject() throws BeansException &#123;</span><br><span class="line">            return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Initialize the bean instance.</span><br><span class="line">   Object exposedObject &#x3D; bean;</span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值</span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      if (exposedObject !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？</span><br><span class="line">         &#x2F;&#x2F; 这里就是处理 bean 初始化完成后的各种回调</span><br><span class="line">         exposedObject &#x3D; initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         throw (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         throw new BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   if (earlySingletonExposure) &#123;</span><br><span class="line">      &#x2F;&#x2F; </span><br><span class="line">      Object earlySingletonReference &#x3D; getSingleton(beanName, false);</span><br><span class="line">      if (earlySingletonReference !&#x3D; null) &#123;</span><br><span class="line">         if (exposedObject &#x3D;&#x3D; bean) &#123;</span><br><span class="line">            exposedObject &#x3D; earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans &#x3D; getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans &#x3D; new LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">            for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                     &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +</span><br><span class="line">                     &quot;wrapped. This means that said other beans do not use the final version of the &quot; +</span><br><span class="line">                     &quot;bean. This is often the result of over-eager type matching - consider using &quot; +</span><br><span class="line">                     &quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; Register bean as disposable.</span><br><span class="line">   try &#123;</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      throw new BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   return exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，已经走完了整个初始化流程，接下来挑doCreateBean方法中的三个细节出来说说，一个是创建Bean实例的createBeanInstance方法,一个是依赖注入的populateBean方法，还有就是回调方法initializeBean</p>
<h5 id="创建Bean实例"><a href="#创建Bean实例" class="headerlink" title="创建Bean实例"></a>创建Bean实例</h5><p>createBeanInstance这个方法的目的就是实例化我们指定的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123;</span><br><span class="line">   &#x2F;&#x2F; 确保已经加载了此 class</span><br><span class="line">   Class&lt;?&gt; beanClass &#x3D; resolveBeanClass(mbd, beanName);</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 校验一下这个类的访问权限</span><br><span class="line">   if (beanClass !&#x3D; null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">      throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">            &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot; + beanClass.getName());</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   if (mbd.getFactoryMethodName() !&#x3D; null)  &#123;</span><br><span class="line">      &#x2F;&#x2F; 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean</span><br><span class="line">      return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 如果不是第一次创建，比如第二次创建 prototype bean。</span><br><span class="line">   &#x2F;&#x2F; 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span><br><span class="line">   boolean resolved &#x3D; false;</span><br><span class="line">   boolean autowireNecessary &#x3D; false;</span><br><span class="line">   if (args &#x3D;&#x3D; null) &#123;</span><br><span class="line">      synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">         if (mbd.resolvedConstructorOrFactoryMethod !&#x3D; null) &#123;</span><br><span class="line">            resolved &#x3D; true;</span><br><span class="line">            autowireNecessary &#x3D; mbd.constructorArgumentsResolved;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   if (resolved) &#123;</span><br><span class="line">      if (autowireNecessary) &#123;</span><br><span class="line">         &#x2F;&#x2F; 构造函数依赖注入</span><br><span class="line">         return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         &#x2F;&#x2F; 无参构造函数</span><br><span class="line">         return instantiateBean(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 判断是否采用有参构造函数</span><br><span class="line">   Constructor&lt;?&gt;[] ctors &#x3D; determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">   if (ctors !&#x3D; null ||</span><br><span class="line">         mbd.getResolvedAutowireMode() &#x3D;&#x3D; RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">      &#x2F;&#x2F; 构造函数依赖注入</span><br><span class="line">      return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 调用无参构造函数</span><br><span class="line">   return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挑个简单的无参构造函数构造实例来看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      Object beanInstance;</span><br><span class="line">      final BeanFactory parent &#x3D; this;</span><br><span class="line">      if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">         beanInstance &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object run() &#123;</span><br><span class="line"> </span><br><span class="line">               return getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         &#x2F;&#x2F; 实例化</span><br><span class="line">         beanInstance &#x3D; getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 包装一下，返回</span><br><span class="line">      BeanWrapper bw &#x3D; new BeanWrapperImpl(beanInstance);</span><br><span class="line">      initBeanWrapper(bw);</span><br><span class="line">      return bw;</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      throw new BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键的地方在于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanInstance &#x3D; getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure>

<p>这里会进行实际的实例化过程</p>
<p>SimpleInstantiationStrategy 59 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span><br><span class="line">   &#x2F;&#x2F; 方法覆写 请参见附录&quot;方法注入&quot;中对 lookup-method 和 replaced-method 的介绍</span><br><span class="line">   if (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">      Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">      synchronized (bd.constructorArgumentLock) &#123;</span><br><span class="line">         constructorToUse &#x3D; (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">         if (constructorToUse &#x3D;&#x3D; null) &#123;</span><br><span class="line">            final Class&lt;?&gt; clazz &#x3D; bd.getBeanClass();</span><br><span class="line">            if (clazz.isInterface()) &#123;</span><br><span class="line">               throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">               if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">                  constructorToUse &#x3D; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">                     @Override</span><br><span class="line">                     public Constructor&lt;?&gt; run() throws Exception &#123;</span><br><span class="line">                        return clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">               else &#123;</span><br><span class="line">                  constructorToUse &#x3D; clazz.getDeclaredConstructor((Class[]) null);</span><br><span class="line">               &#125;</span><br><span class="line">               bd.resolvedConstructorOrFactoryMethod &#x3D; constructorToUse;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">               throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 利用构造方法进行实例化</span><br><span class="line">      return BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了</span><br><span class="line">      return instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就算实例化完成了，下面开始说怎么进行属性注入</p>
<h5 id="bean属性注入"><a href="#bean属性注入" class="headerlink" title="bean属性注入"></a>bean属性注入</h5><p> AbstractAutowireCapableBeanFactory 1203 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class="line">   &#x2F;&#x2F; bean 实例的所有属性都在这里了</span><br><span class="line">   PropertyValues pvs &#x3D; mbd.getPropertyValues();</span><br><span class="line"> </span><br><span class="line">   if (bw &#x3D;&#x3D; null) &#123;</span><br><span class="line">      if (!pvs.isEmpty()) &#123;</span><br><span class="line">         throw new BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         &#x2F;&#x2F; Skip property population phase for null instance.</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   &#x2F;&#x2F; 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，</span><br><span class="line">   &#x2F;&#x2F; InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，</span><br><span class="line">   &#x2F;&#x2F; 我也没找到有实际的使用，所以我们暂且忽略这块吧</span><br><span class="line">   boolean continueWithPropertyPopulation &#x3D; true;</span><br><span class="line">   if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp &#x3D; (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            &#x2F;&#x2F; 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理</span><br><span class="line">            if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation &#x3D; false;</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   if (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   if (mbd.getResolvedAutowireMode() &#x3D;&#x3D; RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">         mbd.getResolvedAutowireMode() &#x3D;&#x3D; RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      MutablePropertyValues newPvs &#x3D; new MutablePropertyValues(pvs);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span><br><span class="line">      if (mbd.getResolvedAutowireMode() &#x3D;&#x3D; RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 通过类型装配。复杂一些</span><br><span class="line">      if (mbd.getResolvedAutowireMode() &#x3D;&#x3D; RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      pvs &#x3D; newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   boolean hasInstAwareBpps &#x3D; hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   boolean needsDepCheck &#x3D; (mbd.getDependencyCheck() !&#x3D; RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"> </span><br><span class="line">   if (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">      PropertyDescriptor[] filteredPds &#x3D; filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      if (hasInstAwareBpps) &#123;</span><br><span class="line">         for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">               InstantiationAwareBeanPostProcessor ibp &#x3D; (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">               &#x2F;&#x2F; 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span><br><span class="line">               &#x2F;&#x2F; 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究</span><br><span class="line">               pvs &#x3D; ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               if (pvs &#x3D;&#x3D; null) &#123;</span><br><span class="line">                  return;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (needsDepCheck) &#123;</span><br><span class="line">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 设置 bean 实例的属性值</span><br><span class="line">   applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h5><p>属性注入完成后，这一步其实就是处理各种回调了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">   if (System.getSecurityManager() !&#x3D; null) &#123;</span><br><span class="line">      AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public Object run() &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            return null;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   Object wrappedBean &#x3D; bean;</span><br><span class="line">   if (mbd &#x3D;&#x3D; null || !mbd.isSynthetic()) &#123;</span><br><span class="line">      &#x2F;&#x2F; BeanPostProcessor 的 postProcessBeforeInitialization 回调</span><br><span class="line">      wrappedBean &#x3D; applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   try &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理 bean 中定义的 init-method，</span><br><span class="line">      &#x2F;&#x2F; 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   catch (Throwable ex) &#123;</span><br><span class="line">      throw new BeanCreationException(</span><br><span class="line">            (mbd !&#x3D; null ? mbd.getResourceDescription() : null),</span><br><span class="line">            beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   if (mbd &#x3D;&#x3D; null || !mbd.isSynthetic()) &#123;</span><br><span class="line">      &#x2F;&#x2F; BeanPostProcessor 的 postProcessAfterInitialization 回调</span><br><span class="line">      wrappedBean &#x3D; applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   return wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> BeanPostProcessor的两个回调都发生在这边，只不过中间处理了init-method</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="id和name"><a href="#id和name" class="headerlink" title="id和name"></a>id和name</h2><p>每个Bean在Spring容器中都有一个唯一的名字beanName和0个或多个别名aliases</p>
<p>我们从Spring容器中获取Bean的时候，可以根据beanName，也可以通过别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.getBean(&quot;beanName or alias&quot;);</span><br></pre></td></tr></table></figure>

<p>在配置bean标签的过程中，我们可以配置id和name</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;messageService&quot; name&#x3D;&quot;m1, m2, m3&quot; class&#x3D;&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>以上配置的结果就是:beanName为messageService,别名有3个，分别为m1,m2,m3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name&#x3D;&quot;m1, m2, m3&quot; class&#x3D;&quot;com.javadoop.example.MessageServiceImpl&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>以上配置的结果就是：beanName为m1,别名有2个，分为为m2,m3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>beanName为： com.javadoop.example.MessageServiceImpl#0 ，别名1个，为 com.javadoop.example.MessageServiceImpl </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;messageService&quot; class&#x3D;&quot;com.javadoop.example.MessageServiceImpl&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>以上的配置结果就是：beanName为messageService，没有别名</p>
<h2 id="配置是否允许bean覆盖，是否允许循环依赖"><a href="#配置是否允许bean覆盖，是否允许循环依赖" class="headerlink" title="配置是否允许bean覆盖，是否允许循环依赖"></a>配置是否允许bean覆盖，是否允许循环依赖</h2><p>默认情况下，allowBeanDefinitionOverriding属性为null，如果在同一配置文件中Bean id或name重复了，会抛出错误，如果不是同一配置文件中，会发生覆盖</p>
<p>有些时候我们希望在系统启动的过程中就严格杜绝发生Bean覆盖，因为万一出现这种情况，会增加排查问题的成本</p>
<p>循环依赖，默认allowCircularReferences也是null</p>
<p>循环依赖和bean覆盖是一起出现的，必然可以在同一个地方一起进行配置  </p>
<p>配置不允许bean覆盖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class NoBeanOverridingContextLoader extends ContextLoader &#123;</span><br><span class="line"> </span><br><span class="line">  @Override</span><br><span class="line">  protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) &#123;</span><br><span class="line">    super.customizeContext(servletContext, applicationContext);</span><br><span class="line">    AbstractRefreshableApplicationContext arac &#x3D; (AbstractRefreshableApplicationContext) applicationContext;</span><br><span class="line">    arac.setAllowBeanDefinitionOverriding(false);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener &#123;</span><br><span class="line"> </span><br><span class="line">  @Override</span><br><span class="line">  protected ContextLoader createContextLoader() &#123;</span><br><span class="line">    return new NoBeanOverridingContextLoader();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;com.javadoop.MyContextLoaderListener&lt;&#x2F;listener-class&gt;  </span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure>

<h2 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h2><p>可以把不同环境的配置分别配置到单独的文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans profile&#x3D;&quot;development&quot;</span><br><span class="line">    xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jdbc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jdbc&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;...&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;jdbc:embedded-database id&#x3D;&quot;dataSource&quot;&gt;</span><br><span class="line">        &lt;jdbc:script location&#x3D;&quot;classpath:com&#x2F;bank&#x2F;config&#x2F;sql&#x2F;schema.sql&quot;&#x2F;&gt;</span><br><span class="line">        &lt;jdbc:script location&#x3D;&quot;classpath:com&#x2F;bank&#x2F;config&#x2F;sql&#x2F;test-data.sql&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;jdbc:embedded-database&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans profile&#x3D;&quot;production&quot;</span><br><span class="line">    xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jee&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jee&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;...&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;jee:jndi-lookup id&#x3D;&quot;dataSource&quot; jndi-name&#x3D;&quot;java:comp&#x2F;env&#x2F;jdbc&#x2F;datasource&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>也可以在一个配置文件中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jdbc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jdbc&quot;</span><br><span class="line">    xmlns:jee&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jee&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;...&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;beans profile&#x3D;&quot;development&quot;&gt;</span><br><span class="line">        &lt;jdbc:embedded-database id&#x3D;&quot;dataSource&quot;&gt;</span><br><span class="line">            &lt;jdbc:script location&#x3D;&quot;classpath:com&#x2F;bank&#x2F;config&#x2F;sql&#x2F;schema.sql&quot;&#x2F;&gt;</span><br><span class="line">            &lt;jdbc:script location&#x3D;&quot;classpath:com&#x2F;bank&#x2F;config&#x2F;sql&#x2F;test-data.sql&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;jdbc:embedded-database&gt;</span><br><span class="line">    &lt;&#x2F;beans&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;beans profile&#x3D;&quot;production&quot;&gt;</span><br><span class="line">        &lt;jee:jndi-lookup id&#x3D;&quot;dataSource&quot; jndi-name&#x3D;&quot;java:comp&#x2F;env&#x2F;jdbc&#x2F;datasource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;beans&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>怎样使用特定的profile呐，Spring启动的过程中，会去寻找spring.profiles.active的属性值，如何配置这个值呐？</p>
<p>Spring会在这几个地方寻找spring.profiles.active的属性值：操作系统环境变量，JVM系统变量，web.xml中定义的参数，JNDI</p>
<p>最简单的方式莫过于在程序启动的时候指定,profile可以激活多个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active &#x3D; &quot;profile1,profile2&quot;</span><br></pre></td></tr></table></figure>

<p>也可以通过代码的形式从Environment中设置profile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(&quot;development&quot;);</span><br><span class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class="line">ctx.refresh(); &#x2F;&#x2F; 重启</span><br></pre></td></tr></table></figure>

<p>如果是springboot的话更简单，一般会创建application.properties等文件，其中application.properties配置各个环境通用的配置，application-{profile}.properties中配置特定环境的配置，然后在启动的时候指定profile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dspring.profiles.active&#x3D;prod -jar JavaDoop.jar</span><br></pre></td></tr></table></figure>

<h2 id="工厂模式生成Bean"><a href="#工厂模式生成Bean" class="headerlink" title="工厂模式生成Bean"></a>工厂模式生成Bean</h2><p>factory-bean和FactoryBean是不同的，前者是说静态工厂或实例工厂，而后者是Spring中的特殊接口，代表一类特殊的Bean</p>
<p>设计模式中，工厂方法模式分静态工厂和实例工厂，来分别看看spring中怎么配置这两个</p>
<p>静态工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;clientService&quot;</span><br><span class="line">    class&#x3D;&quot;examples.ClientService&quot;</span><br><span class="line">    factory-method&#x3D;&quot;createInstance&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ClientService &#123;</span><br><span class="line">    private static ClientService clientService &#x3D; new ClientService();</span><br><span class="line">    private ClientService() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 静态方法</span><br><span class="line">    public static ClientService createInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例工厂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;serviceLocator&quot; class&#x3D;&quot;examples.DefaultServiceLocator&quot;&gt;</span><br><span class="line">    &lt;!-- inject any dependencies required by this locator bean --&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;bean id&#x3D;&quot;clientService&quot;</span><br><span class="line">    factory-bean&#x3D;&quot;serviceLocator&quot;</span><br><span class="line">    factory-method&#x3D;&quot;createClientServiceInstance&quot;&#x2F;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot;</span><br><span class="line">    factory-bean&#x3D;&quot;serviceLocator&quot;</span><br><span class="line">    factory-method&#x3D;&quot;createAccountServiceInstance&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultServiceLocator &#123;</span><br><span class="line"> </span><br><span class="line">    private static ClientService clientService &#x3D; new ClientServiceImpl();</span><br><span class="line"> </span><br><span class="line">    private static AccountService accountService &#x3D; new AccountServiceImpl();</span><br><span class="line"> </span><br><span class="line">    public ClientService createClientServiceInstance() &#123;</span><br><span class="line">        return clientService;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public AccountService createAccountServiceInstance() &#123;</span><br><span class="line">        return accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p>FactoryBean适用于Bean的创建过程比较复杂的场景，比如数据库连接池的创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line">    T getObject() throws Exception;</span><br><span class="line">    Class&lt;T&gt; getObjectType();</span><br><span class="line">    boolean isSingleton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123; </span><br><span class="line">    private Car car ;</span><br><span class="line">    private void setCar(Car car)&#123; this.car &#x3D; car;  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设现在需要创建一个Person的Bean，首先需要一个Car实例。假设Car的实例创建很麻烦，那么可以把创建Car的复杂过程包装起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;&#123;</span><br><span class="line">    private String make; </span><br><span class="line">    private int year ;</span><br><span class="line"> </span><br><span class="line">    public void setMake(String m)&#123; this.make &#x3D;m ; &#125;</span><br><span class="line"> </span><br><span class="line">    public void setYear(int y)&#123; this.year &#x3D; y; &#125;</span><br><span class="line"> </span><br><span class="line">    public Car getObject()&#123; </span><br><span class="line">      &#x2F;&#x2F; 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种</span><br><span class="line">      CarBuilder cb &#x3D; CarBuilder.car();</span><br><span class="line"> </span><br><span class="line">      if(year!&#x3D;0) cb.setYear(this.year);</span><br><span class="line">      if(StringUtils.hasText(this.make)) cb.setMake( this.make ); </span><br><span class="line">      return cb.factory(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Class&lt;Car&gt; getObjectType() &#123; return Car.class ; &#125; </span><br><span class="line"> </span><br><span class="line">    public boolean isSingleton() &#123; return false; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看装配的时候怎么配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class &#x3D; &quot;com.javadoop.MyCarFactoryBean&quot; id &#x3D; &quot;car&quot;&gt;</span><br><span class="line">  &lt;property name &#x3D; &quot;make&quot; value &#x3D;&quot;Honda&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name &#x3D; &quot;year&quot; value &#x3D;&quot;1984&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean class &#x3D; &quot;com.javadoop.Person&quot; id &#x3D; &quot;josh&quot;&gt;</span><br><span class="line">  &lt;property name &#x3D; &quot;car&quot; ref &#x3D; &quot;car&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>id为car的bean其实指定的是一个FactoryBean，不过配置的时候，直接让配置Person的Bean直接依赖于这个FactoryBean就可以了，中间的过程Spring已经封装好了</p>
<p>现在还用xml配置Bean依赖的越来越少了，更多的时候，可能会采用Java config的方式来配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration </span><br><span class="line">public class CarConfiguration &#123; </span><br><span class="line"> </span><br><span class="line">    @Bean </span><br><span class="line">    public MyCarFactoryBean carFactoryBean()&#123; </span><br><span class="line">      MyCarFactoryBean cfb &#x3D; new MyCarFactoryBean();</span><br><span class="line">      cfb.setMake(&quot;Honda&quot;);</span><br><span class="line">      cfb.setYear(1984);</span><br><span class="line">      return cfb;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Bean</span><br><span class="line">    public Person aPerson()&#123; </span><br><span class="line">    Person person &#x3D; new Person();</span><br><span class="line">      &#x2F;&#x2F; 注意这里的不同</span><br><span class="line">    person.setCar(carFactoryBean().getObject());</span><br><span class="line">    return person; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把MyCarFactoryBean看成是一个简单的Bean就可以了</p>
<h2 id="初始化Bean的回调"><a href="#初始化Bean的回调" class="headerlink" title="初始化Bean的回调"></a>初始化Bean的回调</h2><p>有以下四种方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exampleInitBean&quot; class&#x3D;&quot;examples.ExampleBean&quot; init-method&#x3D;&quot;init&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AnotherExampleBean implements InitializingBean &#123;</span><br><span class="line"> </span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        &#x2F;&#x2F; do some initialization work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean(initMethod &#x3D; &quot;init&quot;)</span><br><span class="line">public Foo foo() &#123;</span><br><span class="line">    return new Foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostConstruct</span><br><span class="line">public void init() &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="销毁Bean的回调"><a href="#销毁Bean的回调" class="headerlink" title="销毁Bean的回调"></a>销毁Bean的回调</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exampleInitBean&quot; class&#x3D;&quot;examples.ExampleBean&quot; destroy-method&#x3D;&quot;cleanup&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AnotherExampleBean implements DisposableBean &#123;</span><br><span class="line"> </span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        &#x2F;&#x2F; do some destruction work (like releasing pooled connections)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean(destroyMethod &#x3D; &quot;cleanup&quot;)</span><br><span class="line">public Bar bar() &#123;</span><br><span class="line">    return new Bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PreDestroy</span><br><span class="line">public void cleanup() &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h2><p>用来将前端传过来的参数和后端的controller方法上的参数进行绑定的时候用</p>
<p>像前端传过来的字符串，整数要转换为后端的String,Integer很容器，但是如果controller方法需要的是一个枚举值，或者是Date这些非基础类型值得时候，就可以考虑用ConversionService来进行转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;conversionService&quot;</span><br><span class="line">  class&#x3D;&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;converters&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">      &lt;bean class&#x3D;&quot;com.javadoop.learning.utils.StringToEnumConverterFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;list&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p> ConversionService接口很简单，所以要自定义一个convert得话也很简单</p>
<p>下面再说一个实现这种转换很简单得方式，那就是实现Converter接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public Date convert(String source) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return DateUtils.parseDate(source, &quot;yyyy-MM-dd&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd HH:mm&quot;, &quot;HH:mm:ss&quot;, &quot;HH:mm&quot;);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要注册这个Bean就可以了，这样前端往后端传的时间描述字符串就很容易绑定成Date类型了，不需要其他任何操作</p>
<h2 id="Bean继承"><a href="#Bean继承" class="headerlink" title="Bean继承"></a>Bean继承</h2><p>在初始化Bean的地方，说过这个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RootBeanDefinition bd &#x3D; getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure>

<p>这里涉及到的就是<bean parent>中的parent属性，我们来看看Spring中是用这个来干什么的</bean></p>
<p>这里的继承和Java语法中的继承没有任何关系，不过思路是相同的，child bean会继承parent bean中的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置</p>
<p>Spring中提供了继承自 AbstractBeanDefinition的ChildBeanDefinition来表示child bean</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;inheritedTestBean&quot; abstract&#x3D;&quot;true&quot; class&#x3D;&quot;org.springframework.beans.TestBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;parent&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;bean id&#x3D;&quot;inheritsWithDifferentClass&quot; class&#x3D;&quot;org.springframework.beans.DerivedTestBean&quot;</span><br><span class="line">        parent&#x3D;&quot;inheritedTestBean&quot; init-method&#x3D;&quot;initialize&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;override&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>parent bean设置了abstract=“true”，所以它不会被实例化，child bean继承了parent bean的两个属性，但是对name属性进行了覆写</p>
<p>child bean会继承scope，构造器参数，属性值，init-method，destroy-method等等</p>
<p>parent bean中的abstract=true在这里不是必须的，这个bean的作用就是用来充当模板用的parent bean，此处就必须加上abstract =true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;inheritedTestBeanWithoutClass&quot; abstract&#x3D;&quot;true&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;parent&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h2><p>应用程序中大多数Bean都是singleton的，singleton依赖singleton,或者prototype依赖prototype都很好解决，直接设置属性依赖就可以了</p>
<p>但是如果是singleton依赖prototype呐？这个时候不能用属性依赖，因为如果用属性依赖的话，每次其实拿到的还是第一次初始化时候的bean</p>
<p>一种解决方案就是不要用属性依赖，每次获取依赖的bean的时候从BeanFactory中取</p>
<p>另一种解决方案就是使用Lookup method</p>
<h3 id="lookup-method"><a href="#lookup-method" class="headerlink" title="lookup-method"></a>lookup-method</h3><p>先看一下Spring Reference中提供的一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package fiona.apple;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; no more Spring imports!</span><br><span class="line"> </span><br><span class="line">public abstract class CommandManager &#123;</span><br><span class="line"> </span><br><span class="line">    public Object process(Object commandState) &#123;</span><br><span class="line">        &#x2F;&#x2F; grab a new instance of the appropriate Command interface</span><br><span class="line">        Command command &#x3D; createCommand();</span><br><span class="line">        &#x2F;&#x2F; set the state on the (hopefully brand new) Command instance</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; okay... but where is the implementation of this method?</span><br><span class="line">    protected abstract Command createCommand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xml配置lookup-method</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;myCommand&quot; class&#x3D;&quot;fiona.apple.AsyncCommand&quot; scope&#x3D;&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;!-- inject dependencies here as required --&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;commandManager&quot; class&#x3D;&quot;fiona.apple.CommandManager&quot;&gt;</span><br><span class="line">    &lt;lookup-method name&#x3D;&quot;createCommand&quot; bean&#x3D;&quot;myCommand&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>spring采用CGLIB生成字节码的方式来生成一个子类，我们定义的类不能定义为final class,抽象方法上也不能加final</p>
<p>lookup-method上的配置也可以采用注解来完成，这样就可以不用配置lookup-method了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CommandManager &#123;</span><br><span class="line"> </span><br><span class="line">    public Object process(Object commandState) &#123;</span><br><span class="line">        MyCommand command &#x3D; createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Lookup(&quot;myCommand&quot;)</span><br><span class="line">    protected abstract Command createCommand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然用了注解，要配置注解扫描</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.javadoop&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="replaced-method"><a href="#replaced-method" class="headerlink" title="replaced-method"></a>replaced-method</h3><p>功能就是替换掉bean中的一些方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyValueCalculator &#123;</span><br><span class="line"> </span><br><span class="line">    public String computeValue(String input) &#123;</span><br><span class="line">        &#x2F;&#x2F; some real code...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; some other methods...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法覆写，注意要实现MethodReplacer接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer &#123;</span><br><span class="line"> </span><br><span class="line">    public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F; get the input value, work with it, and return a computed result</span><br><span class="line">        String input &#x3D; (String) args[0];</span><br><span class="line">        ...</span><br><span class="line">        return ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;myValueCalculator&quot; class&#x3D;&quot;x.y.z.MyValueCalculator&quot;&gt;</span><br><span class="line">    &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span><br><span class="line">    &lt;replaced-method name&#x3D;&quot;computeValue&quot; replacer&#x3D;&quot;replacementComputeValue&quot;&gt;</span><br><span class="line">        &lt;arg-type&gt;String&lt;&#x2F;arg-type&gt;</span><br><span class="line">    &lt;&#x2F;replaced-method&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;bean id&#x3D;&quot;replacementComputeValue&quot; class&#x3D;&quot;a.b.c.ReplacementComputeValue&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>arg-type明显不是必须的，除非存在方法重载，这样必须通过类型参数列表来判断这里要覆盖哪个方法</p>
<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line"> </span><br><span class="line">   Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line"> </span><br><span class="line">   Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bean在初始化之前会执行postProcessBeforeInitialization这个方法，初始化完成之后会执行postProcessAfterInitialization这个方法</p>
<p>除了自定义的BeanPostProcessor实现外，Spring容器在启动时自动给我们也加了几个，如在获取BeanFactory的obtainFactory()方法结束后的prepareBeanFactory(factory),Spring往容器中添加了这两个BeanPostProcessor: ApplicationContextAwareProcessor、ApplicationListenerDetector </p>
<p>回到这个接口本身，第一个方法接受的第一个参数是bean实例，第二个参数是bean的名字，重点在返回值将会作为新的bean实例，所以，没事的话这里不能随便返回一个null</p>
<p>这里可以对一些我们想要修饰的bean实例做一些事情，但是对于spring框架来说，它会决定是不是要在这个方法中返回bean实例的代理，这样就有更大的想象空间了</p>
<p>bean实例化完成，属性注入完成之后，会执行回调方法，首先会回调几个实现了Aware接口的bean，然后就开始回调BeanPostProcessor的 postProcessBeforeInitialization方法，之后是回调init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法 </p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">李上</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/11/spring-source-code/">http://yoursite.com/2020/05/11/spring-source-code/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">定不辱使命</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/13/dubbo/"><img class="prev_cover lazyload" data-src="/img/dubbo.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Dubbo入门学习</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/09/mysql/"><img class="next_cover lazyload" data-src="/img/mysql.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL学习笔记</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 李上</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>