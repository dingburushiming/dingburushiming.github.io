<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM学习笔记 | 定不辱使命</title><meta name="description" content="JVM学习笔记"><meta name="author" content="李上"><meta name="copyright" content="李上"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM学习笔记"><meta name="twitter:description" content="JVM学习笔记"><meta name="twitter:image" content="http://yoursite.com/img/jvm.png"><meta property="og:type" content="article"><meta property="og:title" content="JVM学习笔记"><meta property="og:url" content="http://yoursite.com/2020/05/18/jvm/"><meta property="og:site_name" content="定不辱使命"><meta property="og:description" content="JVM学习笔记"><meta property="og:image" content="http://yoursite.com/img/jvm.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/05/18/jvm/"><link rel="prev" title="Netty学习笔记" href="http://yoursite.com/2020/05/22/netty/"><link rel="next" title="Dubbo入门学习" href="http://yoursite.com/2020/05/13/dubbo/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#类加载子系统"><span class="toc-number">1.</span> <span class="toc-text">类加载子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类的加载过程"><span class="toc-number">1.1.</span> <span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载"><span class="toc-number">1.1.1.</span> <span class="toc-text">加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#将-java文件编译成-class文件"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">将.java文件编译成.class文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载-class文件的方式"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">加载.class文件的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链接过程"><span class="toc-number">1.1.2.</span> <span class="toc-text">链接过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#验证"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#准备"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解析"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-number">1.1.3.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#init方法"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">init方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clinit方法"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">clinit方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java文件"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">.java文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class文件"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">.class文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jclasslib中的clinit"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">.jclasslib中的clinit</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类加载器的分类"><span class="toc-number">1.2.</span> <span class="toc-text">类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引导类加载器-启动类加载器，Bootstrap"><span class="toc-number">1.2.1.</span> <span class="toc-text">引导类加载器(启动类加载器，Bootstrap)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展类加载器-Extension"><span class="toc-number">1.2.2.</span> <span class="toc-text">扩展类加载器(Extension)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用程序类加载器-系统类加载器，AppClassLoader"><span class="toc-number">1.2.3.</span> <span class="toc-text">应用程序类加载器(系统类加载器，AppClassLoader)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义类加载器"><span class="toc-number">1.2.4.</span> <span class="toc-text">自定义类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义类加载器的目的"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">自定义类加载器的目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现步骤"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">实现步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader的相关方法"><span class="toc-number">1.3.</span> <span class="toc-text">ClassLoader的相关方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双亲委派机制"><span class="toc-number">1.4.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">1.4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码"><span class="toc-number">1.4.2.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#委派机制流程图"><span class="toc-number">1.4.3.</span> <span class="toc-text">委派机制流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">1.4.4.</span> <span class="toc-text">作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#沙箱安全机制"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">沙箱安全机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">1.5.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java程序对类的使用方式分为-主动使用和被动使用"><span class="toc-number">1.5.1.</span> <span class="toc-text">Java程序对类的使用方式分为:主动使用和被动使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主动使用"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">主动使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运行时数据区-内存"><span class="toc-number">2.</span> <span class="toc-text">运行时数据区(内存)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#作用-1"><span class="toc-number">2.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个关于pc寄存器的列子"><span class="toc-number">2.2.</span> <span class="toc-text">一个关于pc寄存器的列子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见问题"><span class="toc-number">2.3.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？"><span class="toc-number">2.3.1.</span> <span class="toc-text">使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pc寄存器为什么被设置为线程私有的？"><span class="toc-number">2.3.2.</span> <span class="toc-text">pc寄存器为什么被设置为线程私有的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu时间片"><span class="toc-number">2.4.</span> <span class="toc-text">cpu时间片</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#虚拟机栈"><span class="toc-number">3.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机栈概述"><span class="toc-number">3.1.</span> <span class="toc-text">虚拟机栈概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#出现背景"><span class="toc-number">3.1.1.</span> <span class="toc-text">出现背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java虚拟机栈是什么？"><span class="toc-number">3.1.2.</span> <span class="toc-text">Java虚拟机栈是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈的特点"><span class="toc-number">3.1.3.</span> <span class="toc-text">栈的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈异常"><span class="toc-number">3.1.4.</span> <span class="toc-text">栈异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StackOverflowError"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">StackOverflowError</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutOfMemoryError"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">OutOfMemoryError</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置栈大小的方法"><span class="toc-number">3.1.5.</span> <span class="toc-text">设置栈大小的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈的存储单位"><span class="toc-number">3.2.</span> <span class="toc-text">栈的存储单位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#栈帧的内部结构"><span class="toc-number">3.2.1.</span> <span class="toc-text">栈帧的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#局部变量表-本地变量表，局部变量数组"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">局部变量表(本地变量表，局部变量数组)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字节码的内部方法"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">字节码的内部方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量槽Solt"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">变量槽Solt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量的分类"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">变量的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#按照类型分"><span class="toc-number">3.2.1.4.1.</span> <span class="toc-text">按照类型分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#按照在类中声明的位置分"><span class="toc-number">3.2.1.4.2.</span> <span class="toc-text">按照在类中声明的位置分</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量"><span class="toc-number">3.2.1.4.2.1.</span> <span class="toc-text">成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#局部变量：在使用前，必须进行显示赋值，否则，编译不通过"><span class="toc-number">3.2.1.4.2.2.</span> <span class="toc-text">局部变量：在使用前，必须进行显示赋值，否则，编译不通过</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作数栈"><span class="toc-number">3.2.1.5.</span> <span class="toc-text">操作数栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈顶缓存技术"><span class="toc-number">3.2.2.</span> <span class="toc-text">栈顶缓存技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态链接-指向运行时常量池的方法引用"><span class="toc-number">3.2.3.</span> <span class="toc-text">动态链接(指向运行时常量池的方法引用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法返回地址"><span class="toc-number">3.2.4.</span> <span class="toc-text">方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#本地方法栈"><span class="toc-number">3.2.5.</span> <span class="toc-text">本地方法栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#本地方法接口"><span class="toc-number">4.</span> <span class="toc-text">本地方法接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要使用Native-Method"><span class="toc-number">4.0.1.</span> <span class="toc-text">为什么要使用Native Method</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#与其他语言交互"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">与其他语言交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与操作系统交互"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">与操作系统交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提高执行效率"><span class="toc-number">4.0.1.3.</span> <span class="toc-text">提高执行效率</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆"><span class="toc-number">5.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TLAB"><span class="toc-number">5.0.1.</span> <span class="toc-text">TLAB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存结构"><span class="toc-number">5.1.</span> <span class="toc-text">内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆空间大小的设置和查看"><span class="toc-number">5.2.</span> <span class="toc-text">堆空间大小的设置和查看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOM-OutOfMemory"><span class="toc-number">5.3.</span> <span class="toc-text">OOM(OutOfMemory)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#年轻代与老年代"><span class="toc-number">5.4.</span> <span class="toc-text">年轻代与老年代</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置年轻代和老年代在堆结构中的占比"><span class="toc-number">5.4.1.</span> <span class="toc-text">配置年轻代和老年代在堆结构中的占比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置Eden区，两个Survivor的占比"><span class="toc-number">5.4.2.</span> <span class="toc-text">配置Eden区，两个Survivor的占比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置年轻代的大小"><span class="toc-number">5.4.3.</span> <span class="toc-text">配置年轻代的大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图解对象分配过程"><span class="toc-number">5.5.</span> <span class="toc-text">图解对象分配过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存分配策略"><span class="toc-number">5.5.1.</span> <span class="toc-text">内存分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YGC-Minor-GC"><span class="toc-number">5.5.2.</span> <span class="toc-text">YGC&#x2F;Minor GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Major-GC"><span class="toc-number">5.5.3.</span> <span class="toc-text">Major GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full-GC"><span class="toc-number">5.5.4.</span> <span class="toc-text">Full GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC"><span class="toc-number">5.6.</span> <span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#部分收集-不是完整收集整个Java堆的垃圾收集"><span class="toc-number">5.6.1.</span> <span class="toc-text">部分收集:不是完整收集整个Java堆的垃圾收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#整堆收集-Full-GC-收集整个Java堆和方法区的垃圾收集"><span class="toc-number">5.6.2.</span> <span class="toc-text">整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC日志分析"><span class="toc-number">5.7.</span> <span class="toc-text">GC日志分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆的参数设置"><span class="toc-number">5.8.</span> <span class="toc-text">堆的参数设置</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/jvm.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">定不辱使命</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">JVM学习笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-18 16:16:04"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-18</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-07 01:59:24"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-07</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/004.png"  alt="jvm"></p>
<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件中有特定的文件标识，加载的类信息存放在方法区的内存空间</p>
<p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine执行引擎决定</p>
<p>方法区除了存放被加载类的类信息，还会包含字符串，字面量，数字常量，运行时常量池信息</p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/001.png"  alt="jvm"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><h4 id="将-java文件编译成-class文件"><a href="#将-java文件编译成-class文件" class="headerlink" title="将.java文件编译成.class文件"></a>将.java文件编译成.class文件</h4><p>1.通过一个类的全限定名获取定义此类的二进制字节流</p>
<p>2.将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</p>
<p>3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<h4 id="加载-class文件的方式"><a href="#加载-class文件的方式" class="headerlink" title="加载.class文件的方式"></a>加载.class文件的方式</h4><p>1.从本地文件中直接加载</p>
<p>2.通过网络获取，例如web applet</p>
<p>3.从zip压缩包中读取，例如jar,war包</p>
<p>4.运行时计算生成，例如动态代理技术</p>
<p>5.由其他文件生成，例如jsp应用</p>
<p>6.从专有数据库中提取.class文件</p>
<p>7.从加密文件中获取，典型的防止Class文件被反编译的保护措施</p>
<h3 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</p>
<p>主要包括四种验证：文件格式，元数据，字节码，符号引用验证</p>
<p>.class文件的开头都是cafe babe</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为类变量分配内存并且设置该类变量的默认初始值,具体赋值在初始化阶段</p>
<p>整形：0</p>
<p>浮点型：0.0</p>
<p>Char: /u0000</p>
<p>Boolean:false</p>
<p>String:null</p>
<p>final修饰的static是常量，在编译的时候就会分配数值，准备阶段会显式初始化</p>
<p>不会为实例变量(对象)分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析操作往往会在JVM实初始化之后再执行</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h4><p>init是实例对象的构造器方法，用于构造类对象</p>
<h4 id="clinit方法"><a href="#clinit方法" class="headerlink" title="clinit方法"></a>clinit方法</h4><p>clinit是类的初始化方法，在JVM第一次加载class文件时调用</p>
<p>如果没有静态代码块，静态变量则没有clinit方法</p>
<p>初始化过程就是执行类构造器方法<clinit>的过程，该方法由javac编译器自动执行</clinit></p>
<p><clinit>不需要定义，由javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</clinit></p>
<p>构造器方法中的指令按语句在源文件中出现的顺序执行</p>
<p>如果一个类有父类，JVM会保证子类的<clinit>执行前，父类的<clinit>已经执行完毕</clinit></clinit></p>
<p>虚拟机必须保证一个类的的<clinit>方法在多线程下被同步加锁</clinit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当一个线程在初始化一个类时，其他线程无法初始化该类</span><br><span class="line">public class DeadThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable r &#x3D; () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;开始&quot;);</span><br><span class="line">            DeadThread dead &#x3D; new DeadThread();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 &#x3D; new Thread(r,&quot;线程1&quot;);</span><br><span class="line">        Thread t2 &#x3D; new Thread(r,&quot;线程2&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DeadThread&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        if(true)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;初始化当前类&quot;);</span><br><span class="line">            while(true)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java文件"><a href="#java文件" class="headerlink" title=".java文件"></a>.java文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ClassInit &#123;</span><br><span class="line">    private static int num &#x3D; 1;</span><br><span class="line">    static &#123;</span><br><span class="line">        num&#x3D;2;</span><br><span class="line">        number&#x3D;20;</span><br><span class="line">    &#125;</span><br><span class="line">    private static int number &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="class文件"><a href="#class文件" class="headerlink" title=".class文件"></a>.class文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ClassInit &#123;</span><br><span class="line">    private static int num &#x3D; 1;</span><br><span class="line">    private static int number;</span><br><span class="line"></span><br><span class="line">    public ClassInit() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        num &#x3D; 2;</span><br><span class="line">        number &#x3D; 20;</span><br><span class="line">        number &#x3D; 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="jclasslib中的clinit"><a href="#jclasslib中的clinit" class="headerlink" title=".jclasslib中的clinit"></a>.jclasslib中的clinit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0 iconst_1</span><br><span class="line"> 1 putstatic #3 &lt;ClassInit.num&gt;</span><br><span class="line"> 4 iconst_2</span><br><span class="line"> 5 putstatic #3 &lt;ClassInit.num&gt;</span><br><span class="line"> 8 bipush 20</span><br><span class="line">10 putstatic #5 &lt;ClassInit.number&gt;</span><br><span class="line">13 bipush 10</span><br><span class="line">15 putstatic #5 &lt;ClassInit.number&gt;</span><br><span class="line">18 return</span><br></pre></td></tr></table></figure>

<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/001.png"  alt="jvm"></p>
<p>用户自定义类默认使用系统类加载器</p>
<p>Java核心类库都是使用引导类加载器进行加载的</p>
<p>引导类加载器是无法直接获取到的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取系统类加载器</span><br><span class="line">ClassLoader systemClassLoader &#x3D; ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取其上层：扩展类加载器</span><br><span class="line">ClassLoader extClassLoader &#x3D; systemClassLoader.getParent();</span><br><span class="line">System.out.println(extClassLoader);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取其上层：获取不到引导类加载器，打印为null</span><br><span class="line">ClassLoader bootstrapClassLoader &#x3D; extClassLoader.getParent();</span><br><span class="line">System.out.println(bootstrapClassLoader);&#x2F;&#x2F;null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对于用户自定义类来说：默认使用系统类加载器进行加载</span><br><span class="line">ClassLoader classLoader &#x3D; ClassLoaderTest.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span><br><span class="line">ClassLoader classLoader1 &#x3D; String.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader1);&#x2F;&#x2F;null</span><br></pre></td></tr></table></figure>

<h3 id="引导类加载器-启动类加载器，Bootstrap"><a href="#引导类加载器-启动类加载器，Bootstrap" class="headerlink" title="引导类加载器(启动类加载器，Bootstrap)"></a>引导类加载器(启动类加载器，Bootstrap)</h3><p>使用C/C++语言实现的，嵌套在JVM内部</p>
<p> 用于加载Java的核心类(JAVA_HOME/jre/lib/rt.jar,resources.jar,sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;**********启动类加载器**************&quot;);</span><br><span class="line">&#x2F;&#x2F;获取BootstrapClassLoader能够加载的api的路径</span><br><span class="line">URL[] urLs &#x3D; sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"> for (URL element : urLs) &#123;</span><br><span class="line">      System.out.println(element.toExternalForm());</span><br><span class="line">&#125;</span><br><span class="line">---------------------------</span><br><span class="line">输出结果</span><br><span class="line">**********启动类加载器**************</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;resources.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;rt.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;sunrsasign.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;jsse.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;jce.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;charsets.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;lib&#x2F;jfr.jar</span><br><span class="line">file:&#x2F;C:&#x2F;Program%20Files&#x2F;Java&#x2F;jdk1.8.0_171&#x2F;jre&#x2F;classes</span><br><span class="line">file:&#x2F;D:&#x2F;idea&#x2F;idea_install&#x2F;lib&#x2F;rt&#x2F;debugger-agent-storage.jar</span><br></pre></td></tr></table></figure>

<p> 并不继承java.lang.ClassLoader,没有父加载器</p>
<p>加载扩展类和应用程序类加载器，并指定为它们的父类加载器</p>
<p>出于安全考虑，Bootstrap启动类加载器只加载包名为java,javax,sun等开头的类</p>
<h3 id="扩展类加载器-Extension"><a href="#扩展类加载器-Extension" class="headerlink" title="扩展类加载器(Extension)"></a>扩展类加载器(Extension)</h3><p> Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</p>
<p>派生于ClassLoader类</p>
<p>父类加载器为启动类加载器</p>
<p> 从java.ext,dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库，如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;***********扩展类加载器*************&quot;);</span><br><span class="line">String extDirs &#x3D; System.getProperty(&quot;java.ext.dirs&quot;);</span><br><span class="line">for (String path : extDirs.split(&quot;;&quot;)) &#123;</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line">---------------------------</span><br><span class="line">输出结果</span><br><span class="line">***********扩展类加载器*************</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_171\jre\lib\ext</span><br><span class="line">C:\WINDOWS\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure>

<h3 id="应用程序类加载器-系统类加载器，AppClassLoader"><a href="#应用程序类加载器-系统类加载器，AppClassLoader" class="headerlink" title="应用程序类加载器(系统类加载器，AppClassLoader)"></a>应用程序类加载器(系统类加载器，AppClassLoader)</h3><p>java语言编写，由sun.misc.Launcher$AppClassLoader实现</p>
<p>派生于ClassLoader类，父类加载器为扩展类加载器</p>
<p>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</p>
<p>程序中默认的类加载器，Java应用的类都是由它来完成加载</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><h4 id="自定义类加载器的目的"><a href="#自定义类加载器的目的" class="headerlink" title="自定义类加载器的目的"></a>自定义类加载器的目的</h4><ol>
<li>隔离加载类</li>
<li>修改类加载方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ol>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>继承抽象类java.lang.ClassLoader类</li>
<li>jdk1.2之前重写loadClass(),jdk1.2之后建议把自定义类加载逻辑写在findClass()方法中</li>
<li>如果没有太过于复杂的需求，可以直接继承URLClassLoader类，避免编写findClass方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] result &#x3D; getClassFromCustomPath(name);</span><br><span class="line">            if(result &#x3D;&#x3D; null)&#123;</span><br><span class="line">                throw new FileNotFoundException();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return defineClass(name,result,0,result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] getClassFromCustomPath(String name)&#123;</span><br><span class="line">        &#x2F;&#x2F;从自定义路径中加载指定类:细节略</span><br><span class="line">        &#x2F;&#x2F;如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CustomClassLoader customClassLoader &#x3D; new CustomClassLoader();</span><br><span class="line">        try &#123;</span><br><span class="line">            Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;One&quot;,true,customClassLoader);</span><br><span class="line">            Object obj &#x3D; clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClassLoader的相关方法"><a href="#ClassLoader的相关方法" class="headerlink" title="ClassLoader的相关方法"></a>ClassLoader的相关方法</h2><p> 引导类加载器是C/C++编写，其余是由Java编写，这也是一种类加载器分类方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.引导类加载器获取不到</span><br><span class="line">ClassLoader classLoader &#x3D; Class.forName(&quot;java.lang.String&quot;).getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line">&#x2F;&#x2F;2.系统类加载器</span><br><span class="line">ClassLoader classLoader1 &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">System.out.println(classLoader1);</span><br><span class="line">&#x2F;&#x2F;3.扩展类加载器</span><br><span class="line">ClassLoader classLoader2 &#x3D; ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">System.out.println(classLoader2);</span><br></pre></td></tr></table></figure>

<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</p>
<p>如果父类的加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</p>
<p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码</span><br><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">            throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 首先检查这个classsh是否已经加载过了</span><br><span class="line">            Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                long t0 &#x3D; System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; c&#x3D;&#x3D;null表示没有加载，如果有父类的加载器则让父类加载器加载</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果父类的加载器为空 则说明递归到bootStrapClassloader了</span><br><span class="line">                        &#x2F;&#x2F;bootStrapClassloader比较特殊无法通过get获取</span><br><span class="line">                        c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;&#125;</span><br><span class="line">                if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果bootstrapClassLoader 仍然没有加载过，则递归回来，尝试自己去加载class</span><br><span class="line">                    long t1 &#x3D; System.nanoTime();</span><br><span class="line">                    c &#x3D; findClass(name);</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="委派机制流程图"><a href="#委派机制流程图" class="headerlink" title="委派机制流程图"></a>委派机制流程图</h3><p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/003.png"  alt="jvm"></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>防止重复加载同一个.class,通过委托去上面问一问，加载过了就不用再加载一遍，保证数据安全。</p>
<p>保证核心.class不会被篡改。通过委托方式不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。</p>
<h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><p>将Java核心api置于沙箱中，不被外界代码所篡改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;&#x2F;自定义的重名api不会被顶层启动类加载器加载</span><br><span class="line">2.&#x2F;&#x2F;自定义的包名也被允许，例如java.lang,在该表下的类运行会报SecurityException</span><br><span class="line">package java.lang;</span><br><span class="line">public class String &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;我是自定义的String类的静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;错误: 在类 java.lang.String 中找不到 main 方法</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello,String&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3.执行main方法会报错，因为启动类加载器会去调用真正的Java核心api，而String类是没有主函数的。</span><br><span class="line">报错信息：</span><br><span class="line">错误:在类java.lang.String中找不到main方法, 请将main方法定义为:</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>JVM中表示两个class对象是否为同一个类又两个必要条件：</p>
<ol>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的ClassLoader必须相同</li>
</ol>
<p>JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的</p>
<p>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</p>
<p>当解析一个类型到另外一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</p>
<h3 id="Java程序对类的使用方式分为-主动使用和被动使用"><a href="#Java程序对类的使用方式分为-主动使用和被动使用" class="headerlink" title="Java程序对类的使用方式分为:主动使用和被动使用"></a>Java程序对类的使用方式分为:主动使用和被动使用</h3><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射(Class.forName(“com.ls.test”))</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持</li>
</ol>
<p>除了以上七种情况，其他使用Java类的方式都被看做是对类的被动使用，都不会导致类的初始化</p>
<h1 id="运行时数据区-内存"><a href="#运行时数据区-内存" class="headerlink" title="运行时数据区(内存)"></a>运行时数据区(内存)</h1><p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/005.png"  alt="jvm"></p>
<p>运行时数据区中线程独有的：程序计数器，栈，本地栈</p>
<p>运行时数据区中线程间共享的：堆，堆外内存(永久代或元空间，代码缓存)</p>
<p>对JVM的优化主要集中在堆区和方法区(堆外内存)</p>
<p>PC寄存器(Program Counter Register程序计数器)</p>
<p>pc寄存器是一个软件层面上的应用，不同于CPU寄存器</p>
<p>每一个线程都有一个pc寄存器，是线程私有的，生命周期与线程保持一致</p>
<p>是一个小到可以忽略不记且运行速度最快的内存区域</p>
<p>任何时间一个线程(当前方法)都只有一个方法在执行，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址。如果执行native方法。则是未定义值(undefined)</p>
<p>程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成</p>
<p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p>
<p>pc寄存器是唯一一个Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域,也没有GC垃圾回收</p>
<p>GC( Garbage Collection ):垃圾回收机制，OOM( Out Of Memory ):内存溢出异常</p>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>pc寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/006.png"  alt="jvm"></p>
<h2 id="一个关于pc寄存器的列子"><a href="#一个关于pc寄存器的列子" class="headerlink" title="一个关于pc寄存器的列子"></a>一个关于pc寄存器的列子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 10;</span><br><span class="line">int j &#x3D; 20;</span><br><span class="line">int k &#x3D; i + j;</span><br></pre></td></tr></table></figure>

<p>通过反编译javap -verbose PCRegisterTest.class，得到结果如下</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/007.png"  alt="jvm"></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？"><a href="#使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？" class="headerlink" title="使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？"></a>使用pc寄存器存储字节码指令地址有什么用呐？为什么使用pc寄存器记录当前线程的执行地址呐？</h3><p>因为cpu需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始接着执行</p>
<p>JVM的字节码解释器就需要通过改变pc寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<h3 id="pc寄存器为什么被设置为线程私有的？"><a href="#pc寄存器为什么被设置为线程私有的？" class="headerlink" title="pc寄存器为什么被设置为线程私有的？"></a>pc寄存器为什么被设置为线程私有的？</h3><p>如果不是私有而是共享的，那么当多线程出现同步问题的时候，计数器的值会乱掉</p>
<h2 id="cpu时间片"><a href="#cpu时间片" class="headerlink" title="cpu时间片"></a>cpu时间片</h2><p>并行：同时执行多个线程</p>
<p>并发：一个cpu内核快速切换执行线程，实际上是串行的，但是给人的效果像是并行的</p>
<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h2><p>栈是运行时的单位，而堆是存储的单位</p>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据(菜方)</p>
<p>堆解决的是数据存储的问题，即数据怎么放，放在哪里(食材)</p>
<h3 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景"></a>出现背景</h3><p>由于跨平台性的设计，不同平台cpu架构是不同的，不能设计为基于寄存器的，Java的指令都是根据栈来设计的</p>
<p>虚拟机栈的优点是跨平台，指令集小，编译器容器实现，缺点是性能下降，实现同样的功能需要更多的指令</p>
<h3 id="Java虚拟机栈是什么？"><a href="#Java虚拟机栈是什么？" class="headerlink" title="Java虚拟机栈是什么？"></a>Java虚拟机栈是什么？</h3><p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame),对应着一次次的Java方法调用</p>
<p>虚拟机栈是线程私有的，什么周期和线程一致</p>
<p>主管Java程序的运行，它保存方法的局部变量，部分结果，并参与方法的调用和返回 </p>
<h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</p>
<p>虚拟机栈只存在OOM,不存在GC</p>
<p>JVM直接对Java栈的操作只有两个：</p>
<p>1.每个方法执行，伴随着进栈</p>
<p>2.执行结束后的出栈</p>
<h3 id="栈异常"><a href="#栈异常" class="headerlink" title="栈异常"></a>栈异常</h3><p>Java虚拟机允许Java栈的大小是动态的或者是固定不变的</p>
<h4 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h4><p>对于固定容量大小的Java虚拟机栈，如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，就会抛出StackOverflowError异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        main(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h4><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那么就会抛出一个OutOfMemoryError异常</p>
<h3 id="设置栈大小的方法"><a href="#设置栈大小的方法" class="headerlink" title="设置栈大小的方法"></a>设置栈大小的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;判断当前栈的大小</span><br><span class="line">private static int count &#x3D; 1;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过-Xss设置栈的大小，例如vm options:-Xss 256k</p>
<h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据存储在栈帧中，栈帧是栈的基本单位</p>
<p>在线程上运行的每个方法都对应一个栈帧，一个方法执行就有一个栈帧入栈，一个方法结束就有一个栈帧出栈</p>
<p>栈帧是一个内存区域，是一个数据集，维系着方法执行过程中的各种数据信息</p>
<p>如果当前方法被其他方法调用了，方法返回之际，当前栈帧会传回此方法的执行结果给调用自己的方法。接着当前栈帧就会出栈，待用当前栈帧方法的栈帧就会成为当前栈帧</p>
<p>Java方法有两种返回函数的方法，一种是正常的函数返回，使用return指令；另外一种是抛出异常。两种返回方式都会导致栈帧被弹出。出现异常不会导致JVM终止，只会将异常不断上抛，直到有方法捕获处理，如果到主函数都没有处理该异常，就会导致虚拟机异常终止。</p>
<p>进栈就会执行方法，方法结束就会出栈，先进后出，在栈顶的栈帧先执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        test test &#x3D; new test();</span><br><span class="line">        test.method1();</span><br><span class="line">        System.out.println(&quot;main()正常结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        System.out.println(&quot;method1()开始执行...&quot;);</span><br><span class="line">        method2();</span><br><span class="line">        System.out.println(&quot;method1()执行结束...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;method2()开始执行...&quot;);</span><br><span class="line">        method3();</span><br><span class="line">        System.out.println(&quot;method2()即将结束...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method3() &#123;</span><br><span class="line">        System.out.println(&quot;method3()开始执行...&quot;);</span><br><span class="line">        System.out.println(&quot;method3()即将结束...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">----------------运行结果------------------------------</span><br><span class="line">method1()开始执行...</span><br><span class="line">method2()开始执行...</span><br><span class="line">method3()开始执行...</span><br><span class="line">method3()即将结束...</span><br><span class="line">method2()即将结束...</span><br><span class="line">method1()执行结束...</span><br><span class="line">main()正常结束</span><br></pre></td></tr></table></figure>

<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/017.png"  alt="jvm"></p>
<h4 id="局部变量表-本地变量表，局部变量数组"><a href="#局部变量表-本地变量表，局部变量数组" class="headerlink" title="局部变量表(本地变量表，局部变量数组)"></a>局部变量表(本地变量表，局部变量数组)</h4><p>定义为一个数字数组(Java八种数值类型都可以用数字表示)，主要用于存储方法参数和定义在方法体内的局部变量</p>
<p>局部变量表建立在线程栈上，是线程的私有数据，不存在数据安全问题</p>
<p>局部变量表所需的容量大小是在编译期确定下来的，在方法运行期间不会改变局部变量表的大小</p>
<p>局部变量表中的变量只在当前方法调用中有效，当方法调用结束以后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<p>局部变量表存储的是堆空间中的变量的地址，在方法执行时，虚拟机使用局部变量表完成方法的传递</p>
<p>局部变量表中的变量也是重要的的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</p>
<h4 id="字节码的内部方法"><a href="#字节码的内部方法" class="headerlink" title="字节码的内部方法"></a>字节码的内部方法</h4><p>一个静态主函数方法</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/008.png"  alt="jvm"></p>
<p>该主函数对应的字节码方法</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/009.png"  alt="jvm"></p>
<p>主函数相关信息(方法名，参数返回值，修饰符信息)</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/010.png"  alt="jvm"></p>
<p>字节码解析信息</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/011.png"  alt="jvm"></p>
<p>方法参数数量，字节码长度</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/012.png"  alt="jvm"></p>
<p>LineNumberTable存储字节码和.Java文件信息的对应位置，Start PC表示变量在字节码中的位置，Line Number表示变量在.Java文件中的位置</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/013.png"  alt="jvm"></p>
<p>LocalVariableTable存储变量在字节码中的信息，Name变量名，Length是变量作用域长度，Start PC是变量作用域生效位置</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/014.png"  alt="jvm"></p>
<h4 id="变量槽Solt"><a href="#变量槽Solt" class="headerlink" title="变量槽Solt"></a>变量槽Solt</h4><p>局部变量基础的存储单元就是Solt槽</p>
<p>局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference),returnAddress类型的变量</p>
<p>在局部变量表中，32位以内的类型只占一个solt(包括returnAddress类型)，64位的类型(long,double)占用两个solt</p>
<p>byte,short,char在存储前被转换为int，boolean也被转换为int,0表示false,非0表示true</p>
<p> JVM会为局部变量表中的每一个solt都分配一个访问索引，通过这些索引即可成功访问到局部变量表中指定的局部变量值</p>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个solt上</p>
<p>如果需要访问局部变量表中一个bit的局部变量值式，只需要使用前一个索引即可</p>
<p>如果当前栈帧是由构造函数或者实例方法创建的(静态方法不在此列)，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序排列，静态方法是不允许通过this方法调用变量的，this也是一个变量，每一个非静态方法中都有this变量</p>
<p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会重复过期局部变量的槽位，从而达到节省资源的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public void test4() &#123;</span><br><span class="line">        int a &#x3D; 0;</span><br><span class="line">        &#123;</span><br><span class="line">            int b &#x3D; 0;</span><br><span class="line">            b &#x3D; a + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;变量c使用之前已经销毁的变量b占据的slot的位置</span><br><span class="line">        int c &#x3D; a + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c重用失效局部变量b的槽位</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/015.png"  alt="jvm"></p>
<h4 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h4><h5 id="按照类型分"><a href="#按照类型分" class="headerlink" title="按照类型分"></a>按照类型分</h5><p>基本数据类型，引用数据类型</p>
<h5 id="按照在类中声明的位置分"><a href="#按照在类中声明的位置分" class="headerlink" title="按照在类中声明的位置分"></a>按照在类中声明的位置分</h5><h6 id="成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量"><a href="#成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量" class="headerlink" title="成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量"></a>成员变量：在使用前，都经历过默认初始化赋值，类变量和实例变量都属于成员变量</h6><p>类变量：静态成员变量，linking的prepare阶段，给类变量默认赋值，给类变量显示赋值即静态代码块墨汁</p>
<p>实例变量：普通成员变量，随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</p>
<h6 id="局部变量：在使用前，必须进行显示赋值，否则，编译不通过"><a href="#局部变量：在使用前，必须进行显示赋值，否则，编译不通过" class="headerlink" title="局部变量：在使用前，必须进行显示赋值，否则，编译不通过"></a>局部变量：在使用前，必须进行显示赋值，否则，编译不通过</h6><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>栈可以使用数组或者链表来实现，操作数栈是通过数组实现的</p>
<p>Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</p>
<p>操作数栈的作用是执行数据计算操作，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据</p>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/016.png"  alt="jvm"></p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</p>
<p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p>
<p>操作数栈的长度也是在编译器确定的，与局部变量表长度无关</p>
<h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作需要使用更多的入栈和出栈指令，这意味着需要更多的指令分派次数和内存读写次数</p>
<p>栈顶缓存技术可以解决这个问题，将栈顶元素全部缓存在物理cpu的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率</p>
<h3 id="动态链接-指向运行时常量池的方法引用"><a href="#动态链接-指向运行时常量池的方法引用" class="headerlink" title="动态链接(指向运行时常量池的方法引用)"></a>动态链接(指向运行时常量池的方法引用)</h3><p>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。目的是支持当前方法的代码能够实现动态链接</p>
<p>在Java源文件被编译到字节码文件中时所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/018.png"  alt="jvm"></p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>存放调用该方法的pc寄存器的值，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址，而通过异常退出的，返回地址是要通过异常表来确定</p>
<p>方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置pc寄存器的值等，让调用者方法接着执行下去</p>
<p>正常完成方法调用和异常完成的区别在于：通过异常完成方法退出的不会给他的上层调用者产生任何返回值</p>
<p>异常表存储的是某行出现异常之后，跳转到哪一行，按照那一行进行处理的数据</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/019.png"  alt="jvm"></p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</p>
<p>本地方法栈也是线程私有的</p>
<p>本地方法栈的具体做法是在Native Method Stack中登记native方法，在执行引擎执行时加载本地方法库</p>
<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机拥有相同的权限</p>
<p>并不是所有的虚拟机都支持本地方法，在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一</p>
<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><p>本地接口的作用是融合不同语言的为Java所用，初衷是融合C/C++程序</p>
<p>标识符native可以和除abstract以外的修饰符连用</p>
<h3 id="为什么要使用Native-Method"><a href="#为什么要使用Native-Method" class="headerlink" title="为什么要使用Native Method"></a>为什么要使用Native Method</h3><h4 id="与其他语言交互"><a href="#与其他语言交互" class="headerlink" title="与其他语言交互"></a>与其他语言交互</h4><p>有时Java应用需要与Java外面的环境交互，本地方法接口可以屏蔽其他语言的复杂性</p>
<h4 id="与操作系统交互"><a href="#与操作系统交互" class="headerlink" title="与操作系统交互"></a>与操作系统交互</h4><p>操作系统底层是C/C++语言实现的，JVM部分也是C/C++语言实现的，所以使用本地接口是必然的</p>
<h4 id="提高执行效率"><a href="#提高执行效率" class="headerlink" title="提高执行效率"></a>提高执行效率</h4><p>当需要操作硬件的时候，C/C++是更好的选择，Java操作硬件考虑性能时需要使用本地接口</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>一个JVM实例只存在一个堆内存，堆可以处于物理上不连续的内存空间，但在逻辑上应该被视为连续的，即通过映射表使物理上不连续的内存空间在虚拟逻辑层面看起来是连续的，方便管理</p>
<p>几乎所有的对象实例以及数组都应当在运行时分配在堆上，虚拟机栈不存储数据只存储引用，引用指向堆中的实例对象数据</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/020.png"  alt="jvm"></p>
<p>方法结束之后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除，这样做的原因是方法结束就GC太过频繁，效率不高</p>
<p>堆是垃圾回收的重点区域，栈是不存在GC的，只有入栈出栈操作</p>
<h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><p>堆区是线程共享区，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的，为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度，所以有了TLAB的概念，为每个线程提供一个私有的区域，它包含在eden区中</p>
<p>堆中的数据除了TLAB(Thread Local Allocation Buffer)以外的区域都是线程共享的，TLAB是线程私有的，提高并发性，同时还能够提升内存分配的吞吐量</p>
<p>-XX:UserTLAB设置是否开启TLAB空间</p>
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/031.png"  alt="jvm"></p>
<p>默认的TLAB仅占eden空间的1%，可以通过-XX:TLABWasteTargetPercent设置占比</p>
<p>如果对象在TLAB空间分配内存失败，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在eden空间中分配内存</p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>现代垃圾收集器大部分都是基于分代收集理论设计</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/021.png"  alt="jvm"></p>
<p>永久代/元空间就是方法区，可以不看做堆空间的一部分</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/022.png"  alt="jvm"></p>
<p>-XX:+PrintGCDetails虚拟机指令可以在控制台打印相关的堆空间信息</p>
<h2 id="堆空间大小的设置和查看"><a href="#堆空间大小的设置和查看" class="headerlink" title="堆空间大小的设置和查看"></a>堆空间大小的设置和查看</h2><p>-X是jvm的运行参数，ms是memery start,mx是memery max</p>
<p>-Xms用于表示堆区的起始内存，等价于-XX:InitialHeapSize</p>
<p>-Xmx则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</p>
<p>一旦堆区中的内存大小超过-Xmx所指定的最大内存时，将会抛出OutOfMemoryError异常</p>
<p>默认情况下，初始内存大小：物理电脑内存/64；最大内存大小：物理电脑内存/4</p>
<p>通常会将-Xms和-Xmx两个参数配置相同的值，避免重复扩容，在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;返回Java虚拟机中的堆内存总量</span><br><span class="line">long initialMemory &#x3D; Runtime.getRuntime().totalMemory() &#x2F; 1024 &#x2F; 1024;</span><br><span class="line">&#x2F;&#x2F;返回Java虚拟机试图使用的最大堆内存量</span><br><span class="line">long maxMemory &#x3D; Runtime.getRuntime().maxMemory() &#x2F; 1024 &#x2F; 1024;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;-Xms : &quot; + initialMemory + &quot;M&quot;);</span><br><span class="line">System.out.println(&quot;-Xmx : &quot; + maxMemory + &quot;M&quot;);</span><br><span class="line">-----------------输出结果-----------------------------</span><br><span class="line">-Xms : 184M</span><br><span class="line">-Xmx : 2709M</span><br></pre></td></tr></table></figure>

<p>可以通过jps指令查看堆区使用状态，C结尾表示总量大小，U结尾表示已使用容量的大小</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/023.png"  alt="jvm"></p>
<p>在控制带打印的结果和通过jps指令打印的结果是相同的，注意堆中的年轻代s1，s2两个区域在一个线程堆中只能同时运行一个</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/024.png"  alt="jvm"></p>
<h2 id="OOM-OutOfMemory"><a href="#OOM-OutOfMemory" class="headerlink" title="OOM(OutOfMemory)"></a>OOM(OutOfMemory)</h2><p>内存溢出错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class OOMTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(20);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(new Picture(new Random().nextInt(1024 * 1024)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Picture&#123;</span><br><span class="line">    private byte[] pixels;</span><br><span class="line"></span><br><span class="line">    public Picture(int length) &#123;</span><br><span class="line">        this.pixels &#x3D; new byte[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------异常错误-----------------------------------</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.atguigu.java.Picture.&lt;init&gt;(OOMTest.java:29)</span><br><span class="line">	at com.atguigu.java.OOMTest.main(OOMTest.java:20)</span><br></pre></td></tr></table></figure>

<h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/025.png"  alt="jvm"></p>
<p>存储在JVM中的Java对象可以被分为两类</p>
<p>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常的迅速</p>
<p>一类是生命周期非常长，在某些极端情况下还能够与JVM的生命周期保持一致</p>
<h3 id="配置年轻代和老年代在堆结构中的占比"><a href="#配置年轻代和老年代在堆结构中的占比" class="headerlink" title="配置年轻代和老年代在堆结构中的占比"></a>配置年轻代和老年代在堆结构中的占比</h3><p>默认-XX:NewRatio=2,表示年轻代占1，老年代占2</p>
<p>可以修改为-XX:NewRatio=4,表示年轻代占1，老年代占4</p>
<h3 id="配置Eden区，两个Survivor的占比"><a href="#配置Eden区，两个Survivor的占比" class="headerlink" title="配置Eden区，两个Survivor的占比"></a>配置Eden区，两个Survivor的占比</h3><p>-XX:SurvivorRatio=8,设置eden,survivor的比例为8:1:1，默认占比是6:1:1</p>
<p>几乎所有的对象都是在eden区创建的，如果对象太大太多eden放不下就会用到老年代</p>
<p>绝大多数的Java对象的销毁都在新生代进行了</p>
<p>eden存活下来的对象会放到survivor区，再存活放到老年代中</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/026.png"  alt="jvm"></p>
<h3 id="配置年轻代的大小"><a href="#配置年轻代的大小" class="headerlink" title="配置年轻代的大小"></a>配置年轻代的大小</h3><p>-Xmn</p>
<p>当年轻代与老年代的比例和配置的年轻代的大小冲突时，以-Xmn为准</p>
<h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><p>虚拟机调优的主要目的就是降低GC的次数，提高性能</p>
<p>重点关注Major GC和Full GC因为这两个GC产生的暂停时间远远大于Minor GC</p>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p>对象创建优先使用eden</p>
<p>大对象直接分配到老年代，尽量避免程序中出现过多的大对象</p>
<p>长期存活的对象分配到老年代</p>
<p>动态对象年龄判断:如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一般，年龄大于或者等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄</p>
<p>空间分配担保:-XX:HandlerPromotionFailure,将Surivior区中存不下的对象放到老年代中存储</p>
<h3 id="YGC-Minor-GC"><a href="#YGC-Minor-GC" class="headerlink" title="YGC/Minor GC"></a>YGC/Minor GC</h3><p>eden区满了之后触发ygc，回收红色垃圾，绿色对象放到s0区并且添加年代计数器，此时s0作为from区，s1作为to区</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/027.png"  alt="jvm"></p>
<p>再次ygc的时候，eden存活的对象会存储到为空的s1区，s0区的存活对象也会转移s1区，此时s0就为空了，s1作为from区，s0作为to区</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/028.png"  alt="jvm"></p>
<p>往复循环，保证一个survivor区是为空的，作为to区</p>
<p>年代计数器达到阈值15之后，再gc就会将目标对象转移到老年代中</p>
<p>可以通过-XX:MaxTenuringThreshold=N来设置阈值</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/029.png"  alt="jvm"></p>
<p>survivor区复制之后有交换，谁空谁是to</p>
<p>GC频繁在年轻代收集，很少在老年代收集，几乎不在永久代/元空间收集，百分之八十的对象的生命周期在eden区就完成了，老年代空间更大，很少gc</p>
<p>eden区ygc之后一定是空的</p>
<p>eden区满的时候触发ygc，survivor区满的时候不会触发，会直接将对象放到老年代</p>
<p>当eden存储不下某个对象时，会直接将该对象创建存储在在老年代中，如果老年代也存放不下，那么会触发fgc之后再存储到老年代中</p>
<p><img src="/" class="lazyload" data-src="/2020/05/18/jvm/030.png"  alt="jvm"></p>
<h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>发生在老年代的GC,经常伴随至少一次的Minor GC(非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)，即一般在回收老年代垃圾之前会先回收年轻代的垃圾</p>
<p>如果Major GC之后还是内存不足，就会报OOM</p>
<p>Major GC的速度一般会比Minor GC慢十倍以上，STW时间更长</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>触发Full GC整堆收集执行有以下五个场景：</p>
<ol>
<li>调用System.gc()，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于来年代的可用内存</li>
<li>eden,form区向to区复制时,写入的对象大小大于to区内存，将该对象转存到老年代，且老年代的可用内存小于该对象</li>
</ol>
<p>Full GC时开发或者调优中尽量要避免的，避免线程暂停时间过长</p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>GC按照回收区域又分为两大类型：一种是部分收集(Partial GC)，一种是整堆收集(Full GC)</p>
<h3 id="部分收集-不是完整收集整个Java堆的垃圾收集"><a href="#部分收集-不是完整收集整个Java堆的垃圾收集" class="headerlink" title="部分收集:不是完整收集整个Java堆的垃圾收集"></a>部分收集:不是完整收集整个Java堆的垃圾收集</h3><p>新生代收集(Minor GC/Yong GC):只是年轻代的垃圾收集</p>
<p>老年代收集(Major GC/Old GC):只是老年代的垃圾收集</p>
<p>混合收集(Mixed GC):收集整个年轻代以及部分老年代的垃圾收集</p>
<p>目前只有CMS GC会有单独收集老年代的行为，只有G1 GC会有混合收集的行为</p>
<p> 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是eden区满，Survivor满不会引发GC，每次Minor GC会清理年轻代的内存(eden清空，Survivor转移)</p>
<p>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，回收速度也快</p>
<p>Minor GC会引发STW(stop the world),暂停其他用户的线程，等垃圾回收结束，用户线程才会恢复</p>
<h3 id="整堆收集-Full-GC-收集整个Java堆和方法区的垃圾收集"><a href="#整堆收集-Full-GC-收集整个Java堆和方法区的垃圾收集" class="headerlink" title="整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集"></a>整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集</h3><p>很多时候Major GC会和Full GC混淆使用，需要分清楚是老年代回收还是整堆回收</p>
<h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><p>-XX:+PrintGCDetails显示GC信息</p>
<h2 id="堆的参数设置"><a href="#堆的参数设置" class="headerlink" title="堆的参数设置"></a>堆的参数设置</h2><p>-XX:+PrintFlagsInitial:查看所有的参数的默认初始值</p>
<p>-XX:+PrintFlagsFinal:查看所有的参数的最终值(可能会存在修改，不再是初始值)</p>
<p>-Xms:初始堆空间内存(默认为物理内存的1/64)</p>
<p>-Xmx:最大堆空间内存(默认为物理内存的1/4)</p>
<p>-Xmn:设置新生代的大小(初始值及最大值)</p>
<p>-XX:NewRatio:配置年轻代与老年代在堆结构中的占比</p>
<p>-XX:SurvivorRatio:设置新生代eden和s0/s1空间的比例</p>
<p>-XX:MaxTenuringThreshole:设置新生代垃圾的最大年龄</p>
<p>-XX:+PrintGCDetails:输出详细的GC处理日志</p>
<p>-XX:HandlerPromotionFailure:是否设置空间分配担保</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">李上</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/18/jvm/">http://yoursite.com/2020/05/18/jvm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">定不辱使命</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/designpatterns.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/22/netty/"><img class="prev_cover lazyload" data-src="/img/netty.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Netty学习笔记</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/13/dubbo/"><img class="next_cover lazyload" data-src="/img/dubbo.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Dubbo入门学习</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 李上</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>